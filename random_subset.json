{
  "CWE-476": [
    {
      "commit_id": "0061f393de54cf0326621c079dc2988336d1ebb3",
      "filepath": "test/test1.cc",
      "project": "cpp-peglib",
      "project_repo_path": "symbol_backend_projects/cpp-peglib",
      "is_vulnerable": false,
      "func_name": "TEST_CASE",
      "func_body": "TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")\n{\n    parser parser(R\"(\n        ~ROOT <- _\n        _ <- ' '\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == false);\n}",
      "line_statements": [
        [
          37,
          "TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")"
        ],
        [
          38,
          "{"
        ],
        [
          39,
          "    parser parser(R\"("
        ],
        [
          40,
          "        ~ROOT <- _"
        ],
        [
          41,
          "        _ <- ' '"
        ],
        [
          42,
          "    )\");"
        ],
        [
          43,
          ""
        ],
        [
          44,
          "    bool ret = parser;"
        ],
        [
          45,
          "    REQUIRE(ret == false);"
        ],
        [
          46,
          "}"
        ]
      ],
      "statements": [
        [
          37,
          "TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")"
        ],
        [
          38,
          "{\n"
        ],
        [
          39,
          "parser parser(R\"(\n        ~ROOT <- _\n        _ <- ' '\n    )\");"
        ],
        [
          43,
          "\n"
        ],
        [
          44,
          "bool ret = parser;"
        ],
        [
          45,
          "REQUIRE(ret == false);"
        ],
        [
          46,
          "}"
        ]
      ],
      "cve": "CVE-2020-23914"
    },
    {
      "commit_id": "4df105f0ce9f6f30cda4e99f577150d23f0c9c5f",
      "filepath": "drivers/scsi/libfc/fc_lport.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "fc_lport_ptp_setup",
      "func_body": "static void fc_lport_ptp_setup(struct fc_lport *lport,\n\t\t\t       u32 remote_fid, u64 remote_wwpn,\n\t\t\t       u64 remote_wwnn)\n{\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tif (lport->ptp_rdata) {\n\t\tfc_rport_logoff(lport->ptp_rdata);\n\t\tkref_put(&lport->ptp_rdata->kref, fc_rport_destroy);\n\t}\n\tmutex_lock(&lport->disc.disc_mutex);\n\tlport->ptp_rdata = fc_rport_create(lport, remote_fid);\n\tkref_get(&lport->ptp_rdata->kref);\n\tlport->ptp_rdata->ids.port_name = remote_wwpn;\n\tlport->ptp_rdata->ids.node_name = remote_wwnn;\n\tmutex_unlock(&lport->disc.disc_mutex);\n\n\tfc_rport_login(lport->ptp_rdata);\n\n\tfc_lport_enter_ready(lport);\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2023-52809"
    },
    {
      "commit_id": "105cd17a866017b45f3c45901b394c711c97bf40",
      "filepath": "drivers/net/bonding/bond_main.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "bond_ipsec_add_sa",
      "func_body": "static int bond_ipsec_add_sa(struct xfrm_state *xs)\n{\n\tstruct net_device *bond_dev = xs->xso.dev;\n\tstruct bonding *bond;\n\tstruct slave *slave;\n\tint err;\n\n\tif (!bond_dev)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tbond = netdev_priv(bond_dev);\n\tslave = rcu_dereference(bond->curr_active_slave);\n\tif (!slave) {\n\t\trcu_read_unlock();\n\t\treturn -ENODEV;\n\t}\n\n\txs->xso.real_dev = slave->dev;\n\tbond->xs = xs;\n\n\tif (!(slave->dev->xfrmdev_ops\n\t      && slave->dev->xfrmdev_ops->xdo_dev_state_add)) {\n\t\tslave_warn(bond_dev, slave->dev, \"Slave does not support ipsec offload\\n\");\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\terr = slave->dev->xfrmdev_ops->xdo_dev_state_add(xs);\n\trcu_read_unlock();\n\treturn err;\n}\n",
      "line_statements": [
        [
          414,
          "\tif (!slave) {\n"
        ],
        [
          415,
          "\t\trcu_read_unlock();\n"
        ],
        [
          416,
          "\t\treturn -ENODEV;\n"
        ],
        [
          417,
          "\t}\n"
        ],
        [
          418,
          "\n"
        ]
      ],
      "statements": [
        [
          414,
          "if (!slave)"
        ],
        [
          415,
          "rcu_read_unlock();"
        ],
        [
          416,
          "return -ENODEV;"
        ],
        [
          417,
          "\t}\n"
        ],
        [
          418,
          "\n"
        ]
      ],
      "cve": "CVE-2022-0286"
    },
    {
      "commit_id": "a7aeb03888b92304e2fc7d4d1c242f54a312561b",
      "filepath": "drivers/gpu/drm/amd/display/dc/hwss/dcn10/dcn10_hwseq.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "dcn10_set_drr",
      "func_body": "void dcn10_set_drr(struct pipe_ctx **pipe_ctx,\n\t\tint num_pipes, struct dc_crtc_timing_adjust adjust)\n{\n\tint i = 0;\n\tstruct drr_params params = {0};\n\t// DRR set trigger event mapped to OTG_TRIG_A (bit 11) for manual control flow\n\tunsigned int event_triggers = 0x800;\n\t// Note DRR trigger events are generated regardless of whether num frames met.\n\tunsigned int num_frames = 2;\n\n\tparams.vertical_total_max = adjust.v_total_max;\n\tparams.vertical_total_min = adjust.v_total_min;\n\tparams.vertical_total_mid = adjust.v_total_mid;\n\tparams.vertical_total_mid_frame_num = adjust.v_total_mid_frame_num;\n\t/* TODO: If multiple pipes are to be supported, you need\n\t * some GSL stuff. Static screen triggers may be programmed differently\n\t * as well.\n\t */\n\tfor (i = 0; i < num_pipes; i++) {\n\t\t/* dc_state_destruct() might null the stream resources, so fetch tg\n\t\t * here first to avoid a race condition. The lifetime of the pointee\n\t\t * itself (the timing_generator object) is not a problem here.\n\t\t */\n\t\tstruct timing_generator *tg = pipe_ctx[i]->stream_res.tg;\n\n\t\tif ((tg != NULL) && tg->funcs) {\n\t\t\tif (tg->funcs->set_drr)\n\t\t\t\ttg->funcs->set_drr(tg, &params);\n\t\t\tif (adjust.v_total_max != 0 && adjust.v_total_min != 0)\n\t\t\t\tif (tg->funcs->set_static_screen_control)\n\t\t\t\t\ttg->funcs->set_static_screen_control(\n\t\t\t\t\t\ttg, event_triggers, num_frames);\n\t\t}\n\t}\n}\n",
      "line_statements": [
        [
          3210,
          "\t\t/* dc_state_destruct() might null the stream resources, so fetch tg\n"
        ],
        [
          3211,
          "\t\t * here first to avoid a race condition. The lifetime of the pointee\n"
        ],
        [
          3212,
          "\t\t * itself (the timing_generator object) is not a problem here.\n"
        ],
        [
          3213,
          "\t\t */\n"
        ],
        [
          3214,
          "\t\tstruct timing_generator *tg = pipe_ctx[i]->stream_res.tg;\n"
        ],
        [
          3215,
          "\n"
        ],
        [
          3216,
          "\t\tif ((tg != NULL) && tg->funcs) {\n"
        ],
        [
          3217,
          "\t\t\tif (tg->funcs->set_drr)\n"
        ],
        [
          3218,
          "\t\t\t\ttg->funcs->set_drr(tg, &params);\n"
        ],
        [
          3220,
          "\t\t\t\tif (tg->funcs->set_static_screen_control)\n"
        ],
        [
          3221,
          "\t\t\t\t\ttg->funcs->set_static_screen_control(\n"
        ],
        [
          3222,
          "\t\t\t\t\t\ttg, event_triggers, num_frames);\n"
        ]
      ],
      "statements": [
        [
          3210,
          "/* dc_state_destruct() might null the stream resources, so fetch tg\n\t\t * here first to avoid a race condition. The lifetime of the pointee\n\t\t * itself (the timing_generator object) is not a problem here.\n\t\t */"
        ],
        [
          3214,
          "struct timing_generator *tg = pipe_ctx[i]->stream_res.tg;"
        ],
        [
          3215,
          "\n"
        ],
        [
          3216,
          "if ((tg != NULL) && tg->funcs)"
        ],
        [
          3217,
          "if (tg->funcs->set_drr)"
        ],
        [
          3218,
          "tg->funcs->set_drr(tg, &params);"
        ],
        [
          3220,
          "if (tg->funcs->set_static_screen_control)"
        ],
        [
          3221,
          "tg->funcs->set_static_screen_control(\n\t\t\t\t\t\ttg, event_triggers, num_frames);"
        ]
      ],
      "cve": "CVE-2024-46851"
    },
    {
      "commit_id": "973a57891608a98e894db2887f278777f564de18",
      "filepath": "drivers/usb/gadget/udc/core.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "usb_ep_enable",
      "func_body": "int usb_ep_enable(struct usb_ep *ep)\n{\n\tint ret = 0;\n\n\tif (ep->enabled)\n\t\tgoto out;\n\n\t/* UDC drivers can't handle endpoints with maxpacket size 0 */\n\tif (!ep->desc || usb_endpoint_maxp(ep->desc) == 0) {\n\t\tWARN_ONCE(1, \"%s: ep%d (%s) has %s\\n\", __func__, ep->address, ep->name,\n\t\t\t  (!ep->desc) ? \"NULL descriptor\" : \"maxpacket 0\");\n\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ep->ops->enable(ep, ep->desc);\n\tif (ret)\n\t\tgoto out;\n\n\tep->enabled = true;\n\nout:\n\ttrace_usb_ep_enable(ep, ret);\n\n\treturn ret;\n}\n",
      "line_statements": [
        [
          121,
          "\tif (!ep->desc || usb_endpoint_maxp(ep->desc) == 0) {\n"
        ],
        [
          122,
          "\t\tWARN_ONCE(1, \"%s: ep%d (%s) has %s\\n\", __func__, ep->address, ep->name,\n"
        ],
        [
          123,
          "\t\t\t  (!ep->desc) ? \"NULL descriptor\" : \"maxpacket 0\");\n"
        ],
        [
          124,
          "\n"
        ]
      ],
      "statements": [
        [
          121,
          "if (!ep->desc || usb_endpoint_maxp(ep->desc) == 0)"
        ],
        [
          122,
          "WARN_ONCE(1, \"%s: ep%d (%s) has %s\\n\", __func__, ep->address, ep->name,\n\t\t\t  (!ep->desc) ? \"NULL descriptor\" : \"maxpacket 0\");"
        ],
        [
          124,
          "\n"
        ]
      ],
      "cve": "CVE-2024-44960"
    },
    {
      "commit_id": "8e64d2356cbc800b4cd0e3e614797f76bcf0cdb8",
      "filepath": "drivers/s390/block/dasd_devmap.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "dasd_copy_pair_store",
      "func_body": "static ssize_t dasd_copy_pair_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct dasd_devmap *prim_devmap, *sec_devmap;\n\tchar prim_busid[DASD_BUS_ID_SIZE];\n\tchar sec_busid[DASD_BUS_ID_SIZE];\n\tstruct dasd_copy_relation *copy;\n\tstruct dasd_device *device;\n\tbool pprc_enabled;\n\tint rc;\n\n\tif (strncmp(buf, \"clear\", strlen(\"clear\")) == 0) {\n\t\tif (dasd_devmap_clear_copy_relation(dev))\n\t\t\treturn -EINVAL;\n\t\treturn count;\n\t}\n\n\trc = dasd_devmap_parse_busid(buf, prim_busid, sec_busid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (strncmp(dev_name(dev), prim_busid, DASD_BUS_ID_SIZE) != 0 &&\n\t    strncmp(dev_name(dev), sec_busid, DASD_BUS_ID_SIZE) != 0)\n\t\treturn -EINVAL;\n\n\t/* allocate primary devmap if needed */\n\tprim_devmap = dasd_find_busid(prim_busid);\n\tif (IS_ERR(prim_devmap))\n\t\tprim_devmap = dasd_add_busid(prim_busid, DASD_FEATURE_DEFAULT);\n\n\t/* allocate secondary devmap if needed */\n\tsec_devmap = dasd_find_busid(sec_busid);\n\tif (IS_ERR(sec_devmap))\n\t\tsec_devmap = dasd_add_busid(sec_busid, DASD_FEATURE_DEFAULT);\n\n\t/* setting copy relation is only allowed for offline secondary */\n\tif (sec_devmap->device)\n\t\treturn -EINVAL;\n\n\tif (prim_devmap->copy) {\n\t\tcopy = prim_devmap->copy;\n\t} else if (sec_devmap->copy) {\n\t\tcopy = sec_devmap->copy;\n\t} else {\n\t\tcopy = kzalloc(sizeof(*copy), GFP_KERNEL);\n\t\tif (!copy)\n\t\t\treturn -ENOMEM;\n\t}\n\tspin_lock(&dasd_devmap_lock);\n\trc = dasd_devmap_set_copy_relation(prim_devmap, copy, prim_busid, true);\n\tif (rc) {\n\t\tspin_unlock(&dasd_devmap_lock);\n\t\treturn rc;\n\t}\n\trc = dasd_devmap_set_copy_relation(sec_devmap, copy, sec_busid, false);\n\tif (rc) {\n\t\tspin_unlock(&dasd_devmap_lock);\n\t\treturn rc;\n\t}\n\tspin_unlock(&dasd_devmap_lock);\n\n\t/* if primary device is already online call device setup directly */\n\tif (prim_devmap->device && !prim_devmap->device->copy) {\n\t\tdevice = prim_devmap->device;\n\t\tif (device->discipline->pprc_enabled) {\n\t\t\tpprc_enabled = device->discipline->pprc_enabled(device);\n\t\t\trc = dasd_devmap_set_device_copy_relation(device->cdev,\n\t\t\t\t\t\t\t\t  pprc_enabled);\n\t\t} else {\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t}\n\tif (rc) {\n\t\tdasd_devmap_del_copy_relation(copy, prim_busid);\n\t\tdasd_devmap_del_copy_relation(copy, sec_busid);\n\t\tcount = rc;\n\t}\n\n\treturn count;\n}\n",
      "line_statements": [
        [
          2251,
          "\tif (IS_ERR(prim_devmap))\n"
        ],
        [
          2256,
          "\tif (IS_ERR(sec_devmap))\n"
        ]
      ],
      "statements": [
        [
          2251,
          "if (IS_ERR(prim_devmap))"
        ],
        [
          2256,
          "if (IS_ERR(sec_devmap))"
        ]
      ],
      "cve": "CVE-2024-42320"
    },
    {
      "commit_id": "5a6248c0a22352f09ea041665d3bd3e18f6f872c",
      "filepath": "drivers/net/wireless/intel/iwlwifi/mvm/debugfs.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "iwl_mvm_dbgfs_register",
      "func_body": "void iwl_mvm_dbgfs_register(struct iwl_mvm *mvm)\n{\n\tstruct dentry *bcast_dir __maybe_unused;\n\n\tspin_lock_init(&mvm->drv_stats_lock);\n\n\tMVM_DEBUGFS_ADD_FILE(tx_flush, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(sta_drain, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(sram, mvm->debugfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE(set_nic_temperature, mvm->debugfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE(nic_temp, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(ctdp_budget, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(stop_ctdp, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(force_ctkill, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(stations, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(bt_notif, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(bt_cmd, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(disable_power_off, mvm->debugfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE(fw_ver, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(fw_rx_stats, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(drv_rx_stats, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(fw_restart, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(fw_nmi, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(bt_tx_prio, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(bt_force_ant, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(scan_ant_rxchain, mvm->debugfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE(prph_reg, mvm->debugfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE(fw_dbg_conf, mvm->debugfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE(fw_dbg_collect, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(dbg_time_point, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(send_echo_cmd, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(indirection_tbl, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(inject_packet, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(inject_beacon_ie, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(inject_beacon_ie_restore, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(rfi_freq_table, mvm->debugfs_dir, 0600);\n\n\tif (mvm->fw->phy_integration_ver)\n\t\tMVM_DEBUGFS_ADD_FILE(phy_integration_ver, mvm->debugfs_dir, 0400);\n// #ifdef CONFIG_ACPI\n\tMVM_DEBUGFS_ADD_FILE(sar_geo_profile, mvm->debugfs_dir, 0400);\n#endif\n\tMVM_DEBUGFS_ADD_FILE(he_sniffer_params, mvm->debugfs_dir, 0600);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_SET_LTR_GEN2))\n\t\tMVM_DEBUGFS_ADD_FILE(ltr_config, mvm->debugfs_dir, 0200);\n\n\tdebugfs_create_bool(\"enable_scan_iteration_notif\", 0600,\n\t\t\t    mvm->debugfs_dir, &mvm->scan_iter_notif_enabled);\n\tdebugfs_create_bool(\"drop_bcn_ap_mode\", 0600, mvm->debugfs_dir,\n\t\t\t    &mvm->drop_bcn_ap_mode);\n\n\tMVM_DEBUGFS_ADD_FILE(uapsd_noagg_bssids, mvm->debugfs_dir, S_IRUSR);\n\n// #ifdef CONFIG_PM_SLEEP\n\tMVM_DEBUGFS_ADD_FILE(d3_test, mvm->debugfs_dir, 0400);\n\tdebugfs_create_bool(\"d3_wake_sysassert\", 0600, mvm->debugfs_dir,\n\t\t\t    &mvm->d3_wake_sysassert);\n\tdebugfs_create_u32(\"last_netdetect_scans\", 0400, mvm->debugfs_dir,\n\t\t\t   &mvm->last_netdetect_scans);\n#endif\n\n\tdebugfs_create_u8(\"ps_disabled\", 0400, mvm->debugfs_dir,\n\t\t\t  &mvm->ps_disabled);\n\tdebugfs_create_blob(\"nvm_hw\", 0400, mvm->debugfs_dir,\n\t\t\t    &mvm->nvm_hw_blob);\n\tdebugfs_create_blob(\"nvm_sw\", 0400, mvm->debugfs_dir,\n\t\t\t    &mvm->nvm_sw_blob);\n\tdebugfs_create_blob(\"nvm_calib\", 0400, mvm->debugfs_dir,\n\t\t\t    &mvm->nvm_calib_blob);\n\tdebugfs_create_blob(\"nvm_prod\", 0400, mvm->debugfs_dir,\n\t\t\t    &mvm->nvm_prod_blob);\n\tdebugfs_create_blob(\"nvm_phy_sku\", 0400, mvm->debugfs_dir,\n\t\t\t    &mvm->nvm_phy_sku_blob);\n\tdebugfs_create_blob(\"nvm_reg\", S_IRUSR,\n\t\t\t    mvm->debugfs_dir, &mvm->nvm_reg_blob);\n\n\tdebugfs_create_file(\"mem\", 0600, mvm->debugfs_dir, mvm,\n\t\t\t    &iwl_dbgfs_mem_ops);\n\n\t/*\n\t * Create a symlink with mac80211. It will be removed when mac80211\n\t * exists (before the opmode exists which removes the target.)\n\t */\n\tif (!IS_ERR(mvm->debugfs_dir)) {\n\t\tchar buf[100];\n\n\t\tsnprintf(buf, 100, \"../../%pd2\", mvm->debugfs_dir->d_parent);\n\t\tdebugfs_create_symlink(\"iwlwifi\", mvm->hw->wiphy->debugfsdir,\n\t\t\t\t       buf);\n\t}\n}\n",
      "line_statements": [
        [
          1942,
          "\tif (!IS_ERR(mvm->debugfs_dir)) {\n"
        ],
        [
          1943,
          "\t\tchar buf[100];\n"
        ],
        [
          1944,
          "\n"
        ],
        [
          1945,
          "\t\tsnprintf(buf, 100, \"../../%pd2\", mvm->debugfs_dir->d_parent);\n"
        ],
        [
          1946,
          "\t\tdebugfs_create_symlink(\"iwlwifi\", mvm->hw->wiphy->debugfsdir,\n"
        ],
        [
          1947,
          "\t\t\t\t       buf);\n"
        ],
        [
          1948,
          "\t}\n"
        ]
      ],
      "statements": [
        [
          1942,
          "if (!IS_ERR(mvm->debugfs_dir))"
        ],
        [
          1943,
          "char buf[100];"
        ],
        [
          1944,
          "\n"
        ],
        [
          1945,
          "snprintf(buf, 100, \"../../%pd2\", mvm->debugfs_dir->d_parent);"
        ],
        [
          1946,
          "debugfs_create_symlink(\"iwlwifi\", mvm->hw->wiphy->debugfsdir,\n\t\t\t\t       buf);"
        ],
        [
          1948,
          "\t}\n"
        ]
      ],
      "cve": "CVE-2022-48918"
    },
    {
      "commit_id": "49a940dbdc3107fecd5e6d3063dc07128177e058",
      "filepath": "arch/powerpc/platforms/pseries/iommu.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "pci_dma_bus_setup_pSeriesLP",
      "func_body": "static void pci_dma_bus_setup_pSeriesLP(struct pci_bus *bus)\n{\n\tstruct iommu_table *tbl;\n\tstruct device_node *dn, *pdn;\n\tstruct pci_dn *ppci;\n\tstruct dynamic_dma_window_prop prop;\n\n\tdn = pci_bus_to_OF_node(bus);\n\n\tpr_debug(\"pci_dma_bus_setup_pSeriesLP: setting up bus %pOF\\n\",\n\t\t dn);\n\n\tpdn = pci_dma_find(dn, &prop);\n\n\t/* In PPC architecture, there will always be DMA window on bus or one of the\n\t * parent bus. During reboot, there will be ibm,dma-window property to\n\t * define DMA window. For kdump, there will at least be default window or DDW\n\t * or both.\n\t * There is an exception to the above. In case the PE goes into frozen\n\t * state, firmware may not provide ibm,dma-window property at the time\n\t * of LPAR boot up.\n\t */\n\n\tif (!pdn) {\n\t\tpr_debug(\"  no ibm,dma-window property !\\n\");\n\t\treturn;\n\t}\n\n\tppci = PCI_DN(pdn);\n\n\tpr_debug(\"  parent is %pOF, iommu_table: 0x%p\\n\",\n\t\t pdn, ppci->table_group);\n\n\tif (!ppci->table_group) {\n\t\tppci->table_group = iommu_pseries_alloc_group(ppci->phb->node);\n\t\ttbl = ppci->table_group->tables[0];\n\n\t\tiommu_table_setparms_common(tbl, ppci->phb->bus->number,\n\t\t\t\tbe32_to_cpu(prop.liobn),\n\t\t\t\tbe64_to_cpu(prop.dma_base),\n\t\t\t\t1ULL << be32_to_cpu(prop.window_shift),\n\t\t\t\tbe32_to_cpu(prop.tce_shift), NULL,\n\t\t\t\t&iommu_table_lpar_multi_ops);\n\n\t\t/* Only for normal boot with default window. Doesn't matter even\n\t\t * if we set these with DDW which is 64bit during kdump, since\n\t\t * these will not be used during kdump.\n\t\t */\n\t\tppci->table_group->tce32_start = be64_to_cpu(prop.dma_base);\n\t\tppci->table_group->tce32_size = 1 << be32_to_cpu(prop.window_shift);\n\n\t\tif (!iommu_init_table(tbl, ppci->phb->node, 0, 0))\n\t\t\tpanic(\"Failed to initialize iommu table\");\n\n\t\tiommu_register_group(ppci->table_group,\n\t\t\t\tpci_domain_nr(bus), 0);\n\t\tpr_debug(\"  created table: %p\\n\", ppci->table_group);\n\t}\n}\n",
      "line_statements": [
        [
          789,
          "\t * There is an exception to the above. In case the PE goes into frozen\n"
        ],
        [
          790,
          "\t * state, firmware may not provide ibm,dma-window property at the time\n"
        ],
        [
          791,
          "\t * of LPAR boot up.\n"
        ],
        [
          794,
          "\tif (!pdn) {\n"
        ],
        [
          795,
          "\t\tpr_debug(\"  no ibm,dma-window property !\\n\");\n"
        ],
        [
          796,
          "\t\treturn;\n"
        ],
        [
          797,
          "\t}\n"
        ],
        [
          798,
          "\n"
        ]
      ],
      "statements": [
        [
          785,
          "/* In PPC architecture, there will always be DMA window on bus or one of the\n\t * parent bus. During reboot, there will be ibm,dma-window property to\n\t * define DMA window. For kdump, there will at least be default window or DDW\n\t * or both.\n\t * There is an exception to the above. In case the PE goes into frozen\n\t * state, firmware may not provide ibm,dma-window property at the time\n\t * of LPAR boot up.\n\t */"
        ],
        [
          794,
          "if (!pdn)"
        ],
        [
          795,
          "pr_debug(\"  no ibm,dma-window property !\\n\");"
        ],
        [
          796,
          "return;"
        ],
        [
          797,
          "\t}\n"
        ],
        [
          798,
          "\n"
        ]
      ],
      "cve": "CVE-2024-36926"
    },
    {
      "commit_id": "ebfa346eff05049718f7b80041093b4c5581c24e",
      "filepath": "src/isomedia/isom_read.c",
      "project": "gpac",
      "project_repo_path": "symbol_backend_projects/gpac",
      "is_vulnerable": false,
      "func_name": "gf_isom_guess_specification",
      "func_body": "GF_EXPORT\nu32 gf_isom_guess_specification(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_m4s, nb_a, nb_v, nb_auxv,nb_scene, nb_od, nb_mp3, nb_aac, nb_m4v, nb_avc, nb_amr, nb_h263, nb_qcelp, nb_evrc, nb_smv, nb_text, nb_pict;\n\n\tnb_m4s = nb_a = nb_v = nb_auxv = nb_any = nb_scene = nb_od = nb_mp3 = nb_aac = nb_m4v = nb_avc = nb_amr = nb_h263 = nb_qcelp = nb_evrc = nb_smv = nb_text = nb_pict = 0;\n\n\tif (file->is_jp2) {\n\t\tif (file->moov) return GF_ISOM_BRAND_MJP2;\n\t\treturn GF_ISOM_BRAND_JP2;\n\t}\n\tif (!file->moov) {\n\t\tif (!file->meta || !file->meta->handler) return 0;\n\t\treturn file->meta->handler->handlerType;\n\t}\n\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tu32 mstype = gf_isom_get_media_subtype(file, i+1, 1);\n\n\t\tif (mtype==GF_ISOM_MEDIA_SCENE) {\n\t\t\tnb_scene++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t} else if (mtype==GF_ISOM_MEDIA_OD) {\n\t\t\tnb_od++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t}\n\t\telse if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT)) nb_text++;\n\t\telse if ((mtype==GF_ISOM_MEDIA_AUDIO) || gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tswitch (mstype) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tnb_amr++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tnb_h263++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tnb_evrc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tnb_qcelp++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tnb_smv++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\t{\n\t\t\t\tGF_DecoderConfig *dcd = gf_isom_get_decoder_config(file, i+1, 1);\n\t\t\t\tif (!dcd) break;\n\t\t\t\tswitch (dcd->streamType) {\n\t\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\t\tif (dcd->objectTypeIndication==GF_CODECID_MPEG4_PART2) nb_m4v++;\n\t\t\t\t\telse if ((dcd->objectTypeIndication==GF_CODECID_AVC) || (dcd->objectTypeIndication==GF_CODECID_SVC) || (dcd->objectTypeIndication==GF_CODECID_MVC)) nb_avc++;\n\t\t\t\t\telse nb_v++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\t\tswitch (dcd->objectTypeIndication) {\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\t\t\t\tnb_aac++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\t\tnb_mp3++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\t\tnb_evrc++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\t\tnb_smv++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\t\tnb_qcelp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tnb_a++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/*SHOULD NEVER HAPPEN - IF SO, BROKEN MPEG4 FILE*/\n\t\t\t\tdefault:\n\t\t\t\t\tnb_any++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)dcd);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (mtype==GF_ISOM_MEDIA_VISUAL) nb_v++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_AUXV) nb_auxv++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_PICT) nb_pict++;\n\t\t\t\telse nb_a++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP)) nb_m4s++;\n\t\telse nb_any++;\n\t}\n\tif (nb_any) return GF_ISOM_BRAND_ISOM;\n\tif (nb_qcelp || nb_evrc || nb_smv) {\n\t\t/*non std mix of streams*/\n\t\tif (nb_m4s || nb_avc || nb_scene || nb_od || nb_mp3 || nb_a || nb_v) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_3G2A;\n\t}\n\t/*other a/v/s streams*/\n\tif (nb_v || nb_a || nb_m4s) return GF_ISOM_BRAND_MP42;\n\n\tnb_v = nb_m4v + nb_avc + nb_h263;\n\tnb_a = nb_mp3 + nb_aac + nb_amr;\n\n\t/*avc file: whatever has AVC and no systems*/\n\tif (nb_avc) {\n\t\tif (!nb_scene && !nb_od) return GF_ISOM_BRAND_AVC1;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP3: ISMA and MPEG4*/\n\tif (nb_mp3) {\n\t\tif (!nb_text && (nb_v<=1) && (nb_a<=1) && (nb_scene==1) && (nb_od==1))\n\t\t\treturn GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP4*/\n\tif (nb_scene || nb_od) {\n\t\t/*issue with AMR and H263 which don't have MPEG mapping: non compliant file*/\n\t\tif (nb_amr || nb_h263) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*use ISMA (3GP fine too)*/\n\tif (!nb_amr && !nb_h263 && !nb_text) {\n\t\tif ((nb_v<=1) && (nb_a<=1)) return GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\n\tif ((nb_v<=1) && (nb_a<=1) && (nb_text<=1)) return nb_text ? GF_ISOM_BRAND_3GP6 : GF_ISOM_BRAND_3GP5;\n\treturn GF_ISOM_BRAND_3GG6;",
      "line_statements": [
        [
          3906,
          "\t\t\t\tif (!dcd) break;"
        ]
      ],
      "statements": [
        [
          3906,
          "if (!dcd)"
        ]
      ],
      "cve": "CVE-2021-31258"
    },
    {
      "commit_id": "3dd384108d53834002be5630132ad5c3f32166ad",
      "filepath": "security/apparmor/apparmorfs.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "__aafs_profile_mkdir",
      "func_body": "int __aafs_profile_mkdir(struct aa_profile *profile, struct dentry *parent)\n{\n\tstruct aa_profile *child;\n\tstruct dentry *dent = NULL, *dir;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mutex_is_locked(&profiles_ns(profile)->lock));\n\n\tif (!parent) {\n\t\tstruct aa_profile *p;\n\t\tp = aa_deref_parent(profile);\n\t\tdent = prof_dir(p);\n\t\t/* adding to parent that previously didn't have children */\n\t\tdent = aafs_create_dir(\"profiles\", dent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprof_child_dir(p) = parent = dent;\n\t}\n\n\tif (!profile->dirname) {\n\t\tint len, id_len;\n\t\tlen = mangle_name(profile->base.name, NULL);\n\t\tid_len = snprintf(NULL, 0, \".%ld\", profile->ns->uniq_id);\n\n\t\tprofile->dirname = kmalloc(len + id_len + 1, GFP_KERNEL);\n\t\tif (!profile->dirname) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tmangle_name(profile->base.name, profile->dirname);\n\t\tsprintf(profile->dirname + len, \".%ld\", profile->ns->uniq_id++);\n\t}\n\n\tdent = aafs_create_dir(profile->dirname, parent);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprof_dir(profile) = dir = dent;\n\n\tdent = create_profile_file(dir, \"name\", profile,\n\t\t\t\t   &seq_profile_name_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_NAME] = dent;\n\n\tdent = create_profile_file(dir, \"mode\", profile,\n\t\t\t\t   &seq_profile_mode_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_MODE] = dent;\n\n\tdent = create_profile_file(dir, \"attach\", profile,\n\t\t\t\t   &seq_profile_attach_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_ATTACH] = dent;\n\n\tif (profile->hash) {\n\t\tdent = create_profile_file(dir, \"sha256\", profile,\n\t\t\t\t\t   &seq_profile_hash_fops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_HASH] = dent;\n\t}\n\n// #ifdef CONFIG_SECURITY_APPARMOR_EXPORT_BINARY\n\tif (profile->rawdata) {\n\t\tif (aa_g_hash_policy) {\n\t\t\tdent = aafs_create(\"raw_sha256\", S_IFLNK | 0444, dir,\n\t\t\t\t\t   profile->label.proxy, NULL, NULL,\n\t\t\t\t\t   &rawdata_link_sha256_iops);\n\t\t\tif (IS_ERR(dent))\n\t\t\t\tgoto fail;\n\t\t\taa_get_proxy(profile->label.proxy);\n\t\t\tprofile->dents[AAFS_PROF_RAW_HASH] = dent;\n\t\t}\n\t\tdent = aafs_create(\"raw_abi\", S_IFLNK | 0444, dir,\n\t\t\t\t   profile->label.proxy, NULL, NULL,\n\t\t\t\t   &rawdata_link_abi_iops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\taa_get_proxy(profile->label.proxy);\n\t\tprofile->dents[AAFS_PROF_RAW_ABI] = dent;\n\n\t\tdent = aafs_create(\"raw_data\", S_IFLNK | 0444, dir,\n\t\t\t\t   profile->label.proxy, NULL, NULL,\n\t\t\t\t   &rawdata_link_data_iops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\taa_get_proxy(profile->label.proxy);\n\t\tprofile->dents[AAFS_PROF_RAW_DATA] = dent;\n\t}\n#endif /*CONFIG_SECURITY_APPARMOR_EXPORT_BINARY */\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, prof_child_dir(profile));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_profile_rmdir(profile);\n\n\treturn error;\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2024-46721"
    },
    {
      "commit_id": "ff70c47a396ef1e3cb73c90513da4f5cb71bebba",
      "filepath": "tensorflow/core/kernels/session_ops.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tensorflow::DeleteSessionTensorOp::Compute",
      "func_body": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n  }",
      "line_statements": [
        [
          136,
          "    auto session_state = ctx->session_state();"
        ],
        [
          137,
          "    OP_REQUIRES(ctx, session_state != nullptr,"
        ],
        [
          138,
          "                errors::FailedPrecondition("
        ],
        [
          139,
          "                    \"DeleteSessionTensor called on null session state\"));"
        ],
        [
          140,
          "    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));"
        ]
      ],
      "statements": [
        [
          136,
          "auto session_state = ctx->session_state();"
        ],
        [
          137,
          "OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\"));"
        ],
        [
          138,
          "errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\")"
        ],
        [
          140,
          "OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));"
        ]
      ],
      "cve": "CVE-2021-29518"
    },
    {
      "commit_id": "afca6c5b2595fc44383919fba740c194b0b76aff",
      "filepath": "fs/xfs/xfs_icache.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "xfs_iget_check_free_state",
      "func_body": "xfs_iget_check_free_state(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tif (flags & XFS_IGET_CREATE) {\n\t\t/* should be a free inode */\n\t\tif (VFS_I(ip)->i_mode != 0) {\n\t\t\txfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)\",\n\t\t\t\tip->i_ino, VFS_I(ip)->i_mode);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tif (ip->i_d.di_nblocks != 0) {\n\t\t\txfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n\t\t\t\tip->i_ino);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* should be an allocated inode */\n\tif (VFS_I(ip)->i_mode == 0)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
      "line_statements": [
        [
          322,
          "xfs_iget_check_free_state("
        ],
        [
          323,
          "\tstruct xfs_inode\t*ip,"
        ],
        [
          324,
          "\tint\t\t\tflags)"
        ],
        [
          325,
          "{"
        ],
        [
          326,
          "\tif (flags & XFS_IGET_CREATE) {"
        ],
        [
          328,
          "\t\tif (VFS_I(ip)->i_mode != 0) {"
        ],
        [
          329,
          "\t\t\txfs_warn(ip->i_mount,"
        ],
        [
          330,
          "\"Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)\","
        ],
        [
          331,
          "\t\t\t\tip->i_ino, VFS_I(ip)->i_mode);"
        ],
        [
          332,
          "\t\t\treturn -EFSCORRUPTED;"
        ],
        [
          333,
          "\t\t}"
        ],
        [
          334,
          ""
        ],
        [
          335,
          "\t\tif (ip->i_d.di_nblocks != 0) {"
        ],
        [
          336,
          "\t\t\txfs_warn(ip->i_mount,"
        ],
        [
          337,
          "\"Corruption detected! Free inode 0x%llx has blocks allocated!\","
        ],
        [
          338,
          "\t\t\t\tip->i_ino);"
        ],
        [
          339,
          "\t\t\treturn -EFSCORRUPTED;"
        ],
        [
          340,
          "\t\t}"
        ],
        [
          341,
          "\t\treturn 0;"
        ],
        [
          342,
          "\t}"
        ],
        [
          343,
          ""
        ],
        [
          345,
          "\tif (VFS_I(ip)->i_mode == 0)"
        ],
        [
          346,
          "\t\treturn -ENOENT;"
        ],
        [
          347,
          ""
        ],
        [
          348,
          "\treturn 0;"
        ],
        [
          349,
          "}"
        ]
      ],
      "statements": [
        [
          322,
          "xfs_iget_check_free_state(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tif (flags & XFS_IGET_CREATE) {\n\t\t/* should be a free inode */\n\t\tif (VFS_I(ip)->i_mode != 0) {\n\t\t\txfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)\",\n\t\t\t\tip->i_ino, VFS_I(ip)->i_mode);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tif (ip->i_d.di_nblocks != 0) {\n\t\t\txfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n\t\t\t\tip->i_ino);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* should be an allocated inode */\n\tif (VFS_I(ip)->i_mode == 0)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
        ],
        [
          324,
          "int\t\t\tflags)\n{\n\tif (flags & XFS_IGET_CREATE) {\n\t\t/* should be a free inode */\n\t\tif (VFS_I(ip)->i_mode != 0) {"
        ],
        [
          325,
          "{"
        ],
        [
          332,
          "return -EFSCORRUPTED;"
        ],
        [
          333,
          "}"
        ],
        [
          335,
          "if (ip->i_d.di_nblocks != 0)"
        ],
        [
          336,
          "xfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n\t\t\t\tip->i_ino);"
        ],
        [
          339,
          "return -EFSCORRUPTED;"
        ],
        [
          340,
          "\t\t}\n"
        ],
        [
          341,
          "return 0;"
        ],
        [
          342,
          "}"
        ],
        [
          345,
          "if (VFS_I(ip)->i_mode == 0)"
        ],
        [
          346,
          "return -ENOENT;"
        ],
        [
          348,
          "return 0;"
        ],
        [
          349,
          "}"
        ]
      ],
      "cve": "CVE-2018-13093"
    },
    {
      "commit_id": "15c2990e0f0108b9c3752d7072a97d45d4283aea",
      "filepath": "drivers/gpu/drm/amd/display/dc/hwss/dcn30/dcn30_hwseq.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "dcn30_apply_idle_power_optimizations",
      "func_body": "bool dcn30_apply_idle_power_optimizations(struct dc *dc, bool enable)\n{\n\tunion dmub_rb_cmd cmd;\n\tuint32_t tmr_delay = 0, tmr_scale = 0;\n\tstruct dc_cursor_attributes cursor_attr = {0};\n\tbool cursor_cache_enable = false;\n\tstruct dc_stream_state *stream = NULL;\n\tstruct dc_plane_state *plane = NULL;\n\n\tif (!dc->ctx->dmub_srv)\n\t\treturn false;\n\n\tif (enable) {\n\t\tif (dc->current_state) {\n\t\t\tint i;\n\n\t\t\t/* First, check no-memory-requests case */\n\t\t\tfor (i = 0; i < dc->current_state->stream_count; i++) {\n\t\t\t\tif (dc->current_state->stream_status[i].plane_count)\n\t\t\t\t\t/* Fail eligibility on a visible stream */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == dc->current_state->stream_count) {\n\t\t\t\t/* Enable no-memory-requests case */\n\t\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\t\tcmd.mall.header.type = DMUB_CMD__MALL;\n\t\t\t\tcmd.mall.header.sub_type = DMUB_CMD__MALL_ACTION_NO_DF_REQ;\n\t\t\t\tcmd.mall.header.payload_bytes = sizeof(cmd.mall) - sizeof(cmd.mall.header);\n\n\t\t\t\tdc_wake_and_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_NO_WAIT);\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tstream = dc->current_state->streams[0];\n\t\t\tplane = (stream ? dc->current_state->stream_status[0].plane_states[0] : NULL);\n\n\t\t\tif (!stream || !plane)\n\t\t\t\treturn false;\n\n\t\t\tif (stream && plane) {\n\t\t\t\tcursor_cache_enable = stream->cursor_position.enable &&\n\t\t\t\t\t\tplane->address.grph.cursor_cache_addr.quad_part;\n\t\t\t\tcursor_attr = stream->cursor_attributes;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Second, check MALL eligibility\n\t\t\t *\n\t\t\t * single display only, single surface only, 8 and 16 bit formats only, no VM,\n\t\t\t * do not use MALL for displays that support PSR as they use D0i3.2 in DMCUB FW\n\t\t\t *\n\t\t\t * TODO: When we implement multi-display, PSR displays will be allowed if there is\n\t\t\t * a non-PSR display present, since in that case we can't do D0i3.2\n\t\t\t */\n\t\t\tif (dc->current_state->stream_count == 1 &&\n\t\t\t\t\tstream->link->psr_settings.psr_version == DC_PSR_VERSION_UNSUPPORTED &&\n\t\t\t\t\tdc->current_state->stream_status[0].plane_count == 1 &&\n\t\t\t\t\tplane->format <= SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F &&\n\t\t\t\t\tplane->format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB8888 &&\n\t\t\t\t\tplane->address.page_table_base.quad_part == 0 &&\n\t\t\t\t\tdc->hwss.does_plane_fit_in_mall &&\n\t\t\t\t\tdc->hwss.does_plane_fit_in_mall(dc, plane->plane_size.surface_pitch,\n\t\t\t\t\t\t\tplane->plane_size.surface_size.height, plane->format,\n\t\t\t\t\t\t\tcursor_cache_enable ? &cursor_attr : NULL)) {\n\t\t\t\tunsigned int v_total = stream->adjust.v_total_max ?\n\t\t\t\t\t\tstream->adjust.v_total_max : stream->timing.v_total;\n\t\t\t\tunsigned int refresh_hz = div_u64((unsigned long long) stream->timing.pix_clk_100hz *\n\t\t\t\t\t\t100LL, (v_total * stream->timing.h_total));\n\n\t\t\t\t/*\n\t\t\t\t * one frame time in microsec:\n\t\t\t\t * Delay_Us = 1000000 / refresh\n\t\t\t\t * dynamic_delay_us = 1000000 / refresh + 2 * stutter_period\n\t\t\t\t *\n\t\t\t\t * one frame time modified by 'additional timer percent' (p):\n\t\t\t\t * Delay_Us_modified = dynamic_delay_us + dynamic_delay_us * p / 100\n\t\t\t\t *                   = dynamic_delay_us * (1 + p / 100)\n\t\t\t\t *                   = (1000000 / refresh + 2 * stutter_period) * (100 + p) / 100\n\t\t\t\t *                   = (1000000 + 2 * stutter_period * refresh) * (100 + p) / (100 * refresh)\n\t\t\t\t *\n\t\t\t\t * formula for timer duration based on parameters, from regspec:\n\t\t\t\t * dynamic_delay_us = 65.28 * (64 + MallFrameCacheTmrDly) * 2^MallFrameCacheTmrScale\n\t\t\t\t *\n\t\t\t\t * dynamic_delay_us / 65.28 = (64 + MallFrameCacheTmrDly) * 2^MallFrameCacheTmrScale\n\t\t\t\t * (dynamic_delay_us / 65.28) / 2^MallFrameCacheTmrScale = 64 + MallFrameCacheTmrDly\n\t\t\t\t * MallFrameCacheTmrDly = ((dynamic_delay_us / 65.28) / 2^MallFrameCacheTmrScale) - 64\n\t\t\t\t *                      = (1000000 + 2 * stutter_period * refresh) * (100 + p) / (100 * refresh) / 65.28 / 2^MallFrameCacheTmrScale - 64\n\t\t\t\t *                      = (1000000 + 2 * stutter_period * refresh) * (100 + p) / (refresh * 6528 * 2^MallFrameCacheTmrScale) - 64\n\t\t\t\t *\n\t\t\t\t * need to round up the result of the division before the subtraction\n\t\t\t\t */\n\t\t\t\tunsigned int denom = refresh_hz * 6528;\n\t\t\t\tunsigned int stutter_period = dc->current_state->perf_params.stutter_period_us;\n\n\t\t\t\ttmr_delay = div_u64(((1000000LL + 2 * stutter_period * refresh_hz) *\n\t\t\t\t\t\t(100LL + dc->debug.mall_additional_timer_percent) + denom - 1),\n\t\t\t\t\t\tdenom) - 64LL;\n\n\t\t\t\t/* In some cases the stutter period is really big (tiny modes) in these\n\t\t\t\t * cases MALL cant be enabled, So skip these cases to avoid a ASSERT()\n\t\t\t\t *\n\t\t\t\t * We can check if stutter_period is more than 1/10th the frame time to\n\t\t\t\t * consider if we can actually meet the range of hysteresis timer\n\t\t\t\t */\n\t\t\t\tif (stutter_period > 100000/refresh_hz)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/* scale should be increased until it fits into 6 bits */\n\t\t\t\twhile (tmr_delay & ~0x3F) {\n\t\t\t\t\ttmr_scale++;\n\n\t\t\t\t\tif (tmr_scale > 3) {\n\t\t\t\t\t\t/* Delay exceeds range of hysteresis timer */\n\t\t\t\t\t\tASSERT(false);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tdenom *= 2;\n\t\t\t\t\ttmr_delay = div_u64(((1000000LL + 2 * stutter_period * refresh_hz) *\n\t\t\t\t\t\t\t(100LL + dc->debug.mall_additional_timer_percent) + denom - 1),\n\t\t\t\t\t\t\tdenom) - 64LL;\n\t\t\t\t}\n\n\t\t\t\t/* Copy HW cursor */\n\t\t\t\tif (cursor_cache_enable) {\n\t\t\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\t\t\tcmd.mall.header.type = DMUB_CMD__MALL;\n\t\t\t\t\tcmd.mall.header.sub_type = DMUB_CMD__MALL_ACTION_COPY_CURSOR;\n\t\t\t\t\tcmd.mall.header.payload_bytes =\n\t\t\t\t\t\t\tsizeof(cmd.mall) - sizeof(cmd.mall.header);\n\n\t\t\t\t\tswitch (cursor_attr.color_format) {\n\t\t\t\t\tcase CURSOR_MODE_MONO:\n\t\t\t\t\t\tcmd.mall.cursor_bpp = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CURSOR_MODE_COLOR_1BIT_AND:\n\t\t\t\t\tcase CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA:\n\t\t\t\t\tcase CURSOR_MODE_COLOR_UN_PRE_MULTIPLIED_ALPHA:\n\t\t\t\t\t\tcmd.mall.cursor_bpp = 32;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CURSOR_MODE_COLOR_64BIT_FP_PRE_MULTIPLIED:\n\t\t\t\t\tcase CURSOR_MODE_COLOR_64BIT_FP_UN_PRE_MULTIPLIED:\n\t\t\t\t\t\tcmd.mall.cursor_bpp = 64;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcmd.mall.cursor_copy_src.quad_part = cursor_attr.address.quad_part;\n\t\t\t\t\tcmd.mall.cursor_copy_dst.quad_part =\n\t\t\t\t\t\t\t(plane->address.grph.cursor_cache_addr.quad_part + 2047) & ~2047;\n\t\t\t\t\tcmd.mall.cursor_width = cursor_attr.width;\n\t\t\t\t\tcmd.mall.cursor_height = cursor_attr.height;\n\t\t\t\t\tcmd.mall.cursor_pitch = cursor_attr.pitch;\n\n\t\t\t\t\tdc_wake_and_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\t\t\t\t\t/* Use copied cursor, and it's okay to not switch back */\n\t\t\t\t\tcursor_attr.address.quad_part = cmd.mall.cursor_copy_dst.quad_part;\n\t\t\t\t\tdc_stream_program_cursor_attributes(stream, &cursor_attr);\n\t\t\t\t}\n\n\t\t\t\t/* Enable MALL */\n\t\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\t\tcmd.mall.header.type = DMUB_CMD__MALL;\n\t\t\t\tcmd.mall.header.sub_type = DMUB_CMD__MALL_ACTION_ALLOW;\n\t\t\t\tcmd.mall.header.payload_bytes = sizeof(cmd.mall) - sizeof(cmd.mall.header);\n\t\t\t\tcmd.mall.tmr_delay = tmr_delay;\n\t\t\t\tcmd.mall.tmr_scale = tmr_scale;\n\t\t\t\tcmd.mall.debug_bits = dc->debug.mall_error_as_fatal;\n\n\t\t\t\tdc_wake_and_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_NO_WAIT);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t/* No applicable optimizations */\n\t\treturn false;\n\t}\n\n\t/* Disable MALL */\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.mall.header.type = DMUB_CMD__MALL;\n\tcmd.mall.header.sub_type = DMUB_CMD__MALL_ACTION_DISALLOW;\n\tcmd.mall.header.payload_bytes =\n\t\tsizeof(cmd.mall) - sizeof(cmd.mall.header);\n\n\tdc_wake_and_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n",
      "line_statements": [
        [
          922,
          "\t\t\tif (!stream || !plane)\n"
        ],
        [
          923,
          "\t\t\t\treturn false;\n"
        ],
        [
          924,
          "\n"
        ]
      ],
      "statements": [
        [
          922,
          "if (!stream || !plane)"
        ],
        [
          923,
          "return false;"
        ],
        [
          924,
          "\n"
        ]
      ],
      "cve": "CVE-2024-43904"
    },
    {
      "commit_id": "12f35199a2c0551187edbf8eb01379f0598659fa",
      "filepath": "drivers/infiniband/ulp/srp/ib_srp.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "srp_process_rsp",
      "func_body": "static void srp_process_rsp(struct srp_rdma_ch *ch, struct srp_rsp *rsp)\n{\n\tstruct srp_target_port *target = ch->target;\n\tstruct srp_request *req;\n\tstruct scsi_cmnd *scmnd;\n\tunsigned long flags;\n\n\tif (unlikely(rsp->tag & SRP_TAG_TSK_MGMT)) {\n\t\tspin_lock_irqsave(&ch->lock, flags);\n\t\tch->req_lim += be32_to_cpu(rsp->req_lim_delta);\n\t\tif (rsp->tag == ch->tsk_mgmt_tag) {\n\t\t\tch->tsk_mgmt_status = -1;\n\t\t\tif (be32_to_cpu(rsp->resp_data_len) >= 4)\n\t\t\t\tch->tsk_mgmt_status = rsp->data[3];\n\t\t\tcomplete(&ch->tsk_mgmt_done);\n\t\t} else {\n\t\t\tshost_printk(KERN_ERR, target->scsi_host,\n\t\t\t\t     \"Received tsk mgmt response too late for tag %#llx\\n\",\n\t\t\t\t     rsp->tag);\n\t\t}\n\t\tspin_unlock_irqrestore(&ch->lock, flags);\n\t} else {\n\t\tscmnd = scsi_host_find_tag(target->scsi_host, rsp->tag);\n\t\tif (scmnd) {\n\t\t\treq = scsi_cmd_priv(scmnd);\n\t\t\tscmnd = srp_claim_req(ch, req, NULL, scmnd);\n\t\t}\n\t\tif (!scmnd) {\n\t\t\tshost_printk(KERN_ERR, target->scsi_host,\n\t\t\t\t     \"Null scmnd for RSP w/tag %#016llx received on ch %td / QP %#x\\n\",\n\t\t\t\t     rsp->tag, ch - target->ch, ch->qp->qp_num);\n\n\t\t\tspin_lock_irqsave(&ch->lock, flags);\n\t\t\tch->req_lim += be32_to_cpu(rsp->req_lim_delta);\n\t\t\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\t\t\treturn;\n\t\t}\n\t\tscmnd->result = rsp->status;\n\n\t\tif (rsp->flags & SRP_RSP_FLAG_SNSVALID) {\n\t\t\tmemcpy(scmnd->sense_buffer, rsp->data +\n\t\t\t       be32_to_cpu(rsp->resp_data_len),\n\t\t\t       min_t(int, be32_to_cpu(rsp->sense_data_len),\n\t\t\t\t     SCSI_SENSE_BUFFERSIZE));\n\t\t}\n\n\t\tif (unlikely(rsp->flags & SRP_RSP_FLAG_DIUNDER))\n\t\t\tscsi_set_resid(scmnd, be32_to_cpu(rsp->data_in_res_cnt));\n\t\telse if (unlikely(rsp->flags & SRP_RSP_FLAG_DIOVER))\n\t\t\tscsi_set_resid(scmnd, -be32_to_cpu(rsp->data_in_res_cnt));\n\t\telse if (unlikely(rsp->flags & SRP_RSP_FLAG_DOUNDER))\n\t\t\tscsi_set_resid(scmnd, be32_to_cpu(rsp->data_out_res_cnt));\n\t\telse if (unlikely(rsp->flags & SRP_RSP_FLAG_DOOVER))\n\t\t\tscsi_set_resid(scmnd, -be32_to_cpu(rsp->data_out_res_cnt));\n\n\t\tsrp_free_req(ch, req, scmnd,\n\t\t\t     be32_to_cpu(rsp->req_lim_delta));\n\n\t\tscsi_done(scmnd);\n\t}\n}\n",
      "line_statements": [
        [
          1964,
          "\t\t}\n"
        ],
        [
          1965,
          "\t\tif (!scmnd) {\n"
        ]
      ],
      "statements": [
        [
          1964,
          "\t\t}\n"
        ],
        [
          1965,
          "if (!scmnd)"
        ]
      ],
      "cve": "CVE-2022-48692"
    },
    {
      "commit_id": "4224cfd7fb6523f7a9d1c8bb91bb5df1e38eb624",
      "filepath": "net/core/net-sysfs.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "speed_show",
      "func_body": "static ssize_t speed_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct net_device *netdev = to_net_dev(dev);\n\tint ret = -EINVAL;\n\n\t/* The check is also done in __ethtool_get_link_ksettings; this helps\n\t * returning early without hitting the trylock/restart below.\n\t */\n\tif (!netdev->ethtool_ops->get_link_ksettings)\n\t\treturn ret;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tif (netif_running(netdev) && netif_device_present(netdev)) {\n\t\tstruct ethtool_link_ksettings cmd;\n\n\t\tif (!__ethtool_get_link_ksettings(netdev, &cmd))\n\t\t\tret = sprintf(buf, fmt_dec, cmd.base.speed);\n\t}\n\trtnl_unlock();\n\treturn ret;\n}\n",
      "line_statements": [
        [
          216,
          "\tif (netif_running(netdev) && netif_device_present(netdev)) {\n"
        ]
      ],
      "statements": [
        [
          216,
          "if (netif_running(netdev) && netif_device_present(netdev))"
        ]
      ],
      "cve": "CVE-2022-48850"
    },
    {
      "commit_id": "89189557b47b35683a27c80ee78aef18248eefb4",
      "filepath": "fs/proc/proc_sysctl.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "drop_sysctl_table",
      "func_body": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tif (parent) {\n\t\tput_links(header);\n\t\tstart_unregistering(header);\n\t}\n\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}\n",
      "line_statements": [
        [
          1629,
          "\tif (parent) {\n"
        ],
        [
          1631,
          "\t\tstart_unregistering(header);\n"
        ],
        [
          1632,
          "\t}\n"
        ],
        [
          1633,
          "\n"
        ]
      ],
      "statements": [
        [
          1629,
          "if (parent)"
        ],
        [
          1631,
          "start_unregistering(header);"
        ],
        [
          1632,
          "\t}\n"
        ],
        [
          1633,
          "\n"
        ]
      ],
      "cve": "CVE-2019-20054"
    },
    {
      "commit_id": "924e5814d1f84e6fa5cb19c6eceb69f066225229",
      "filepath": "drivers/gpu/drm/panel/panel-arm-versatile.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "versatile_panel_get_modes",
      "func_body": "static int versatile_panel_get_modes(struct drm_panel *panel,\n\t\t\t\t     struct drm_connector *connector)\n{\n\tstruct versatile_panel *vpanel = to_versatile_panel(panel);\n\tstruct drm_display_mode *mode;\n\n\tconnector->display_info.width_mm = vpanel->panel_type->width_mm;\n\tconnector->display_info.height_mm = vpanel->panel_type->height_mm;\n\tconnector->display_info.bus_flags = vpanel->panel_type->bus_flags;\n\n\tmode = drm_mode_duplicate(connector->dev, &vpanel->panel_type->mode);\n\tif (!mode)\n\t\treturn -ENOMEM;\n\tdrm_mode_set_name(mode);\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\n\tmode->width_mm = vpanel->panel_type->width_mm;\n\tmode->height_mm = vpanel->panel_type->height_mm;\n\tdrm_mode_probed_add(connector, mode);\n\n\treturn 1;\n}\n",
      "line_statements": [
        [
          270,
          "\tif (!mode)\n"
        ],
        [
          271,
          "\t\treturn -ENOMEM;\n"
        ]
      ],
      "statements": [
        [
          270,
          "if (!mode)"
        ],
        [
          271,
          "return -ENOMEM;"
        ]
      ],
      "cve": "CVE-2023-52821"
    },
    {
      "commit_id": "fbaf24bce7ea4211e4608b3ab6c1b45702cb243d",
      "filepath": "libr/bin/format/elf/elf.c",
      "project": "radare2",
      "project_repo_path": "symbol_backend_projects/radare2",
      "is_vulnerable": false,
      "func_name": "store_versioninfo_gnu_verdef",
      "func_body": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif ((int)shdr->sh_size < 1) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tsize_t vstart_off = i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tvstart_off += vdaux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tvstart_off += aux.vda_next;\n\t\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}",
      "line_statements": [
        [
          737,
          "\t\tsize_t vstart_off = i;"
        ],
        [
          753,
          "\t\tif (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {"
        ],
        [
          758,
          "\t\tvstart_off += vdaux;"
        ],
        [
          786,
          "\t\t\tvstart_off += aux.vda_next;"
        ]
      ],
      "statements": [
        [
          737,
          "size_t vstart_off = i;"
        ],
        [
          753,
          "if (vdaux < 1 || shdr->sh_size - vstart_off < vdaux)"
        ],
        [
          758,
          "vstart_off += vdaux;"
        ],
        [
          786,
          "vstart_off += aux.vda_next;"
        ]
      ],
      "cve": "CVE-2017-16359"
    },
    {
      "commit_id": "f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb",
      "filepath": "tensorflow/core/kernels/sdca_internal.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tensorflow::sdca::Examples::Initialize",
      "func_body": "Status Examples::Initialize(OpKernelContext* const context,\n                            const ModelWeights& weights,\n                            const int num_sparse_features,\n                            const int num_sparse_features_with_values,\n                            const int num_dense_features) {\n  num_features_ = num_sparse_features + num_dense_features;\n\n  OpInputList sparse_example_indices_inputs;\n  TF_RETURN_IF_ERROR(context->input_list(\"sparse_example_indices\",\n                                         &sparse_example_indices_inputs));\n  if (sparse_example_indices_inputs.size() != num_sparse_features)\n    return errors::InvalidArgument(\n        \"Expected \", num_sparse_features,\n        \" tensors in sparse_example_indices but got \",\n        sparse_example_indices_inputs.size());\n  OpInputList sparse_feature_indices_inputs;\n  TF_RETURN_IF_ERROR(context->input_list(\"sparse_feature_indices\",\n                                         &sparse_feature_indices_inputs));\n  if (sparse_feature_indices_inputs.size() != num_sparse_features)\n    return errors::InvalidArgument(\n        \"Expected \", num_sparse_features,\n        \" tensors in sparse_feature_indices but got \",\n        sparse_feature_indices_inputs.size());\n  OpInputList sparse_feature_values_inputs;\n  if (num_sparse_features_with_values > 0) {\n    TF_RETURN_IF_ERROR(context->input_list(\"sparse_feature_values\",\n                                           &sparse_feature_values_inputs));\n    if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)\n      return errors::InvalidArgument(\n          \"Expected \", num_sparse_features_with_values,\n          \" tensors in sparse_feature_values but got \",\n          sparse_feature_values_inputs.size());\n  }\n\n  const Tensor* example_weights_t;\n  TF_RETURN_IF_ERROR(context->input(\"example_weights\", &example_weights_t));\n  auto example_weights = example_weights_t->flat<float>();\n\n  if (example_weights.size() >= std::numeric_limits<int>::max()) {\n    return errors::InvalidArgument(strings::Printf(\n        \"Too many examples in a mini-batch: %zu > %d\", example_weights.size(),\n        std::numeric_limits<int>::max()));\n  }\n\n  // The static_cast here is safe since num_examples can be at max an int.\n  const int num_examples = static_cast<int>(example_weights.size());\n  const Tensor* example_labels_t;\n  TF_RETURN_IF_ERROR(context->input(\"example_labels\", &example_labels_t));\n  auto example_labels = example_labels_t->flat<float>();\n\n  OpInputList dense_features_inputs;\n  TF_RETURN_IF_ERROR(\n      context->input_list(\"dense_features\", &dense_features_inputs));\n\n  examples_.clear();\n  examples_.resize(num_examples);\n  probabilities_.resize(num_examples);\n  sampled_index_.resize(num_examples);\n  sampled_count_.resize(num_examples);\n  for (int example_id = 0; example_id < num_examples; ++example_id) {\n    Example* const example = &examples_[example_id];\n    example->sparse_features_.resize(num_sparse_features);\n    example->dense_vectors_.resize(num_dense_features);\n    example->example_weight_ = example_weights(example_id);\n    example->example_label_ = example_labels(example_id);\n  }\n  const DeviceBase::CpuWorkerThreads& worker_threads =\n      *context->device()->tensorflow_cpu_worker_threads();\n  TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(\n      worker_threads, num_examples, num_sparse_features, weights,\n      sparse_example_indices_inputs, sparse_feature_indices_inputs,\n      sparse_feature_values_inputs, &examples_));\n  TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(\n      worker_threads, num_examples, num_dense_features, weights,\n      dense_features_inputs, &examples_));\n  TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(\n      worker_threads, num_examples, num_sparse_features, num_dense_features,\n      &examples_));\n  return Status::OK();\n}",
      "line_statements": [
        [
          344,
          "  if (sparse_example_indices_inputs.size() != num_sparse_features)"
        ],
        [
          345,
          "    return errors::InvalidArgument("
        ],
        [
          346,
          "        \"Expected \", num_sparse_features,"
        ],
        [
          347,
          "        \" tensors in sparse_example_indices but got \","
        ],
        [
          348,
          "        sparse_example_indices_inputs.size());"
        ],
        [
          352,
          "  if (sparse_feature_indices_inputs.size() != num_sparse_features)"
        ],
        [
          353,
          "    return errors::InvalidArgument("
        ],
        [
          354,
          "        \"Expected \", num_sparse_features,"
        ],
        [
          355,
          "        \" tensors in sparse_feature_indices but got \","
        ],
        [
          356,
          "        sparse_feature_indices_inputs.size());"
        ],
        [
          361,
          "    if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)"
        ],
        [
          362,
          "      return errors::InvalidArgument("
        ],
        [
          363,
          "          \"Expected \", num_sparse_features_with_values,"
        ],
        [
          364,
          "          \" tensors in sparse_feature_values but got \","
        ],
        [
          365,
          "          sparse_feature_values_inputs.size());"
        ]
      ],
      "statements": [
        [
          344,
          "if (sparse_example_indices_inputs.size() != num_sparse_features)"
        ],
        [
          345,
          "return errors::InvalidArgument(\n        \"Expected \", num_sparse_features,\n        \" tensors in sparse_example_indices but got \",\n        sparse_example_indices_inputs.size());"
        ],
        [
          352,
          "if (sparse_feature_indices_inputs.size() != num_sparse_features)"
        ],
        [
          353,
          "return errors::InvalidArgument(\n        \"Expected \", num_sparse_features,\n        \" tensors in sparse_feature_indices but got \",\n        sparse_feature_indices_inputs.size());"
        ],
        [
          361,
          "if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)"
        ],
        [
          362,
          "return errors::InvalidArgument(\n          \"Expected \", num_sparse_features_with_values,\n          \" tensors in sparse_feature_values but got \",\n          sparse_feature_values_inputs.size());"
        ]
      ],
      "cve": "CVE-2021-29572"
    },
    {
      "commit_id": "1165affd484889d4986cf3b724318935a0b120d8",
      "filepath": "net/mac802154/llsec.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "llsec_key_alloc",
      "func_body": "static struct mac802154_llsec_key*\nllsec_key_alloc(const struct ieee802154_llsec_key *template)\n{\n\tconst int authsizes[3] = { 4, 8, 16 };\n\tstruct mac802154_llsec_key *key;\n\tint i;\n\n\tkey = kzalloc(sizeof(*key), GFP_KERNEL);\n\tif (!key)\n\t\treturn NULL;\n\n\tkref_init(&key->ref);\n\tkey->key = *template;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(authsizes) != ARRAY_SIZE(key->tfm));\n\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++) {\n\t\tkey->tfm[i] = crypto_alloc_aead(\"ccm(aes)\", 0,\n\t\t\t\t\t\tCRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(key->tfm[i]))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setkey(key->tfm[i], template->key,\n\t\t\t\t       IEEE802154_LLSEC_KEY_SIZE))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setauthsize(key->tfm[i], authsizes[i]))\n\t\t\tgoto err_tfm;\n\t}\n\n\tkey->tfm0 = crypto_alloc_sync_skcipher(\"ctr(aes)\", 0, 0);\n\tif (IS_ERR(key->tfm0))\n\t\tgoto err_tfm;\n\n\tif (crypto_sync_skcipher_setkey(key->tfm0, template->key,\n\t\t\t\t   IEEE802154_LLSEC_KEY_SIZE))\n\t\tgoto err_tfm0;\n\n\treturn key;\n\nerr_tfm0:\n\tcrypto_free_sync_skcipher(key->tfm0);\nerr_tfm:\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++)\n\t\tif (key->tfm[i])\n\t\t\tcrypto_free_aead(key->tfm[i]);\n\n\tkfree_sensitive(key);\n\treturn NULL;\n}\n",
      "line_statements": [
        [
          155,
          "\t\tif (key->tfm[i])\n"
        ]
      ],
      "statements": [
        [
          155,
          "if (key->tfm[i])"
        ]
      ],
      "cve": "CVE-2021-3659"
    },
    {
      "commit_id": "f0ba83717b6e4d7a15a1676d1fe06152e199b011",
      "filepath": "src/isomedia/media_odf.c",
      "project": "gpac",
      "project_repo_path": "symbol_backend_projects/gpac",
      "is_vulnerable": true,
      "func_name": "Media_RewriteODFrame",
      "func_body": "GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (!mpod->trackIDs || gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}",
      "line_statements": [
        [
          135,
          "\t\t\t\t\tif (!mpod->trackIDs || gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;"
        ]
      ],
      "statements": [
        [
          135,
          "if (!mpod->trackIDs || gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL)"
        ]
      ],
      "cve": "CVE-2021-32440"
    },
    {
      "commit_id": "7dc357d343f134bf59815ff6098b93503ec8a23b",
      "filepath": "drivers/char/tpm/tpm2-sessions.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "tpm_buf_check_hmac_response",
      "func_body": "int tpm_buf_check_hmac_response(struct tpm_chip *chip, struct tpm_buf *buf,\n\t\t\t\tint rc)\n{\n\tstruct tpm_header *head = (struct tpm_header *)buf->data;\n\tstruct tpm2_auth *auth = chip->auth;\n\toff_t offset_s, offset_p;\n\tu8 rphash[SHA256_DIGEST_SIZE];\n\tu32 attrs, cc;\n\tstruct sha256_state sctx;\n\tu16 tag = be16_to_cpu(head->tag);\n\tint parm_len, len, i, handles;\n\n\tif (!auth)\n\t\treturn rc;\n\n\tcc = be32_to_cpu(auth->ordinal);\n\n\tif (auth->session >= TPM_HEADER_SIZE) {\n\t\tWARN(1, \"tpm session not filled correctly\\n\");\n\t\tgoto out;\n\t}\n\n\tif (rc != 0)\n\t\t/* pass non success rc through and close the session */\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif (tag != TPM2_ST_SESSIONS) {\n\t\tdev_err(&chip->dev, \"TPM: HMAC response check has no sessions tag\\n\");\n\t\tgoto out;\n\t}\n\n\ti = tpm2_find_cc(chip, cc);\n\tif (i < 0)\n\t\tgoto out;\n\tattrs = chip->cc_attrs_tbl[i];\n\thandles = (attrs >> TPM2_CC_ATTR_RHANDLE) & 1;\n\n\t/* point to area beyond handles */\n\toffset_s = TPM_HEADER_SIZE + handles * 4;\n\tparm_len = tpm_buf_read_u32(buf, &offset_s);\n\toffset_p = offset_s;\n\toffset_s += parm_len;\n\t/* skip over any sessions before ours */\n\tfor (i = 0; i < auth->session - 1; i++) {\n\t\tlen = tpm_buf_read_u16(buf, &offset_s);\n\t\toffset_s += len + 1;\n\t\tlen = tpm_buf_read_u16(buf, &offset_s);\n\t\toffset_s += len;\n\t}\n\t/* TPM nonce */\n\tlen = tpm_buf_read_u16(buf, &offset_s);\n\tif (offset_s + len > tpm_buf_length(buf))\n\t\tgoto out;\n\tif (len != SHA256_DIGEST_SIZE)\n\t\tgoto out;\n\tmemcpy(auth->tpm_nonce, &buf->data[offset_s], len);\n\toffset_s += len;\n\tattrs = tpm_buf_read_u8(buf, &offset_s);\n\tlen = tpm_buf_read_u16(buf, &offset_s);\n\tif (offset_s + len != tpm_buf_length(buf))\n\t\tgoto out;\n\tif (len != SHA256_DIGEST_SIZE)\n\t\tgoto out;\n\t/*\n\t * offset_s points to the HMAC. now calculate comparison, beginning\n\t * with rphash\n\t */\n\tsha256_init(&sctx);\n\t/* yes, I know this is now zero, but it's what the standard says */\n\tsha256_update(&sctx, (u8 *)&head->return_code,\n\t\t      sizeof(head->return_code));\n\t/* ordinal is already BE */\n\tsha256_update(&sctx, (u8 *)&auth->ordinal, sizeof(auth->ordinal));\n\tsha256_update(&sctx, &buf->data[offset_p], parm_len);\n\tsha256_final(&sctx, rphash);\n\n\t/* now calculate the hmac */\n\ttpm2_hmac_init(&sctx, auth->session_key, sizeof(auth->session_key)\n\t\t       + auth->passphrase_len);\n\tsha256_update(&sctx, rphash, sizeof(rphash));\n\tsha256_update(&sctx, auth->tpm_nonce, sizeof(auth->tpm_nonce));\n\tsha256_update(&sctx, auth->our_nonce, sizeof(auth->our_nonce));\n\tsha256_update(&sctx, &auth->attrs, 1);\n\t/* we're done with the rphash, so put our idea of the hmac there */\n\ttpm2_hmac_final(&sctx, auth->session_key, sizeof(auth->session_key)\n\t\t\t+ auth->passphrase_len, rphash);\n\tif (memcmp(rphash, &buf->data[offset_s], SHA256_DIGEST_SIZE) == 0) {\n\t\trc = 0;\n\t} else {\n\t\tdev_err(&chip->dev, \"TPM: HMAC check failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* now do response decryption */\n\tif (auth->attrs & TPM2_SA_ENCRYPT) {\n\t\t/* need key and IV */\n\t\ttpm2_KDFa(auth->session_key, SHA256_DIGEST_SIZE\n\t\t\t  + auth->passphrase_len, \"CFB\", auth->tpm_nonce,\n\t\t\t  auth->our_nonce, AES_KEY_BYTES + AES_BLOCK_SIZE,\n\t\t\t  auth->scratch);\n\n\t\tlen = tpm_buf_read_u16(buf, &offset_p);\n\t\taes_expandkey(&auth->aes_ctx, auth->scratch, AES_KEY_BYTES);\n\t\taescfb_decrypt(&auth->aes_ctx, &buf->data[offset_p],\n\t\t\t       &buf->data[offset_p], len,\n\t\t\t       auth->scratch + AES_KEY_BYTES);\n\t}\n\n out:\n\tif ((auth->attrs & TPM2_SA_CONTINUE_SESSION) == 0) {\n\t\tif (rc)\n\t\t\t/* manually close the session if it wasn't consumed */\n\t\t\ttpm2_flush_context(chip, auth->handle);\n\t\tmemzero_explicit(auth, sizeof(*auth));\n\t} else {\n\t\t/* reset for next use  */\n\t\tauth->session = TPM_HEADER_SIZE;\n\t}\n\n\treturn rc;\n}\n",
      "line_statements": [
        [
          749,
          "\tu32 attrs, cc;\n"
        ],
        [
          757,
          "\tcc = be32_to_cpu(auth->ordinal);\n"
        ],
        [
          758,
          "\n"
        ]
      ],
      "statements": [
        [
          749,
          "u32 attrs, cc;"
        ],
        [
          757,
          "cc = be32_to_cpu(auth->ordinal);"
        ],
        [
          758,
          "\n"
        ]
      ],
      "cve": "CVE-2024-42255"
    },
    {
      "commit_id": "d2af3bc375e2a77139c3a28d6128c60cd8d08655",
      "filepath": "parse.c",
      "project": "samurai",
      "project_repo_path": "symbol_backend_projects/samurai",
      "is_vulnerable": false,
      "func_name": "parserule",
      "func_body": "parserule(struct scanner *s, struct environment *env)\n{\n\tstruct rule *r;\n\tchar *var;\n\tstruct evalstring *val;\n\tbool hascommand = false, hasrspfile = false, hasrspcontent = false;\n\n\tr = mkrule(scanname(s));\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tvar = scanname(s);\n\t\tparselet(s, &val);\n\t\truleaddvar(r, var, val);\n\t\tif (!val)\n\t\t\tcontinue;\n\t\tif (strcmp(var, \"command\") == 0)\n\t\t\thascommand = true;\n\t\telse if (strcmp(var, \"rspfile\") == 0)\n\t\t\thasrspfile = true;\n\t\telse if (strcmp(var, \"rspfile_content\") == 0)\n\t\t\thasrspcontent = true;\n\t}\n\tif (!hascommand)\n\t\tfatal(\"rule '%s' has no command\", r->name);\n\tif (hasrspfile != hasrspcontent)\n\t\tfatal(\"rule '%s' has rspfile and no rspfile_content or vice versa\", r->name);\n\tenvaddrule(env, r);\n}",
      "line_statements": [
        [
          45,
          "\t\tif (!val)"
        ],
        [
          46,
          "\t\t\tcontinue;"
        ]
      ],
      "statements": [
        [
          45,
          "if (!val)"
        ],
        [
          46,
          "continue;"
        ]
      ],
      "cve": "CVE-2021-30219"
    },
    {
      "commit_id": "d4fdf8ba0e5808ba9ad6b44337783bd9935e0982",
      "filepath": "fs/f2fs/segment.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "create_flush_cmd_control",
      "func_body": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->fcc_info = fcc;\n\tif (!test_opt(sbi, FLUSH_MERGE))\n\t\treturn err;\n\ninit_thread:\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}",
      "line_statements": [
        [
          569,
          "\tif (!test_opt(sbi, FLUSH_MERGE))"
        ],
        [
          570,
          "\t\treturn err;"
        ],
        [
          571,
          ""
        ]
      ],
      "statements": [
        [
          569,
          "if (!test_opt(sbi, FLUSH_MERGE))"
        ],
        [
          570,
          "return err;"
        ],
        [
          571,
          "\n"
        ]
      ],
      "cve": "CVE-2017-18241"
    },
    {
      "commit_id": "8a12f8836145ffe37e9c8733dce18c22fb668b66",
      "filepath": "drivers/net/usb/hso.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "obtain_minor",
      "func_body": "static int obtain_minor(struct hso_serial *serial)\n{\n\tint index;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serial_table_lock, flags);\n\tfor (index = 0; index < HSO_SERIAL_TTY_MINORS; index++) {\n\t\tif (serial_table[index] == NULL) {\n\t\t\tserial_table[index] = serial->parent;\n\t\t\tserial->minor = index;\n\t\t\tspin_unlock_irqrestore(&serial_table_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&serial_table_lock, flags);\n\n\tpr_err(\"%s: no free serial devices in table\\n\", __func__);\n\treturn -1;\n}\n",
      "line_statements": [
        [
          614,
          "static int obtain_minor(struct hso_serial *serial)\n"
        ],
        [
          622,
          "\t\t\tserial_table[index] = serial->parent;\n"
        ],
        [
          623,
          "\t\t\tserial->minor = index;\n"
        ],
        [
          625,
          "\t\t\treturn 0;\n"
        ]
      ],
      "statements": [
        [
          614,
          "static int obtain_minor(struct hso_serial *serial)"
        ],
        [
          622,
          "serial_table[index] = serial->parent;"
        ],
        [
          623,
          "serial->minor = index;"
        ],
        [
          625,
          "return 0;"
        ]
      ],
      "cve": "CVE-2021-46904"
    },
    {
      "commit_id": "9a133d73ae4b4664d22bd1aa6d654fec13c52ee1",
      "filepath": "tensorflow/core/kernels/session_ops.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tensorflow::GetSessionHandleOp::Compute",
      "func_body": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionHandle called on null session state\"));\n    int64 id = session_state->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      // Legacy behavior in V1.\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }",
      "line_statements": [
        [
          47,
          "    auto session_state = ctx->session_state();"
        ],
        [
          48,
          "    OP_REQUIRES(ctx, session_state != nullptr,"
        ],
        [
          49,
          "                errors::FailedPrecondition("
        ],
        [
          50,
          "                    \"GetSessionHandle called on null session state\"));"
        ],
        [
          51,
          "    int64 id = session_state->GetNewId();"
        ]
      ],
      "statements": [
        [
          47,
          "auto session_state = ctx->session_state();"
        ],
        [
          48,
          "OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionHandle called on null session state\"));"
        ],
        [
          49,
          "errors::FailedPrecondition(\n                    \"GetSessionHandle called on null session state\")"
        ],
        [
          51,
          "int64 id = session_state->GetNewId();"
        ]
      ],
      "cve": "CVE-2020-15204"
    },
    {
      "commit_id": "a9c10b5b3b67b3750a10c8b089b2e05f5e176e33",
      "filepath": "net/sunrpc/xprtrdma/verbs.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "rpcrdma_ep_create",
      "func_body": "static int rpcrdma_ep_create(struct rpcrdma_xprt *r_xprt)\n{\n\tstruct rpcrdma_connect_private *pmsg;\n\tstruct ib_device *device;\n\tstruct rdma_cm_id *id;\n\tstruct rpcrdma_ep *ep;\n\tint rc;\n\n\tep = kzalloc(sizeof(*ep), GFP_NOFS);\n\tif (!ep)\n\t\treturn -ENOTCONN;\n\tep->re_xprt = &r_xprt->rx_xprt;\n\tkref_init(&ep->re_kref);\n\n\tid = rpcrdma_create_id(r_xprt, ep);\n\tif (IS_ERR(id)) {\n\t\tkfree(ep);\n\t\treturn PTR_ERR(id);\n\t}\n\t__module_get(THIS_MODULE);\n\tdevice = id->device;\n\tep->re_id = id;\n\treinit_completion(&ep->re_done);\n\n\tep->re_max_requests = r_xprt->rx_xprt.max_reqs;\n\tep->re_inline_send = xprt_rdma_max_inline_write;\n\tep->re_inline_recv = xprt_rdma_max_inline_read;\n\trc = frwr_query_device(ep, device);\n\tif (rc)\n\t\tgoto out_destroy;\n\n\tr_xprt->rx_buf.rb_max_requests = cpu_to_be32(ep->re_max_requests);\n\n\tep->re_attr.srq = NULL;\n\tep->re_attr.cap.max_inline_data = 0;\n\tep->re_attr.sq_sig_type = IB_SIGNAL_REQ_WR;\n\tep->re_attr.qp_type = IB_QPT_RC;\n\tep->re_attr.port_num = ~0;\n\n\tep->re_send_batch = ep->re_max_requests >> 3;\n\tep->re_send_count = ep->re_send_batch;\n\tinit_waitqueue_head(&ep->re_connect_wait);\n\n\tep->re_attr.send_cq = ib_alloc_cq_any(device, r_xprt,\n\t\t\t\t\t      ep->re_attr.cap.max_send_wr,\n\t\t\t\t\t      IB_POLL_WORKQUEUE);\n\tif (IS_ERR(ep->re_attr.send_cq)) {\n\t\trc = PTR_ERR(ep->re_attr.send_cq);\n\t\tep->re_attr.send_cq = NULL;\n\t\tgoto out_destroy;\n\t}\n\n\tep->re_attr.recv_cq = ib_alloc_cq_any(device, r_xprt,\n\t\t\t\t\t      ep->re_attr.cap.max_recv_wr,\n\t\t\t\t\t      IB_POLL_WORKQUEUE);\n\tif (IS_ERR(ep->re_attr.recv_cq)) {\n\t\trc = PTR_ERR(ep->re_attr.recv_cq);\n\t\tep->re_attr.recv_cq = NULL;\n\t\tgoto out_destroy;\n\t}\n\tep->re_receive_count = 0;\n\n\t/* Initialize cma parameters */\n\tmemset(&ep->re_remote_cma, 0, sizeof(ep->re_remote_cma));\n\n\t/* Prepare RDMA-CM private message */\n\tpmsg = &ep->re_cm_private;\n\tpmsg->cp_magic = rpcrdma_cmp_magic;\n\tpmsg->cp_version = RPCRDMA_CMP_VERSION;\n\tpmsg->cp_flags |= RPCRDMA_CMP_F_SND_W_INV_OK;\n\tpmsg->cp_send_size = rpcrdma_encode_buffer_size(ep->re_inline_send);\n\tpmsg->cp_recv_size = rpcrdma_encode_buffer_size(ep->re_inline_recv);\n\tep->re_remote_cma.private_data = pmsg;\n\tep->re_remote_cma.private_data_len = sizeof(*pmsg);\n\n\t/* Client offers RDMA Read but does not initiate */\n\tep->re_remote_cma.initiator_depth = 0;\n\tep->re_remote_cma.responder_resources =\n\t\tmin_t(int, U8_MAX, device->attrs.max_qp_rd_atom);\n\n\t/* Limit transport retries so client can detect server\n\t * GID changes quickly. RPC layer handles re-establishing\n\t * transport connection and retransmission.\n\t */\n\tep->re_remote_cma.retry_count = 6;\n\n\t/* RPC-over-RDMA handles its own flow control. In addition,\n\t * make all RNR NAKs visible so we know that RPC-over-RDMA\n\t * flow control is working correctly (no NAKs should be seen).\n\t */\n\tep->re_remote_cma.flow_control = 0;\n\tep->re_remote_cma.rnr_retry_count = 0;\n\n\tep->re_pd = ib_alloc_pd(device, 0);\n\tif (IS_ERR(ep->re_pd)) {\n\t\trc = PTR_ERR(ep->re_pd);\n\t\tep->re_pd = NULL;\n\t\tgoto out_destroy;\n\t}\n\n\trc = rdma_create_qp(id, ep->re_pd, &ep->re_attr);\n\tif (rc)\n\t\tgoto out_destroy;\n\n\tr_xprt->rx_ep = ep;\n\treturn 0;\n\nout_destroy:\n\trpcrdma_ep_put(ep);\n\trdma_destroy_id(id);\n\treturn rc;\n}\n",
      "line_statements": [
        [
          416,
          "\t\tep->re_attr.send_cq = NULL;\n"
        ],
        [
          425,
          "\t\tep->re_attr.recv_cq = NULL;\n"
        ],
        [
          464,
          "\t\tep->re_pd = NULL;\n"
        ]
      ],
      "statements": [
        [
          416,
          "ep->re_attr.send_cq = NULL;"
        ],
        [
          425,
          "ep->re_attr.recv_cq = NULL;"
        ],
        [
          464,
          "ep->re_pd = NULL;"
        ]
      ],
      "cve": "CVE-2022-48773"
    },
    {
      "commit_id": "021d53a3d87eeb9dbba524ac515651242a2a7e3b",
      "filepath": "net/mac80211/agg-tx.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "ieee80211_start_tx_ba_session",
      "func_body": "int ieee80211_start_tx_ba_session(struct ieee80211_sta *pubsta, u16 tid,\n\t\t\t\t  u16 timeout)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct tid_ampdu_tx *tid_tx;\n\tint ret = 0;\n\n\ttrace_api_start_tx_ba_session(pubsta, tid);\n\n\tif (WARN(sta->reserved_tid == tid,\n\t\t \"Requested to start BA session on reserved tid=%d\", tid))\n\t\treturn -EINVAL;\n\n\tif (!pubsta->deflink.ht_cap.ht_supported &&\n\t    !pubsta->deflink.vht_cap.vht_supported &&\n\t    !pubsta->deflink.he_cap.has_he &&\n\t    !pubsta->deflink.eht_cap.has_eht)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(!local->ops->ampdu_action))\n\t\treturn -EINVAL;\n\n\tif ((tid >= IEEE80211_NUM_TIDS) ||\n\t    !ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION) ||\n\t    ieee80211_hw_check(&local->hw, TX_AMPDU_SETUP_IN_HW))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(tid >= IEEE80211_FIRST_TSPEC_TSID))\n\t\treturn -EINVAL;\n\n\tht_dbg(sdata, \"Open BA session requested for %pM tid %u\\n\",\n\t       pubsta->addr, tid);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&\n\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t    sdata->vif.type != NL80211_IFTYPE_AP &&\n\t    sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\treturn -EINVAL;\n\n\tif (test_sta_flag(sta, WLAN_STA_BLOCK_BA)) {\n\t\tht_dbg(sdata,\n\t\t       \"BA sessions blocked - Denying BA session request %pM tid %d\\n\",\n\t\t       sta->sta.addr, tid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_sta_flag(sta, WLAN_STA_MFP) &&\n\t    !test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {\n\t\tht_dbg(sdata,\n\t\t       \"MFP STA not authorized - deny BA session request %pM tid %d\\n\",\n\t\t       sta->sta.addr, tid);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * 802.11n-2009 11.5.1.1: If the initiating STA is an HT STA, is a\n\t * member of an IBSS, and has no other existing Block Ack agreement\n\t * with the recipient STA, then the initiating STA shall transmit a\n\t * Probe Request frame to the recipient STA and shall not transmit an\n\t * ADDBA Request frame unless it receives a Probe Response frame\n\t * from the recipient within dot11ADDBAFailureTimeout.\n\t *\n\t * The probe request mechanism for ADDBA is currently not implemented,\n\t * but we only build up Block Ack session with HT STAs. This information\n\t * is set when we receive a bss info from a probe response or a beacon.\n\t */\n\tif (sta->sdata->vif.type == NL80211_IFTYPE_ADHOC &&\n\t    !sta->sta.deflink.ht_cap.ht_supported) {\n\t\tht_dbg(sdata,\n\t\t       \"BA request denied - IBSS STA %pM does not advertise HT support\\n\",\n\t\t       pubsta->addr);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&sta->lock);\n\n\t/* we have tried too many times, receiver does not want A-MPDU */\n\tif (sta->ampdu_mlme.addba_req_num[tid] > HT_AGG_MAX_RETRIES) {\n\t\tret = -EBUSY;\n\t\tgoto err_unlock_sta;\n\t}\n\n\t/*\n\t * if we have tried more than HT_AGG_BURST_RETRIES times we\n\t * will spread our requests in time to avoid stalling connection\n\t * for too long\n\t */\n\tif (sta->ampdu_mlme.addba_req_num[tid] > HT_AGG_BURST_RETRIES &&\n\t    time_before(jiffies, sta->ampdu_mlme.last_addba_req_time[tid] +\n\t\t\tHT_AGG_RETRIES_PERIOD)) {\n\t\tht_dbg(sdata,\n\t\t       \"BA request denied - %d failed requests on %pM tid %u\\n\",\n\t\t       sta->ampdu_mlme.addba_req_num[tid], sta->sta.addr, tid);\n\t\tret = -EBUSY;\n\t\tgoto err_unlock_sta;\n\t}\n\n\ttid_tx = rcu_dereference_protected_tid_tx(sta, tid);\n\t/* check if the TID is not in aggregation flow already */\n\tif (tid_tx || sta->ampdu_mlme.tid_start_tx[tid]) {\n\t\tht_dbg(sdata,\n\t\t       \"BA request denied - session is not idle on %pM tid %u\\n\",\n\t\t       sta->sta.addr, tid);\n\t\tret = -EAGAIN;\n\t\tgoto err_unlock_sta;\n\t}\n\n\t/* prepare A-MPDU MLME for Tx aggregation */\n\ttid_tx = kzalloc(sizeof(struct tid_ampdu_tx), GFP_ATOMIC);\n\tif (!tid_tx) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock_sta;\n\t}\n\n\tskb_queue_head_init(&tid_tx->pending);\n\t__set_bit(HT_AGG_STATE_WANT_START, &tid_tx->state);\n\n\ttid_tx->timeout = timeout;\n\ttid_tx->sta = sta;\n\ttid_tx->tid = tid;\n\n\t/* response timer */\n\ttimer_setup(&tid_tx->addba_resp_timer, sta_addba_resp_timer_expired, 0);\n\n\t/* tx timer */\n\ttimer_setup(&tid_tx->session_timer,\n\t\t    sta_tx_agg_session_timer_expired, TIMER_DEFERRABLE);\n\n\t/* assign a dialog token */\n\tsta->ampdu_mlme.dialog_token_allocator++;\n\ttid_tx->dialog_token = sta->ampdu_mlme.dialog_token_allocator;\n\n\t/*\n\t * Finally, assign it to the start array; the work item will\n\t * collect it and move it to the normal array.\n\t */\n\tsta->ampdu_mlme.tid_start_tx[tid] = tid_tx;\n\n\twiphy_work_queue(local->hw.wiphy, &sta->ampdu_mlme.work);\n\n\t/* this flow continues off the work */\n err_unlock_sta:\n\tspin_unlock_bh(&sta->lock);\n\treturn ret;\n}\n",
      "line_statements": [
        [
          619,
          "\t    !pubsta->deflink.vht_cap.vht_supported &&\n"
        ],
        [
          620,
          "\t    !pubsta->deflink.he_cap.has_he &&\n"
        ],
        [
          621,
          "\t    !pubsta->deflink.eht_cap.has_eht)\n"
        ]
      ],
      "statements": [
        [
          618,
          "if (!pubsta->deflink.ht_cap.ht_supported &&\n\t    !pubsta->deflink.vht_cap.vht_supported &&\n\t    !pubsta->deflink.he_cap.has_he &&\n\t    !pubsta->deflink.eht_cap.has_eht)"
        ]
      ],
      "cve": "CVE-2024-43911"
    },
    {
      "commit_id": "65ade5653f5ab5a21635e51d0c65e95f490f5b6f",
      "filepath": "drivers/iommu/arm/arm-smmu/arm-smmu-nvidia.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "nvidia_smmu_context_fault",
      "func_body": "static irqreturn_t nvidia_smmu_context_fault(int irq, void *dev)\n{\n\tint idx;\n\tunsigned int inst;\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct arm_smmu_device *smmu;\n\tstruct iommu_domain *domain = dev;\n\tstruct arm_smmu_domain *smmu_domain;\n\tstruct nvidia_smmu *nvidia;\n\n\tsmmu_domain = container_of(domain, struct arm_smmu_domain, domain);\n\tsmmu = smmu_domain->smmu;\n\tnvidia = to_nvidia_smmu(smmu);\n\n\tfor (inst = 0; inst < nvidia->num_instances; inst++) {\n\t\tirqreturn_t irq_ret;\n\n\t\t/*\n\t\t * Interrupt line is shared between all contexts.\n\t\t * Check for faults across all contexts.\n\t\t */\n\t\tfor (idx = 0; idx < smmu->num_context_banks; idx++) {\n\t\t\tirq_ret = nvidia_smmu_context_fault_bank(irq, smmu,\n\t\t\t\t\t\t\t\t idx, inst);\n\t\t\tif (irq_ret == IRQ_HANDLED)\n\t\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
      "line_statements": [
        [
          224,
          "\tstruct iommu_domain *domain = dev;\n"
        ],
        [
          225,
          "\tstruct arm_smmu_domain *smmu_domain;\n"
        ],
        [
          228,
          "\tsmmu_domain = container_of(domain, struct arm_smmu_domain, domain);\n"
        ]
      ],
      "statements": [
        [
          224,
          "struct iommu_domain *domain = dev;"
        ],
        [
          225,
          "struct arm_smmu_domain *smmu_domain;"
        ],
        [
          228,
          "smmu_domain = container_of(domain, struct arm_smmu_domain, domain);"
        ]
      ],
      "cve": "CVE-2024-36884"
    },
    {
      "commit_id": "01ca667133d019edc9f0a1f70a272447c84ec41f",
      "filepath": "drivers/net/ethernet/intel/fm10k/fm10k_main.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "fm10k_init_module",
      "func_body": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\n\t/* create driver workqueue */\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\tif (!fm10k_workqueue)\n\t\treturn -ENOMEM;\n\n\tfm10k_dbg_init();\n\n\treturn fm10k_register_pci_driver();\n}",
      "line_statements": [
        [
          44,
          "\tif (!fm10k_workqueue)"
        ],
        [
          45,
          "\t\treturn -ENOMEM;"
        ]
      ],
      "statements": [
        [
          44,
          "if (!fm10k_workqueue)"
        ],
        [
          45,
          "return -ENOMEM;"
        ]
      ],
      "cve": "CVE-2019-15924"
    },
    {
      "commit_id": "d11a67634227f9f9da51938af085fb41a733848f",
      "filepath": "drivers/net/ethernet/intel/ice/ice_main.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "ice_rebuild",
      "func_body": "static void ice_rebuild(struct ice_pf *pf, enum ice_reset_req reset_type)\n{\n\tstruct ice_vsi *vsi = ice_get_main_vsi(pf);\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_hw *hw = &pf->hw;\n\tbool dvm;\n\tint err;\n\n\tif (test_bit(ICE_DOWN, pf->state))\n\t\tgoto clear_recovery;\n\n\tdev_dbg(dev, \"rebuilding PF after reset_type=%d\\n\", reset_type);\n\n#define ICE_EMP_RESET_SLEEP_MS 5000\n\tif (reset_type == ICE_RESET_EMPR) {\n\t\t/* If an EMP reset has occurred, any previously pending flash\n\t\t * update will have completed. We no longer know whether or\n\t\t * not the NVM update EMP reset is restricted.\n\t\t */\n\t\tpf->fw_emp_reset_disabled = false;\n\n\t\tmsleep(ICE_EMP_RESET_SLEEP_MS);\n\t}\n\n\terr = ice_init_all_ctrlq(hw);\n\tif (err) {\n\t\tdev_err(dev, \"control queues init failed %d\\n\", err);\n\t\tgoto err_init_ctrlq;\n\t}\n\n\t/* if DDP was previously loaded successfully */\n\tif (!ice_is_safe_mode(pf)) {\n\t\t/* reload the SW DB of filter tables */\n\t\tif (reset_type == ICE_RESET_PFR)\n\t\t\tice_fill_blk_tbls(hw);\n\t\telse\n\t\t\t/* Reload DDP Package after CORER/GLOBR reset */\n\t\t\tice_load_pkg(NULL, pf);\n\t}\n\n\terr = ice_clear_pf_cfg(hw);\n\tif (err) {\n\t\tdev_err(dev, \"clear PF configuration failed %d\\n\", err);\n\t\tgoto err_init_ctrlq;\n\t}\n\n\tice_clear_pxe_mode(hw);\n\n\terr = ice_init_nvm(hw);\n\tif (err) {\n\t\tdev_err(dev, \"ice_init_nvm failed %d\\n\", err);\n\t\tgoto err_init_ctrlq;\n\t}\n\n\terr = ice_get_caps(hw);\n\tif (err) {\n\t\tdev_err(dev, \"ice_get_caps failed %d\\n\", err);\n\t\tgoto err_init_ctrlq;\n\t}\n\n\terr = ice_aq_set_mac_cfg(hw, ICE_AQ_SET_MAC_FRAME_SIZE_MAX, NULL);\n\tif (err) {\n\t\tdev_err(dev, \"set_mac_cfg failed %d\\n\", err);\n\t\tgoto err_init_ctrlq;\n\t}\n\n\tdvm = ice_is_dvm_ena(hw);\n\n\terr = ice_aq_set_port_params(pf->hw.port_info, dvm, NULL);\n\tif (err)\n\t\tgoto err_init_ctrlq;\n\n\terr = ice_sched_init_port(hw->port_info);\n\tif (err)\n\t\tgoto err_sched_init_port;\n\n\t/* start misc vector */\n\terr = ice_req_irq_msix_misc(pf);\n\tif (err) {\n\t\tdev_err(dev, \"misc vector setup failed: %d\\n\", err);\n\t\tgoto err_sched_init_port;\n\t}\n\n\tif (test_bit(ICE_FLAG_FD_ENA, pf->flags)) {\n\t\twr32(hw, PFQF_FD_ENA, PFQF_FD_ENA_FD_ENA_M);\n\t\tif (!rd32(hw, PFQF_FD_SIZE)) {\n\t\t\tu16 unused, guar, b_effort;\n\n\t\t\tguar = hw->func_caps.fd_fltr_guar;\n\t\t\tb_effort = hw->func_caps.fd_fltr_best_effort;\n\n\t\t\t/* force guaranteed filter pool for PF */\n\t\t\tice_alloc_fd_guar_item(hw, &unused, guar);\n\t\t\t/* force shared filter pool for PF */\n\t\t\tice_alloc_fd_shrd_item(hw, &unused, b_effort);\n\t\t}\n\t}\n\n\tif (test_bit(ICE_FLAG_DCB_ENA, pf->flags))\n\t\tice_dcb_rebuild(pf);\n\n\t/* If the PF previously had enabled PTP, PTP init needs to happen before\n\t * the VSI rebuild. If not, this causes the PTP link status events to\n\t * fail.\n\t */\n\tif (test_bit(ICE_FLAG_PTP_SUPPORTED, pf->flags))\n\t\tice_ptp_rebuild(pf, reset_type);\n\n\tif (ice_is_feature_supported(pf, ICE_F_GNSS))\n\t\tice_gnss_init(pf);\n\n\t/* rebuild PF VSI */\n\terr = ice_vsi_rebuild_by_type(pf, ICE_VSI_PF);\n\tif (err) {\n\t\tdev_err(dev, \"PF VSI rebuild failed: %d\\n\", err);\n\t\tgoto err_vsi_rebuild;\n\t}\n\n\tif (reset_type == ICE_RESET_PFR) {\n\t\terr = ice_rebuild_channels(pf);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to rebuild and replay ADQ VSIs, err %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto err_vsi_rebuild;\n\t\t}\n\t}\n\n\t/* If Flow Director is active */\n\tif (test_bit(ICE_FLAG_FD_ENA, pf->flags)) {\n\t\terr = ice_vsi_rebuild_by_type(pf, ICE_VSI_CTRL);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"control VSI rebuild failed: %d\\n\", err);\n\t\t\tgoto err_vsi_rebuild;\n\t\t}\n\n\t\t/* replay HW Flow Director recipes */\n\t\tif (hw->fdir_prof)\n\t\t\tice_fdir_replay_flows(hw);\n\n\t\t/* replay Flow Director filters */\n\t\tice_fdir_replay_fltrs(pf);\n\n\t\tice_rebuild_arfs(pf);\n\t}\n\n\tif (vsi && vsi->netdev)\n\t\tnetif_device_attach(vsi->netdev);\n\n\tice_update_pf_netdev_link(pf);\n\n\t/* tell the firmware we are up */\n\terr = ice_send_version(pf);\n\tif (err) {\n\t\tdev_err(dev, \"Rebuild failed due to error sending driver version: %d\\n\",\n\t\t\terr);\n\t\tgoto err_vsi_rebuild;\n\t}\n\n\tice_replay_post(hw);\n\n\t/* if we get here, reset flow is successful */\n\tclear_bit(ICE_RESET_FAILED, pf->state);\n\n\tice_plug_aux_dev(pf);\n\tif (ice_is_feature_supported(pf, ICE_F_SRIOV_LAG))\n\t\tice_lag_rebuild(pf);\n\n\t/* Restore timestamp mode settings after VSI rebuild */\n\tice_ptp_restore_timestamp_mode(pf);\n\treturn;\n\nerr_vsi_rebuild:\nerr_sched_init_port:\n\tice_sched_cleanup_all(hw);\nerr_init_ctrlq:\n\tice_shutdown_all_ctrlq(hw, false);\n\tset_bit(ICE_RESET_FAILED, pf->state);\nclear_recovery:\n\t/* set this bit in PF state to control service task scheduling */\n\tset_bit(ICE_NEEDS_RESTART, pf->state);\n\tdev_err(dev, \"Rebuild failed, unload and reload driver\\n\");\n}\n",
      "line_statements": [
        [
          7595,
          "\tstruct ice_vsi *vsi = ice_get_main_vsi(pf);\n"
        ],
        [
          7738,
          "\tif (vsi && vsi->netdev)\n"
        ],
        [
          7739,
          "\t\tnetif_device_attach(vsi->netdev);\n"
        ],
        [
          7740,
          "\n"
        ]
      ],
      "statements": [
        [
          7595,
          "struct ice_vsi *vsi = ice_get_main_vsi(pf);"
        ],
        [
          7738,
          "if (vsi && vsi->netdev)"
        ],
        [
          7739,
          "netif_device_attach(vsi->netdev);"
        ],
        [
          7740,
          "\n"
        ]
      ],
      "cve": "CVE-2024-46770"
    },
    {
      "commit_id": "62929726ef0ec72cbbe9440c5d125d4278b99894",
      "filepath": "drivers/gpu/drm/drm_connector.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "drm_connector_set_vrr_capable_property",
      "func_body": "void drm_connector_set_vrr_capable_property(\n\t\tstruct drm_connector *connector, bool capable)\n{\n\tdrm_object_property_set_value(&connector->base,\n\t\t\t\t      connector->vrr_capable_property,\n\t\t\t\t      capable);\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2022-48843"
    },
    {
      "commit_id": "871cd9d881fa791d3f82885000713de07041c0ae",
      "filepath": "drivers/gpu/drm/amd/display/dc/core/dc_resource.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "resource_log_pipe_topology_update",
      "func_body": "void resource_log_pipe_topology_update(struct dc *dc, struct dc_state *state)\n{\n\tstruct pipe_ctx *otg_master;\n\tint stream_idx, phantom_stream_idx;\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tDC_LOG_DC(\"    pipe topology update\");\n\tDC_LOG_DC(\"  ________________________\");\n\tfor (stream_idx = 0; stream_idx < state->stream_count; stream_idx++) {\n\t\tif (state->streams[stream_idx]->is_phantom)\n\t\t\tcontinue;\n\n\t\totg_master = resource_get_otg_master_for_stream(\n\t\t\t\t&state->res_ctx, state->streams[stream_idx]);\n\n\t\tif (!otg_master)\n\t\t\tcontinue;\n\n\t\tresource_log_pipe_for_stream(dc, state, otg_master, stream_idx);\n\t}\n\tif (state->phantom_stream_count > 0) {\n\t\tDC_LOG_DC(\" |    (phantom pipes)     |\");\n\t\tfor (stream_idx = 0; stream_idx < state->stream_count; stream_idx++) {\n\t\t\tif (state->stream_status[stream_idx].mall_stream_config.type != SUBVP_MAIN)\n\t\t\t\tcontinue;\n\n\t\t\tphantom_stream_idx = resource_stream_to_stream_idx(state,\n\t\t\t\t\tstate->stream_status[stream_idx].mall_stream_config.paired_stream);\n\t\t\totg_master = resource_get_otg_master_for_stream(\n\t\t\t\t\t&state->res_ctx, state->streams[phantom_stream_idx]);\n\t\t\tif (!otg_master)\n\t\t\t\tcontinue;\n\n\t\t\tresource_log_pipe_for_stream(dc, state, otg_master, stream_idx);\n\t\t}\n\t}\n\tDC_LOG_DC(\" |________________________|\\n\");\n}\n",
      "line_statements": [
        [
          2332,
          "\t\t\tif (!otg_master)\n"
        ],
        [
          2333,
          "\t\t\t\tcontinue;\n"
        ],
        [
          2334,
          "\n"
        ]
      ],
      "statements": [
        [
          2332,
          "if (!otg_master)"
        ],
        [
          2333,
          "continue;"
        ],
        [
          2334,
          "\n"
        ]
      ],
      "cve": "CVE-2024-46727"
    },
    {
      "commit_id": "cfaa80c91f6f99b9342b6557f0f0e1143e434066",
      "filepath": "net/tls/tls_sw.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "bpf_exec_tx_verdict",
      "func_body": "static int bpf_exec_tx_verdict(struct sk_msg *msg, struct sock *sk,\n\t\t\t       bool full_record, u8 record_type,\n\t\t\t       ssize_t *copied, int flags)\n{\n\tstruct tls_context *tls_ctx = tls_get_ctx(sk);\n\tstruct tls_sw_context_tx *ctx = tls_sw_ctx_tx(tls_ctx);\n\tstruct sk_msg msg_redir = { };\n\tstruct sk_psock *psock;\n\tstruct sock *sk_redir;\n\tstruct tls_rec *rec;\n\tbool enospc, policy, redir_ingress;\n\tint err = 0, send;\n\tu32 delta = 0;\n\n\tpolicy = !(flags & MSG_SENDPAGE_NOPOLICY);\n\tpsock = sk_psock_get(sk);\n\tif (!psock || !policy) {\n\t\terr = tls_push_record(sk, flags, record_type);\n\t\tif (err && sk->sk_err == EBADMSG) {\n\t\t\t*copied -= sk_msg_free(sk, msg);\n\t\t\ttls_free_open_rec(sk);\n\t\t\terr = -sk->sk_err;\n\t\t}\n\t\tif (psock)\n\t\t\tsk_psock_put(sk, psock);\n\t\treturn err;\n\t}\nmore_data:\n\tenospc = sk_msg_full(msg);\n\tif (psock->eval == __SK_NONE) {\n\t\tdelta = msg->sg.size;\n\t\tpsock->eval = sk_psock_msg_verdict(sk, psock, msg);\n\t\tdelta -= msg->sg.size;\n\t}\n\tif (msg->cork_bytes && msg->cork_bytes > msg->sg.size &&\n\t    !enospc && !full_record) {\n\t\terr = -ENOSPC;\n\t\tgoto out_err;\n\t}\n\tmsg->cork_bytes = 0;\n\tsend = msg->sg.size;\n\tif (msg->apply_bytes && msg->apply_bytes < send)\n\t\tsend = msg->apply_bytes;\n\n\tswitch (psock->eval) {\n\tcase __SK_PASS:\n\t\terr = tls_push_record(sk, flags, record_type);\n\t\tif (err && sk->sk_err == EBADMSG) {\n\t\t\t*copied -= sk_msg_free(sk, msg);\n\t\t\ttls_free_open_rec(sk);\n\t\t\terr = -sk->sk_err;\n\t\t\tgoto out_err;\n\t\t}\n\t\tbreak;\n\tcase __SK_REDIRECT:\n\t\tredir_ingress = psock->redir_ingress;\n\t\tsk_redir = psock->sk_redir;\n\t\tmemcpy(&msg_redir, msg, sizeof(*msg));\n\t\tif (msg->apply_bytes < send)\n\t\t\tmsg->apply_bytes = 0;\n\t\telse\n\t\t\tmsg->apply_bytes -= send;\n\t\tsk_msg_return_zero(sk, msg, send);\n\t\tmsg->sg.size -= send;\n\t\trelease_sock(sk);\n\t\terr = tcp_bpf_sendmsg_redir(sk_redir, redir_ingress,\n\t\t\t\t\t    &msg_redir, send, flags);\n\t\tlock_sock(sk);\n\t\tif (err < 0) {\n\t\t\t*copied -= sk_msg_free_nocharge(sk, &msg_redir);\n\t\t\tmsg->sg.size = 0;\n\t\t}\n\t\tif (msg->sg.size == 0)\n\t\t\ttls_free_open_rec(sk);\n\t\tbreak;\n\tcase __SK_DROP:\n\tdefault:\n\t\tsk_msg_free_partial(sk, msg, send);\n\t\tif (msg->apply_bytes < send)\n\t\t\tmsg->apply_bytes = 0;\n\t\telse\n\t\t\tmsg->apply_bytes -= send;\n\t\tif (msg->sg.size == 0)\n\t\t\ttls_free_open_rec(sk);\n\t\t*copied -= (send + delta);\n\t\terr = -EACCES;\n\t}\n\n\tif (likely(!err)) {\n\t\tbool reset_eval = !ctx->open_rec;\n\n\t\trec = ctx->open_rec;\n\t\tif (rec) {\n\t\t\tmsg = &rec->msg_plaintext;\n\t\t\tif (!msg->apply_bytes)\n\t\t\t\treset_eval = true;\n\t\t}\n\t\tif (reset_eval) {\n\t\t\tpsock->eval = __SK_NONE;\n\t\t\tif (psock->sk_redir) {\n\t\t\t\tsock_put(psock->sk_redir);\n\t\t\t\tpsock->sk_redir = NULL;\n\t\t\t}\n\t\t}\n\t\tif (rec)\n\t\t\tgoto more_data;\n\t}\n out_err:\n\tsk_psock_put(sk, psock);\n\treturn err;\n}\n",
      "line_statements": [
        [
          820,
          "\t\tif (err && sk->sk_err == EBADMSG) {\n"
        ],
        [
          849,
          "\t\tif (err && sk->sk_err == EBADMSG) {\n"
        ]
      ],
      "statements": [
        [
          820,
          "if (err && sk->sk_err == EBADMSG)"
        ],
        [
          849,
          "if (err && sk->sk_err == EBADMSG)"
        ]
      ],
      "cve": "CVE-2023-6176"
    },
    {
      "commit_id": "41673c66b3d0c09915698fec5c13b24336f18dd1",
      "filepath": "drivers/mfd/syscon.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "of_syscon_register",
      "func_body": "static struct syscon *of_syscon_register(struct device_node *np, bool check_res)\n{\n\tstruct clk *clk;\n\tstruct syscon *syscon;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tu32 reg_io_width;\n\tint ret;\n\tstruct regmap_config syscon_config = syscon_regmap_config;\n\tstruct resource res;\n\tstruct reset_control *reset;\n\n\tsyscon = kzalloc(sizeof(*syscon), GFP_KERNEL);\n\tif (!syscon)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (of_address_to_resource(np, 0, &res)) {\n\t\tret = -ENOMEM;\n\t\tgoto err_map;\n\t}\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tret = -ENOMEM;\n\t\tgoto err_map;\n\t}\n\n\t/* Parse the device's DT node for an endianness specification */\n\tif (of_property_read_bool(np, \"big-endian\"))\n\t\tsyscon_config.val_format_endian = REGMAP_ENDIAN_BIG;\n\telse if (of_property_read_bool(np, \"little-endian\"))\n\t\tsyscon_config.val_format_endian = REGMAP_ENDIAN_LITTLE;\n\telse if (of_property_read_bool(np, \"native-endian\"))\n\t\tsyscon_config.val_format_endian = REGMAP_ENDIAN_NATIVE;\n\n\t/*\n\t * search for reg-io-width property in DT. If it is not provided,\n\t * default to 4 bytes. regmap_init_mmio will return an error if values\n\t * are invalid so there is no need to check them here.\n\t */\n\tret = of_property_read_u32(np, \"reg-io-width\", &reg_io_width);\n\tif (ret)\n\t\treg_io_width = 4;\n\n\tret = of_hwspin_lock_get_id(np, 0);\n\tif (ret > 0 || (IS_ENABLED(CONFIG_HWSPINLOCK) && ret == 0)) {\n\t\tsyscon_config.use_hwlock = true;\n\t\tsyscon_config.hwlock_id = ret;\n\t\tsyscon_config.hwlock_mode = HWLOCK_IRQSTATE;\n\t} else if (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase -ENOENT:\n\t\t\t/* Ignore missing hwlock, it's optional. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Failed to retrieve valid hwlock: %d\\n\", ret);\n\t\t\tfallthrough;\n\t\tcase -EPROBE_DEFER:\n\t\t\tgoto err_regmap;\n\t\t}\n\t}\n\n\tsyscon_config.name = kasprintf(GFP_KERNEL, \"%pOFn@%pa\", np, &res.start);\n\tif (!syscon_config.name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_regmap;\n\t}\n\tsyscon_config.reg_stride = reg_io_width;\n\tsyscon_config.val_bits = reg_io_width * 8;\n\tsyscon_config.max_register = resource_size(&res) - reg_io_width;\n\n\tregmap = regmap_init_mmio(NULL, base, &syscon_config);\n\tkfree(syscon_config.name);\n\tif (IS_ERR(regmap)) {\n\t\tpr_err(\"regmap init failed\\n\");\n\t\tret = PTR_ERR(regmap);\n\t\tgoto err_regmap;\n\t}\n\n\tif (check_res) {\n\t\tclk = of_clk_get(np, 0);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\t/* clock is optional */\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto err_clk;\n\t\t} else {\n\t\t\tret = regmap_mmio_attach_clk(regmap, clk);\n\t\t\tif (ret)\n\t\t\t\tgoto err_attach_clk;\n\t\t}\n\n\t\treset = of_reset_control_get_optional_exclusive(np, NULL);\n\t\tif (IS_ERR(reset)) {\n\t\t\tret = PTR_ERR(reset);\n\t\t\tgoto err_attach_clk;\n\t\t}\n\n\t\tret = reset_control_deassert(reset);\n\t\tif (ret)\n\t\t\tgoto err_reset;\n\t}\n\n\tsyscon->regmap = regmap;\n\tsyscon->np = np;\n\n\tspin_lock(&syscon_list_slock);\n\tlist_add_tail(&syscon->list, &syscon_list);\n\tspin_unlock(&syscon_list_slock);\n\n\treturn syscon;\n\nerr_reset:\n\treset_control_put(reset);\nerr_attach_clk:\n\tif (!IS_ERR(clk))\n\t\tclk_put(clk);\nerr_clk:\n\tregmap_exit(regmap);\nerr_regmap:\n\tiounmap(base);\nerr_map:\n\tkfree(syscon);\n\treturn ERR_PTR(ret);\n}\n",
      "line_statements": [
        [
          108,
          "\tif (!syscon_config.name) {\n"
        ],
        [
          109,
          "\t\tret = -ENOMEM;\n"
        ],
        [
          110,
          "\t\tgoto err_regmap;\n"
        ],
        [
          111,
          "\t}\n"
        ]
      ],
      "statements": [
        [
          108,
          "if (!syscon_config.name)"
        ],
        [
          109,
          "ret = -ENOMEM;"
        ],
        [
          110,
          "goto err_regmap;"
        ],
        [
          111,
          "\t}\n"
        ]
      ],
      "cve": "CVE-2023-52467"
    },
    {
      "commit_id": "efeb7dfea8ee10cdec11b6b6ba4e405edbe75809",
      "filepath": "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "mlxsw_sp_acl_tcam_region_destroy",
      "func_body": "static void\nmlxsw_sp_acl_tcam_region_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_acl_tcam_region *region)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\n\tops->region_fini(mlxsw_sp, region->priv);\n\tmlxsw_sp_acl_tcam_region_disable(mlxsw_sp, region);\n\tmlxsw_sp_acl_tcam_region_free(mlxsw_sp, region);\n\tmlxsw_sp_acl_tcam_region_id_put(region->group->tcam,\n\t\t\t\t\tregion->id);\n\tkfree(region);\n}\n",
      "line_statements": [
        [
          689,
          "\tmlxsw_sp_acl_tcam_region_id_put(region->group->tcam,\n"
        ],
        [
          690,
          "\t\t\t\t\tregion->id);\n"
        ]
      ],
      "statements": [
        [
          689,
          "mlxsw_sp_acl_tcam_region_id_put(region->group->tcam,\n\t\t\t\t\tregion->id);"
        ]
      ],
      "cve": "CVE-2024-26595"
    },
    {
      "commit_id": "468e3295774d0edce15f4ae475913b5076dd4f40",
      "filepath": "drivers/crypto/ccp/sev-dev.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "__sev_snp_shutdown_locked",
      "func_body": "static int __sev_snp_shutdown_locked(int *error, bool panic)\n{\n\tstruct sev_device *sev = psp_master->sev_data;\n\tstruct sev_data_snp_shutdown_ex data;\n\tint ret;\n\n\tif (!sev->snp_initialized)\n\t\treturn 0;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.len = sizeof(data);\n\tdata.iommu_snp_shutdown = 1;\n\n\t/*\n\t * If invoked during panic handling, local interrupts are disabled\n\t * and all CPUs are stopped, so wbinvd_on_all_cpus() can't be called.\n\t * In that case, a wbinvd() is done on remote CPUs via the NMI\n\t * callback, so only a local wbinvd() is needed here.\n\t */\n\tif (!panic)\n\t\twbinvd_on_all_cpus();\n\telse\n\t\twbinvd();\n\n\tret = __sev_do_cmd_locked(SEV_CMD_SNP_SHUTDOWN_EX, &data, error);\n\t/* SHUTDOWN may require DF_FLUSH */\n\tif (*error == SEV_RET_DFFLUSH_REQUIRED) {\n\t\tret = __sev_do_cmd_locked(SEV_CMD_SNP_DF_FLUSH, NULL, NULL);\n\t\tif (ret) {\n\t\t\tdev_err(sev->dev, \"SEV-SNP DF_FLUSH failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t/* reissue the shutdown command */\n\t\tret = __sev_do_cmd_locked(SEV_CMD_SNP_SHUTDOWN_EX, &data,\n\t\t\t\t\t  error);\n\t}\n\tif (ret) {\n\t\tdev_err(sev->dev, \"SEV-SNP firmware shutdown failed\\n\");\n\t\treturn ret;\n\t}\n\n\t/*\n\t * SNP_SHUTDOWN_EX with IOMMU_SNP_SHUTDOWN set to 1 disables SNP\n\t * enforcement by the IOMMU and also transitions all pages\n\t * associated with the IOMMU to the Reclaim state.\n\t * Firmware was transitioning the IOMMU pages to Hypervisor state\n\t * before version 1.53. But, accounting for the number of assigned\n\t * 4kB pages in a 2M page was done incorrectly by not transitioning\n\t * to the Reclaim state. This resulted in RMP #PF when later accessing\n\t * the 2M page containing those pages during kexec boot. Hence, the\n\t * firmware now transitions these pages to Reclaim state and hypervisor\n\t * needs to transition these pages to shared state. SNP Firmware\n\t * version 1.53 and above are needed for kexec boot.\n\t */\n\tret = amd_iommu_snp_disable();\n\tif (ret) {\n\t\tdev_err(sev->dev, \"SNP IOMMU shutdown failed\\n\");\n\t\treturn ret;\n\t}\n\n\tsev->snp_initialized = false;\n\tdev_dbg(sev->dev, \"SEV-SNP firmware shutdown\\n\");\n\n\treturn ret;\n}\n",
      "line_statements": [
        [
          1645,
          "\tstruct sev_device *sev = psp_master->sev_data;\n"
        ]
      ],
      "statements": [
        [
          1645,
          "struct sev_device *sev = psp_master->sev_data;"
        ]
      ],
      "cve": "CVE-2024-43874"
    },
    {
      "commit_id": "e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
      "filepath": "fs/btrfs/volumes.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "btrfs_rm_device",
      "func_body": "int btrfs_rm_device(struct btrfs_fs_info *fs_info, const char *device_path,\n\t\t    u64 devid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tu64 num_devices;\n\tint ret = 0;\n\n\tmutex_lock(&uuid_mutex);\n\n\tnum_devices = btrfs_num_devices(fs_info);\n\n\tret = btrfs_check_raid_min_devices(fs_info, num_devices - 1);\n\tif (ret)\n\t\tgoto out;\n\n\tdevice = btrfs_find_device_by_devspec(fs_info, devid, device_path);\n\n\tif (IS_ERR(device)) {\n\t\tif (PTR_ERR(device) == -ENOENT &&\n\t\t    device_path && strcmp(device_path, \"missing\") == 0)\n\t\t\tret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;\n\t\telse\n\t\t\tret = PTR_ERR(device);\n\t\tgoto out;\n\t}\n\n\tif (btrfs_pinned_by_swapfile(fs_info, device)) {\n\t\tbtrfs_warn_in_rcu(fs_info,\n\t\t  \"cannot remove device %s (devid %llu) due to active swapfile\",\n\t\t\t\t  rcu_str_deref(device->name), device->devid);\n\t\tret = -ETXTBSY;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tret = BTRFS_ERROR_DEV_TGT_REPLACE;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state) &&\n\t    fs_info->fs_devices->rw_devices == 1) {\n\t\tret = BTRFS_ERROR_DEV_ONLY_WRITABLE;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tlist_del_init(&device->dev_alloc_list);\n\t\tdevice->fs_devices->rw_devices--;\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\n\n\tmutex_unlock(&uuid_mutex);\n\tret = btrfs_shrink_device(device, 0);\n\tif (!ret)\n\t\tbtrfs_reada_remove_dev(device);\n\tmutex_lock(&uuid_mutex);\n\tif (ret)\n\t\tgoto error_undo;\n\n\t/*\n\t * TODO: the superblock still includes this device in its num_devices\n\t * counter although write_all_supers() is not locked out. This\n\t * could give a filesystem state which requires a degraded mount.\n\t */\n\tret = btrfs_rm_dev_item(device);\n\tif (ret)\n\t\tgoto error_undo;\n\n\tclear_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state);\n\tbtrfs_scrub_cancel_dev(device);\n\n\t/*\n\t * the device list mutex makes sure that we don't change\n\t * the device list while someone else is writing out all\n\t * the device supers. Whoever is writing all supers, should\n\t * lock the device list mutex before getting the number of\n\t * devices in the super block (super_copy). Conversely,\n\t * whoever updates the number of devices in the super block\n\t * (super_copy) should hold the device list mutex.\n\t */\n\n\t/*\n\t * In normal cases the cur_devices == fs_devices. But in case\n\t * of deleting a seed device, the cur_devices should point to\n\t * its own fs_devices listed under the fs_devices->seed.\n\t */\n\tcur_devices = device->fs_devices;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_del_rcu(&device->dev_list);\n\n\tcur_devices->num_devices--;\n\tcur_devices->total_devices--;\n\t/* Update total_devices of the parent fs_devices if it's seed */\n\tif (cur_devices != fs_devices)\n\t\tfs_devices->total_devices--;\n\n\tif (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state))\n\t\tcur_devices->missing_devices--;\n\n\tbtrfs_assign_next_active_device(device, NULL);\n\n\tif (device->bdev) {\n\t\tcur_devices->open_devices--;\n\t\t/* remove sysfs entry */\n\t\tbtrfs_sysfs_remove_device(device);\n\t}\n\n\tnum_devices = btrfs_super_num_devices(fs_info->super_copy) - 1;\n\tbtrfs_set_super_num_devices(fs_info->super_copy, num_devices);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t/*\n\t * at this point, the device is zero sized and detached from\n\t * the devices list.  All that's left is to zero out the old\n\t * supers and free the device.\n\t */\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state))\n\t\tbtrfs_scratch_superblocks(fs_info, device->bdev,\n\t\t\t\t\t  device->name->str);\n\n\tbtrfs_close_bdev(device);\n\tsynchronize_rcu();\n\tbtrfs_free_device(device);\n\n\tif (cur_devices->open_devices == 0) {\n\t\tlist_del_init(&cur_devices->seed_list);\n\t\tclose_fs_devices(cur_devices);\n\t\tfree_fs_devices(cur_devices);\n\t}\n\nout:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n\nerror_undo:\n\tbtrfs_reada_undo_remove_dev(device);\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tlist_add(&device->dev_alloc_list,\n\t\t\t &fs_devices->alloc_list);\n\t\tdevice->fs_devices->rw_devices++;\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\n\tgoto out;\n}\n",
      "line_statements": [
        [
          2077,
          "\t\t    device_path && strcmp(device_path, \"missing\") == 0)\n"
        ]
      ],
      "statements": [
        [
          2076,
          "if (PTR_ERR(device) == -ENOENT &&\n\t\t    device_path && strcmp(device_path, \"missing\") == 0)"
        ]
      ],
      "cve": "CVE-2021-3739"
    },
    {
      "commit_id": "d4e9a968738bf66d3bb852dd5588d4c7afd6d7f4",
      "filepath": "fs/tracefs/event_inode.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "eventfs_find_events",
      "func_body": "static struct eventfs_inode *eventfs_find_events(struct dentry *dentry)\n{\n\tstruct eventfs_inode *ei;\n\n\tdo {\n\t\t// The parent is stable because we do not do renames\n\t\tdentry = dentry->d_parent;\n\t\t// ... and directories always have d_fsdata\n\t\tei = dentry->d_fsdata;\n\n\t\t/*\n\t\t * If the ei is being freed, the ownership of the children\n\t\t * doesn't matter.\n\t\t */\n\t\tif (ei->is_freed)\n\t\t\treturn NULL;\n\n\t\t// Walk upwards until you find the events inode\n\t} while (!ei->is_events);\n\n\tupdate_events_attr(ei, dentry->d_sb);\n\n\treturn ei;\n}\n",
      "line_statements": [
        [
          348,
          "\t\tif (ei->is_freed)\n"
        ],
        [
          349,
          "\t\t\treturn NULL;\n"
        ],
        [
          350,
          "\n"
        ]
      ],
      "statements": [
        [
          348,
          "if (ei->is_freed)"
        ],
        [
          349,
          "return NULL;"
        ],
        [
          350,
          "\n"
        ]
      ],
      "cve": "CVE-2024-39470"
    },
    {
      "commit_id": "5dc7f6981fdaf74c8c5be41f393df705841fb7c5",
      "filepath": "tensorflow/core/data/compression_utils.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": true,
      "func_name": "tensorflow::data::CompressElement",
      "func_body": "Status CompressElement(const std::vector<Tensor>& element,\n                       CompressedElement* out) {\n  // Step 1: Determine the total uncompressed size. This requires serializing\n  // non-memcopyable tensors, which we save to use again later.\n  std::vector<TensorProto> non_memcpy_components;\n  int64 total_size = 0;\n  for (auto& component : element) {\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      // Some datatypes can be memcopied, allowing us to save two copies\n      // (AsProtoTensorContent and SerializeToArray).\n      total_size += DMAHelper::buffer(&component)->size();\n    } else {\n      non_memcpy_components.emplace_back();\n      component.AsProtoTensorContent(&non_memcpy_components.back());\n      total_size += non_memcpy_components.back().ByteSizeLong();\n    }\n  }\n\n  // Step 2: Write the tensor data to a buffer, and compress that buffer.\n  // We use tstring for access to resize_uninitialized.\n  tstring uncompressed;\n  uncompressed.resize_uninitialized(total_size);\n  // Position in `uncompressed` to write the next component.\n  char* position = uncompressed.mdata();\n  int non_memcpy_component_index = 0;\n  for (auto& component : element) {\n    CompressedComponentMetadata* metadata =\n        out->mutable_component_metadata()->Add();\n    metadata->set_dtype(component.dtype());\n    component.shape().AsProto(metadata->mutable_tensor_shape());\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      const TensorBuffer* buffer = DMAHelper::buffer(&component);\n      memcpy(position, buffer->data(), buffer->size());\n      metadata->set_tensor_size_bytes(buffer->size());\n    } else {\n      TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];\n      proto.SerializeToArray(position, proto.ByteSizeLong());\n      metadata->set_tensor_size_bytes(proto.ByteSizeLong());\n    }\n    position += metadata->tensor_size_bytes();\n  }\n  DCHECK_EQ(position, uncompressed.mdata() + total_size);\n\n  if (!port::Snappy_Compress(uncompressed.mdata(), total_size,\n                             out->mutable_data())) {\n    return errors::Internal(\"Failed to compress using snappy.\");\n  }\n  VLOG(3) << \"Compressed element from \" << total_size << \" bytes to \"\n          << out->data().size() << \" bytes\";\n  return Status::OK();\n}",
      "line_statements": [
        [
          34,
          "      total_size += DMAHelper::buffer(&component)->size();"
        ],
        [
          56,
          "      memcpy(position, buffer->data(), buffer->size());"
        ],
        [
          57,
          "      metadata->set_tensor_size_bytes(buffer->size());"
        ]
      ],
      "statements": [
        [
          34,
          "total_size += DMAHelper::buffer(&component)->size();"
        ],
        [
          56,
          "memcpy(position, buffer->data(), buffer->size());"
        ],
        [
          57,
          "metadata->set_tensor_size_bytes(buffer->size());"
        ]
      ],
      "cve": "CVE-2021-37637"
    },
    {
      "commit_id": "a1e627af32ed60713941cbfc8075d44cad07f6dd",
      "filepath": "drivers/mmc/core/mmc_test.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "mtf_test_write",
      "func_body": "static ssize_t mtf_test_write(struct file *file, const char __user *buf,\n\tsize_t count, loff_t *pos)\n{\n\tstruct seq_file *sf = file->private_data;\n\tstruct mmc_card *card = sf->private;\n\tstruct mmc_test_card *test;\n\tlong testcase;\n\tint ret;\n\n\tret = kstrtol_from_user(buf, count, 10, &testcase);\n\tif (ret)\n\t\treturn ret;\n\n\ttest = kzalloc(sizeof(*test), GFP_KERNEL);\n\tif (!test)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Remove all test cases associated with given card. Thus we have only\n\t * actual data of the last run.\n\t */\n\tmmc_test_free_result(card);\n\n\ttest->card = card;\n\n\ttest->buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);\n// #ifdef CONFIG_HIGHMEM\n\ttest->highmem = alloc_pages(GFP_KERNEL | __GFP_HIGHMEM, BUFFER_ORDER);\n\tif (!test->highmem) {\n\t\tcount = -ENOMEM;\n\t\tgoto free_test_buffer;\n\t}\n#endif\n\n\tif (test->buffer) {\n\t\tmutex_lock(&mmc_test_lock);\n\t\tmmc_test_run(test, testcase);\n\t\tmutex_unlock(&mmc_test_lock);\n\t}\n\n// #ifdef CONFIG_HIGHMEM\n\t__free_pages(test->highmem, BUFFER_ORDER);\nfree_test_buffer:\n#endif\n\tkfree(test->buffer);\n\tkfree(test);\n\n\treturn count;\n}\n",
      "line_statements": [
        [
          3128,
          "\tif (!test->highmem) {\n"
        ],
        [
          3129,
          "\t\tcount = -ENOMEM;\n"
        ],
        [
          3130,
          "\t\tgoto free_test_buffer;\n"
        ],
        [
          3131,
          "\t}\n"
        ],
        [
          3142,
          "free_test_buffer:\n"
        ]
      ],
      "statements": [
        [
          3128,
          "if (!test->highmem)"
        ],
        [
          3129,
          "count = -ENOMEM;"
        ],
        [
          3130,
          "goto free_test_buffer;"
        ],
        [
          3131,
          "\t}\n"
        ],
        [
          3142,
          "free_test_buffer:"
        ]
      ],
      "cve": "CVE-2024-45028"
    },
    {
      "commit_id": "1be9a950c646c9092fb3618197f7b6bfb50e82aa",
      "filepath": "net/sctp/associola.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "sctp_assoc_update",
      "func_body": "void sctp_assoc_update(struct sctp_association *asoc,\n\t\t       struct sctp_association *new)\n{\n\tstruct sctp_transport *trans;\n\tstruct list_head *pos, *temp;\n\n\t/* Copy in new parameters of peer. */\n\tasoc->c = new->c;\n\tasoc->peer.rwnd = new->peer.rwnd;\n\tasoc->peer.sack_needed = new->peer.sack_needed;\n\tasoc->peer.i = new->peer.i;\n\tsctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\n\t\t\t asoc->peer.i.initial_tsn, GFP_ATOMIC);\n\n\t/* Remove any peer addresses not present in the new association. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttrans = list_entry(pos, struct sctp_transport, transports);\n\t\tif (!sctp_assoc_lookup_paddr(new, &trans->ipaddr)) {\n\t\t\tsctp_assoc_rm_peer(asoc, trans);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (asoc->state >= SCTP_STATE_ESTABLISHED)\n\t\t\tsctp_transport_reset(trans);\n\t}\n\n\t/* If the case is A (association restart), use\n\t * initial_tsn as next_tsn. If the case is B, use\n\t * current next_tsn in case data sent to peer\n\t * has been discarded and needs retransmission.\n\t */\n\tif (asoc->state >= SCTP_STATE_ESTABLISHED) {\n\t\tasoc->next_tsn = new->next_tsn;\n\t\tasoc->ctsn_ack_point = new->ctsn_ack_point;\n\t\tasoc->adv_peer_ack_point = new->adv_peer_ack_point;\n\n\t\t/* Reinitialize SSN for both local streams\n\t\t * and peer's streams.\n\t\t */\n\t\tsctp_ssnmap_clear(asoc->ssnmap);\n\n\t\t/* Flush the ULP reassembly and ordered queue.\n\t\t * Any data there will now be stale and will\n\t\t * cause problems.\n\t\t */\n\t\tsctp_ulpq_flush(&asoc->ulpq);\n\n\t\t/* reset the overall association error count so\n\t\t * that the restarted association doesn't get torn\n\t\t * down on the next retransmission timer.\n\t\t */\n\t\tasoc->overall_error_count = 0;\n\n\t} else {\n\t\t/* Add any peer addresses from the new association. */\n\t\tlist_for_each_entry(trans, &new->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tif (!sctp_assoc_lookup_paddr(asoc, &trans->ipaddr))\n\t\t\t\tsctp_assoc_add_peer(asoc, &trans->ipaddr,\n\t\t\t\t\t\t    GFP_ATOMIC, trans->state);\n\t\t}\n\n\t\tasoc->ctsn_ack_point = asoc->next_tsn - 1;\n\t\tasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\n\t\tif (!asoc->ssnmap) {\n\t\t\t/* Move the ssnmap. */\n\t\t\tasoc->ssnmap = new->ssnmap;\n\t\t\tnew->ssnmap = NULL;\n\t\t}\n\n\t\tif (!asoc->assoc_id) {\n\t\t\t/* get a new association id since we don't have one\n\t\t\t * yet.\n\t\t\t */\n\t\t\tsctp_assoc_set_id(asoc, GFP_ATOMIC);\n\t\t}\n\t}\n\n\t/* SCTP-AUTH: Save the peer parameters from the new associations\n\t * and also move the association shared keys over\n\t */\n\tkfree(asoc->peer.peer_random);\n\tasoc->peer.peer_random = new->peer.peer_random;\n\tnew->peer.peer_random = NULL;\n\n\tkfree(asoc->peer.peer_chunks);\n\tasoc->peer.peer_chunks = new->peer.peer_chunks;\n\tnew->peer.peer_chunks = NULL;\n\n\tkfree(asoc->peer.peer_hmacs);\n\tasoc->peer.peer_hmacs = new->peer.peer_hmacs;\n\tnew->peer.peer_hmacs = NULL;\n\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_auth_asoc_init_active_key(asoc, GFP_ATOMIC);\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2014-5077"
    },
    {
      "commit_id": "cb8a02af7a5677cf608e86d57ab04241cf34e24f",
      "filepath": "miniupnpd/pcpserver.c",
      "project": "miniupnp",
      "project_repo_path": "symbol_backend_projects/miniupnp",
      "is_vulnerable": false,
      "func_name": "copyIPv6IfDifferent",
      "func_body": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src && src != NULL) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}",
      "line_statements": [
        [
          180,
          "\tif(dest != src && src != NULL) {"
        ]
      ],
      "statements": [
        [
          180,
          "if(dest != src && src != NULL)"
        ]
      ],
      "cve": "CVE-2019-12111"
    },
    {
      "commit_id": "44f591aa8f7091e6ca6cb418e428ae6d4ceaf77d",
      "filepath": "mrbgems/mruby-compiler/core/codegen.c",
      "project": "mruby",
      "project_repo_path": "symbol_backend_projects/mruby",
      "is_vulnerable": false,
      "func_name": "codegen",
      "func_body": "codegen(codegen_scope *s, node *tree, int val)\n{\n  int nt;\n  int rlev = s->rlev;\n\n  if (!tree) {\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    return;\n  }\n\n  s->rlev++;\n  if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {\n    codegen_error(s, \"too complex expression\");\n  }\n  if (s->irep && s->filename_index != tree->filename_index) {\n    mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n    const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n\n    mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                               filename, s->lines, s->debug_start_pos, s->pc);\n    s->debug_start_pos = s->pc;\n    s->filename_index = tree->filename_index;\n    s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);\n  }\n\n  nt = nint(tree->car);\n  s->lineno = tree->lineno;\n  tree = tree->cdr;\n  switch (nt) {\n  case NODE_BEGIN:\n    if (val && !tree) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    while (tree) {\n      codegen(s, tree->car, tree->cdr ? NOVAL : val);\n      tree = tree->cdr;\n    }\n    break;\n\n  case NODE_RESCUE:\n    {\n      int noexc;\n      uint32_t exend, pos1, pos2, tmp;\n      struct loopinfo *lp;\n      int catch_entry, begin, end;\n\n      if (tree->car == NULL) goto exit;\n      lp = loop_push(s, LOOP_BEGIN);\n      lp->pc0 = new_label(s);\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, VAL);\n      pop();\n      lp->type = LOOP_RESCUE;\n      end = s->pc;\n      noexc = genjmp_0(s, OP_JMP);\n      catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n      tree = tree->cdr;\n      exend = JMPLINK_START;\n      pos1 = JMPLINK_START;\n      if (tree->car) {\n        node *n2 = tree->car;\n        int exc = cursp();\n\n        genop_1(s, OP_EXCEPT, exc);\n        push();\n        while (n2) {\n          node *n3 = n2->car;\n          node *n4 = n3->car;\n\n          dispatch(s, pos1);\n          pos2 = JMPLINK_START;\n          do {\n            if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {\n              codegen(s, n4->car, VAL);\n              gen_move(s, cursp(), exc, 0);\n              push_n(2); pop_n(2); /* space for one arg and a block */\n              pop();\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              if (n4) {\n                codegen(s, n4->car, VAL);\n              }\n              else {\n                genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));\n                push();\n              }\n              pop();\n              genop_2(s, OP_RESCUE, exc, cursp());\n            }\n            tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);\n            pos2 = tmp;\n            if (n4) {\n              n4 = n4->cdr;\n            }\n          } while (n4);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n\n          pop();\n          if (n3->cdr->car) {\n            gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);\n          }\n          if (n3->cdr->cdr->car) {\n            codegen(s, n3->cdr->cdr->car, val);\n            if (val) pop();\n          }\n          tmp = genjmp(s, OP_JMP, exend);\n          exend = tmp;\n          n2 = n2->cdr;\n          push();\n        }\n        if (pos1 != JMPLINK_START) {\n          dispatch(s, pos1);\n          genop_1(s, OP_RAISEIF, exc);\n        }\n      }\n      pop();\n      tree = tree->cdr;\n      dispatch(s, noexc);\n      if (tree->car) {\n        codegen(s, tree->car, val);\n      }\n      else if (val) {\n        push();\n      }\n      dispatch_linked(s, exend);\n      loop_pop(s, NOVAL);\n    }\n    break;\n\n  case NODE_ENSURE:\n    if (!tree->cdr || !tree->cdr->cdr ||\n        (nint(tree->cdr->cdr->car) == NODE_BEGIN &&\n         tree->cdr->cdr->cdr)) {\n      int catch_entry, begin, end, target;\n      int idx;\n\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, val);\n      end = target = s->pc;\n      push();\n      idx = cursp();\n      genop_1(s, OP_EXCEPT, idx);\n      push();\n      codegen(s, tree->cdr->cdr, NOVAL);\n      pop();\n      genop_1(s, OP_RAISEIF, idx);\n      pop();\n      catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);\n    }\n    else {                      /* empty ensure ignored */\n      codegen(s, tree->car, val);\n    }\n    break;\n\n  case NODE_LAMBDA:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_LAMBDA, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_BLOCK:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_BLOCK, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_IF:\n    {\n      uint32_t pos1, pos2;\n      mrb_bool nil_p = FALSE;\n      node *elsepart = tree->cdr->cdr->car;\n\n      if (!tree->car) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        mrb_sym mid = nsym(n->cdr->car);\n        mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);\n        if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {\n          nil_p = TRUE;\n          codegen(s, n->car, VAL);\n        }\n      }\n      if (!nil_p) {\n        codegen(s, tree->car, VAL);\n      }\n      pop();\n      if (val || tree->cdr->car) {\n        if (nil_p) {\n          pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos2);\n        }\n        else {\n          pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->car, val);\n        if (val) pop();\n        if (elsepart || val) {\n          pos2 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos1);\n          codegen(s, elsepart, val);\n          dispatch(s, pos2);\n        }\n        else {\n          dispatch(s, pos1);\n        }\n      }\n      else {                    /* empty then-part */\n        if (elsepart) {\n          if (nil_p) {\n            pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          }\n          else {\n            pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);\n          }\n          codegen(s, elsepart, val);\n          dispatch(s, pos1);\n        }\n        else if (val && !nil_p) {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n    }\n    break;\n\n  case NODE_AND:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_OR:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPIF, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_WHILE:\n  case NODE_UNTIL:\n    {\n      if (true_always(tree->car)) {\n        if (nt == NODE_UNTIL) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n      else if (false_always(tree->car)) {\n        if (nt == NODE_WHILE) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n\n      uint32_t pos = JMPLINK_START;\n      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);\n\n      if (!val) lp->reg = -1;\n      lp->pc0 = new_label(s);\n      codegen(s, tree->car, VAL);\n      pop();\n      if (nt == NODE_WHILE) {\n        pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);\n      }\n      else {\n        pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);\n      }\n      lp->pc1 = new_label(s);\n      codegen(s, tree->cdr, NOVAL);\n      genjmp(s, OP_JMP, lp->pc0);\n      dispatch(s, pos);\n      loop_pop(s, val);\n    }\n    break;\n\n  case NODE_FOR:\n    for_body(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_CASE:\n    {\n      int head = 0;\n      uint32_t pos1, pos2, pos3, tmp;\n      node *n;\n\n      pos3 = JMPLINK_START;\n      if (tree->car) {\n        head = cursp();\n        codegen(s, tree->car, VAL);\n      }\n      tree = tree->cdr;\n      while (tree) {\n        n = tree->car->car;\n        pos1 = pos2 = JMPLINK_START;\n        while (n) {\n          codegen(s, n->car, VAL);\n          if (head) {\n            gen_move(s, cursp(), head, 0);\n            push(); push(); pop(); pop(); pop();\n            if (nint(n->car->car) == NODE_SPLAT) {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);\n            }\n          }\n          else {\n            pop();\n          }\n          tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);\n          pos2 = tmp;\n          n = n->cdr;\n        }\n        if (tree->car->car) {\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n        }\n        codegen(s, tree->car->cdr, val);\n        if (val) pop();\n        tmp = genjmp(s, OP_JMP, pos3);\n        pos3 = tmp;\n        dispatch(s, pos1);\n        tree = tree->cdr;\n      }\n      if (val) {\n        uint32_t pos = cursp();\n        genop_1(s, OP_LOADNIL, cursp());\n        if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);\n        if (head) pop();\n        if (cursp() != pos) {\n          gen_move(s, cursp(), pos, 0);\n        }\n        push();\n      }\n      else {\n        if (pos3 != JMPLINK_START) {\n          dispatch_linked(s, pos3);\n        }\n        if (head) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_SCOPE:\n    scope_body(s, tree, NOVAL);\n    break;\n\n  case NODE_FCALL:\n  case NODE_CALL:\n    gen_call(s, tree, val, 0);\n    break;\n  case NODE_SCALL:\n    gen_call(s, tree, val, 1);\n    break;\n\n  case NODE_DOT2:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_INC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_DOT3:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_EXC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_COLON2:\n    {\n      int sym = new_sym(s, nsym(tree->cdr));\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_COLON3:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ARRAY:\n    {\n      int n;\n\n      n = gen_values(s, tree, val, 0);\n      if (val) {\n        if (n >= 0) {\n          pop_n(n);\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n      }\n    }\n    break;\n\n  case NODE_HASH:\n  case NODE_KW_HASH:\n    {\n      int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);\n      if (val && nk >= 0) {\n        pop_n(nk*2);\n        genop_2(s, OP_HASH, cursp(), nk);\n        push();\n      }\n    }\n    break;\n\n  case NODE_SPLAT:\n    codegen(s, tree, val);\n    break;\n\n  case NODE_ASGN:\n    gen_assignment(s, tree->car, tree->cdr, 0, val);\n    break;\n\n  case NODE_MASGN:\n    {\n      int len = 0, n = 0, post = 0;\n      node *t = tree->cdr, *p;\n      int rhs = cursp();\n\n      if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {\n        /* fixed rhs */\n        t = t->cdr;\n        while (t) {\n          codegen(s, t->car, VAL);\n          len++;\n          t = t->cdr;\n        }\n        tree = tree->car;\n        if (tree->car) {                /* pre */\n          t = tree->car;\n          n = 0;\n          while (t) {\n            if (n < len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              n++;\n            }\n            else {\n              genop_1(s, OP_LOADNIL, rhs+n);\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n            }\n            t = t->cdr;\n          }\n        }\n        t = tree->cdr;\n        if (t) {\n          if (t->cdr) {         /* post count */\n            p = t->cdr->car;\n            while (p) {\n              post++;\n              p = p->cdr;\n            }\n          }\n          if (t->car) {         /* rest (len - pre - post) */\n            int rn;\n\n            if (len < post + n) {\n              rn = 0;\n            }\n            else {\n              rn = len - post - n;\n            }\n            genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);\n            gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n            n += rn;\n          }\n          if (t->cdr && t->cdr->car) {\n            t = t->cdr->car;\n            while (n<len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              t = t->cdr;\n              n++;\n            }\n          }\n        }\n        pop_n(len);\n        if (val) {\n          genop_2(s, OP_ARRAY, rhs, len);\n          push();\n        }\n      }\n      else {\n        /* variable rhs */\n        codegen(s, t, VAL);\n        gen_vmassignment(s, tree->car, rhs, val);\n        if (!val) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_OP_ASGN:\n    {\n      mrb_sym sym = nsym(tree->cdr->car);\n      mrb_int len;\n      const char *name = mrb_sym_name_len(s->mrb, sym, &len);\n      int idx, callargs = -1, vsp = -1;\n\n      if ((len == 2 && name[0] == '|' && name[1] == '|') &&\n          (nint(tree->car->car) == NODE_CONST ||\n           nint(tree->car->car) == NODE_CVAR)) {\n        int catch_entry, begin, end;\n        int noexc, exc;\n        struct loopinfo *lp;\n\n        lp = loop_push(s, LOOP_BEGIN);\n        lp->pc0 = new_label(s);\n        catch_entry = catch_handler_new(s);\n        begin = s->pc;\n        exc = cursp();\n        codegen(s, tree->car, VAL);\n        end = s->pc;\n        noexc = genjmp_0(s, OP_JMP);\n        lp->type = LOOP_RESCUE;\n        catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n        genop_1(s, OP_EXCEPT, exc);\n        genop_1(s, OP_LOADF, exc);\n        dispatch(s, noexc);\n        loop_pop(s, NOVAL);\n      }\n      else if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        int base, i, nargs = 0;\n        callargs = 0;\n\n        if (val) {\n          vsp = cursp();\n          push();\n        }\n        codegen(s, n->car, VAL);   /* receiver */\n        idx = new_sym(s, nsym(n->cdr->car));\n        base = cursp()-1;\n        if (n->cdr->cdr->car) {\n          nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);\n          if (nargs >= 0) {\n            callargs = nargs;\n          }\n          else { /* varargs */\n            push();\n            nargs = 1;\n            callargs = CALL_MAXARGS;\n          }\n        }\n        /* copy receiver and arguments */\n        gen_move(s, cursp(), base, 1);\n        for (i=0; i<nargs; i++) {\n          gen_move(s, cursp()+i+1, base+i+1, 1);\n        }\n        push_n(nargs+2);pop_n(nargs+2); /* space for receiver, arguments and a block */\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL);\n      }\n      if (len == 2 &&\n          ((name[0] == '|' && name[1] == '|') ||\n           (name[0] == '&' && name[1] == '&'))) {\n        uint32_t pos;\n\n        pop();\n        if (val) {\n          if (vsp >= 0) {\n            gen_move(s, vsp, cursp(), 1);\n          }\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        else {\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->cdr->car, VAL);\n        pop();\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 1);\n        }\n        if (nint(tree->car->car) == NODE_CALL) {\n          if (callargs == CALL_MAXARGS) {\n            pop();\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          else {\n            pop_n(callargs);\n            callargs++;\n          }\n          pop();\n          idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));\n          genop_3(s, OP_SEND, cursp(), idx, callargs);\n        }\n        else {\n          gen_assignment(s, tree->car, NULL, cursp(), val);\n        }\n        dispatch(s, pos);\n        goto exit;\n      }\n      codegen(s, tree->cdr->cdr->car, VAL);\n      push(); pop();\n      pop(); pop();\n\n      if (len == 1 && name[0] == '+')  {\n        gen_addsub(s, OP_ADD, cursp());\n      }\n      else if (len == 1 && name[0] == '-')  {\n        gen_addsub(s, OP_SUB, cursp());\n      }\n      else if (len == 1 && name[0] == '*')  {\n        genop_1(s, OP_MUL, cursp());\n      }\n      else if (len == 1 && name[0] == '/')  {\n        genop_1(s, OP_DIV, cursp());\n      }\n      else if (len == 1 && name[0] == '<')  {\n        genop_1(s, OP_LT, cursp());\n      }\n      else if (len == 2 && name[0] == '<' && name[1] == '=')  {\n        genop_1(s, OP_LE, cursp());\n      }\n      else if (len == 1 && name[0] == '>')  {\n        genop_1(s, OP_GT, cursp());\n      }\n      else if (len == 2 && name[0] == '>' && name[1] == '=')  {\n        genop_1(s, OP_GE, cursp());\n      }\n      else {\n        idx = new_sym(s, sym);\n        genop_3(s, OP_SEND, cursp(), idx, 1);\n      }\n      if (callargs < 0) {\n        gen_assignment(s, tree->car, NULL, cursp(), val);\n      }\n      else {\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 0);\n        }\n        if (callargs == CALL_MAXARGS) {\n          pop();\n          genop_2(s, OP_ARYPUSH, cursp(), 1);\n        }\n        else {\n          pop_n(callargs);\n          callargs++;\n        }\n        pop();\n        idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n      }\n    }\n    break;\n\n  case NODE_SUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      int n = 0, nk = 0, st = 0;\n\n      push();\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (tree) {\n        node *args = tree->car;\n        if (args) {\n          st = n = gen_values(s, args, VAL, 14);\n          if (n < 0) {\n            st = 1; n = 15;\n            push();\n          }\n        }\n        /* keyword arguments */\n        if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {\n          nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n          if (nk < 0) {st++; nk = 15;}\n          else st += nk*2;\n          n |= nk<<4;\n        }\n        /* block arguments */\n        if (tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      else {\n        if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      st++;\n      pop_n(st+1);\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ZSUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      uint16_t ainfo = 0;\n      int n = CALL_MAXARGS;\n      int sp = cursp();\n\n      push();        /* room for receiver */\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2 && s2->ainfo > 0) {\n        ainfo = s2->ainfo;\n      }\n      if (ainfo > 0) {\n        genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));\n        push(); push(); push();   /* ARGARY pushes 3 values at most */\n        pop(); pop(); pop();\n        /* keyword arguments */\n        if (ainfo & 0x1) {\n          n |= CALL_MAXARGS<<4;\n          push();\n        }\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          push();\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n      }\n      else {\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else {\n          gen_blkmove(s, 0, lv);\n        }\n        n = 0;\n      }\n      s->sp = sp;\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_RETURN:\n    if (tree) {\n      gen_retval(s, tree);\n    }\n    else {\n      genop_1(s, OP_LOADNIL, cursp());\n    }\n    if (s->loop) {\n      gen_return(s, OP_RETURN_BLK, cursp());\n    }\n    else {\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_YIELD:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0, ainfo = -1;\n      int n = 0, sendv = 0;\n\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2) {\n        ainfo = (int)s2->ainfo;\n      }\n      if (ainfo < 0) codegen_error(s, \"invalid yield (SyntaxError)\");\n      push();\n      if (tree) {\n        n = gen_values(s, tree, VAL, 14);\n        if (n < 0) {\n          n = sendv = 1;\n          push();\n        }\n      }\n      push();pop(); /* space for a block */\n      pop_n(n+1);\n      genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));\n      if (sendv) n = CALL_MAXARGS;\n      genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BREAK:\n    loop_break(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_NEXT:\n    if (!s->loop) {\n      raise_error(s, \"unexpected next\");\n    }\n    else if (s->loop->type == LOOP_NORMAL) {\n      codegen(s, tree, NOVAL);\n      genjmp(s, OP_JMPUW, s->loop->pc0);\n    }\n    else {\n      if (tree) {\n        codegen(s, tree, VAL);\n        pop();\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_REDO:\n    if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {\n      raise_error(s, \"unexpected redo\");\n    }\n    else {\n      genjmp(s, OP_JMPUW, s->loop->pc1);\n    }\n    if (val) push();\n    break;\n\n  case NODE_RETRY:\n    {\n      const char *msg = \"unexpected retry\";\n      const struct loopinfo *lp = s->loop;\n\n      while (lp && lp->type != LOOP_RESCUE) {\n        lp = lp->prev;\n      }\n      if (!lp) {\n        raise_error(s, msg);\n      }\n      else {\n        genjmp(s, OP_JMPUW, lp->pc0);\n      }\n      if (val) push();\n    }\n    break;\n\n  case NODE_LVAR:\n    if (val) {\n      int idx = lv_idx(s, nsym(tree));\n\n      if (idx > 0) {\n        gen_move(s, cursp(), idx, val);\n      }\n      else {\n        gen_getupvar(s, cursp(), nsym(tree));\n      }\n      push();\n    }\n    break;\n\n  case NODE_NVAR:\n    if (val) {\n      int idx = nint(tree);\n\n      gen_move(s, cursp(), idx, val);\n\n      push();\n    }\n    break;\n\n  case NODE_GVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_IVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETIV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CONST:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCONST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BACK_REF:\n    if (val) {\n      char buf[] = {'$', nchar(tree)};\n      int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_NTH_REF:\n    if (val) {\n      mrb_state *mrb = s->mrb;\n      mrb_value str;\n      int sym;\n\n      str = mrb_format(mrb, \"$%d\", nint(tree));\n      sym = new_sym(s, mrb_intern_str(mrb, str));\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_ARG:\n    /* should not happen */\n    break;\n\n  case NODE_BLOCK_ARG:\n    if (!tree) {\n      int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));\n\n      if (idx == 0) {\n        codegen_error(s, \"no anonymous block argument\");\n      }\n      gen_move(s, cursp(), idx, val);\n      if (val) push();\n    }\n    else {\n      codegen(s, tree, val);\n    }\n    break;\n\n  case NODE_INT:\n    if (val) {\n      char *p = (char*)tree->car;\n      int base = nint(tree->cdr->car);\n      mrb_int i;\n      mrb_bool overflow;\n\n      i = readint(s, p, base, FALSE, &overflow);\n      if (overflow) {\n        int off = new_litbn(s, p, base, FALSE);\n        genop_2(s, OP_LOADL, cursp(), off);\n      }\n      else {\n        gen_int(s, cursp(), i);\n      }\n      push();\n    }\n    break;\n\n#ifndef MRB_NO_FLOAT\n  case NODE_FLOAT:\n    if (val) {\n      char *p = (char*)tree;\n      mrb_float f = mrb_float_read(p, NULL);\n      int off = new_lit(s, mrb_float_value(s->mrb, f));\n\n      genop_2(s, OP_LOADL, cursp(), off);\n      push();\n    }\n    break;\n#endif\n\n  case NODE_NEGATE:\n    {\n      nt = nint(tree->car);\n      switch (nt) {\n#ifndef MRB_NO_FLOAT\n      case NODE_FLOAT:\n        if (val) {\n          char *p = (char*)tree->cdr;\n          mrb_float f = mrb_float_read(p, NULL);\n          int off = new_lit(s, mrb_float_value(s->mrb, -f));\n\n          genop_2(s, OP_LOADL, cursp(), off);\n          push();\n        }\n        break;\n#endif\n\n      case NODE_INT:\n        if (val) {\n          char *p = (char*)tree->cdr->car;\n          int base = nint(tree->cdr->cdr->car);\n          mrb_int i;\n          mrb_bool overflow;\n\n          i = readint(s, p, base, TRUE, &overflow);\n          if (overflow) {\n            int off = new_litbn(s, p, base, TRUE);\n            genop_2(s, OP_LOADL, cursp(), off);\n          }\n          else {\n            gen_int(s, cursp(), i);\n          }\n          push();\n        }\n        break;\n\n      default:\n        if (val) {\n          codegen(s, tree, VAL);\n          pop();\n          push_n(2);pop_n(2); /* space for receiver&block */\n          mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);\n          if (!gen_uniop(s, minus, cursp())) {\n            genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);\n          }\n          push();\n        }\n        else {\n          codegen(s, tree, NOVAL);\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_STR:\n    if (val) {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n\n      mrb_gc_arena_restore(s->mrb, ai);\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n    }\n    break;\n\n  case NODE_HEREDOC:\n    tree = ((struct mrb_parser_heredoc_info *)tree)->doc;\n    /* fall through */\n  case NODE_DSTR:\n    if (val) {\n      node *n = tree;\n\n      if (!n) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n        break;\n      }\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n    }\n    else {\n      node *n = tree;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_WORDS:\n    gen_literal_array(s, tree, FALSE, val);\n    break;\n\n  case NODE_SYMBOLS:\n    gen_literal_array(s, tree, TRUE, val);\n    break;\n\n  case NODE_DXSTR:\n    {\n      node *n;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      codegen(s, tree->car, VAL);\n      n = tree->cdr;\n      while (n) {\n        if (nint(n->car->car) == NODE_XSTR) {\n          n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;\n          mrb_assert(!n->cdr); /* must be the end */\n        }\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      push();                   /* for block */\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_XSTR:\n    {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n      int sym;\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push(); push();\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_REGX:\n    if (val) {\n      char *p1 = (char*)tree->car;\n      char *p2 = (char*)tree->cdr->car;\n      char *p3 = (char*)tree->cdr->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));\n      int argc = 1;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n      if (p2 || p3) {\n        if (p2) { /* opt */\n          off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n          genop_2(s, OP_STRING, cursp(), off);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        push();\n        argc++;\n        if (p3) { /* enc */\n          off = new_lit(s, mrb_str_new(s->mrb, p3, 1));\n          genop_2(s, OP_STRING, cursp(), off);\n          push();\n          argc++;\n        }\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    break;\n\n  case NODE_DREGX:\n    if (val) {\n      node *n = tree->car;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int argc = 1;\n      int off;\n      char *p;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      n = tree->cdr->cdr;\n      if (n->car) { /* tail */\n        p = (char*)n->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p));\n        codegen(s, tree->car, VAL);\n        genop_2(s, OP_STRING, cursp(), off);\n        pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n      }\n      if (n->cdr->car) { /* opt */\n        char *p2 = (char*)n->cdr->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      if (n->cdr->cdr) { /* enc */\n        char *p2 = (char*)n->cdr->cdr;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    else {\n      node *n = tree->car;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_SYM:\n    if (val) {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_LOADSYM, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_DSYM:\n    codegen(s, tree, val);\n    if (val) {\n      gen_intern(s);\n    }\n    break;\n\n  case NODE_SELF:\n    if (val) {\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_NIL:\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    break;\n\n  case NODE_TRUE:\n    if (val) {\n      genop_1(s, OP_LOADT, cursp());\n      push();\n    }\n    break;\n\n  case NODE_FALSE:\n    if (val) {\n      genop_1(s, OP_LOADF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_ALIAS:\n    {\n      int a = new_sym(s, nsym(tree->car));\n      int b = new_sym(s, nsym(tree->cdr));\n\n      genop_2(s, OP_ALIAS, a, b);\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n   break;\n\n  case NODE_UNDEF:\n    {\n      node *t = tree;\n\n      while (t) {\n        int symbol = new_sym(s, nsym(t->car));\n        genop_1(s, OP_UNDEF, symbol);\n        t = t->cdr;\n      }\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n    break;\n\n  case NODE_CLASS:\n    {\n      int idx;\n      node *body;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      if (tree->cdr->car) {\n        codegen(s, tree->cdr->car, VAL);\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      pop(); pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_CLASS, cursp(), idx);\n      body = tree->cdr->cdr->car;\n      if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, body, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_MODULE:\n    {\n      int idx;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_MODULE, cursp(), idx);\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_SCLASS:\n    {\n      int idx;\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_DEF:\n    {\n      int sym = new_sym(s, nsym(tree->car));\n      int idx = lambda_body(s, tree->cdr, 0);\n\n      genop_1(s, OP_TCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      push(); pop();\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_SDEF:\n    {\n      node *recv = tree->car;\n      int sym = new_sym(s, nsym(tree->cdr->car));\n      int idx = lambda_body(s, tree->cdr->cdr, 0);\n\n      codegen(s, recv, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_POSTEXE:\n    codegen(s, tree, NOVAL);\n    break;\n\n  default:\n    break;\n  }\n exit:\n  s->rlev = rlev;\n}",
      "line_statements": [
        [
          2957,
          "        else if (s2) gen_blkmove(s, s2->ainfo, lv);"
        ],
        [
          2959,
          "          genop_1(s, OP_LOADNIL, cursp());"
        ],
        [
          2960,
          "          push();"
        ],
        [
          2964,
          "        if (s2) gen_blkmove(s, s2->ainfo, lv);"
        ],
        [
          2965,
          "        else {"
        ],
        [
          2966,
          "          genop_1(s, OP_LOADNIL, cursp());"
        ],
        [
          2967,
          "          push();"
        ],
        [
          2968,
          "        }"
        ],
        [
          2970,
          "      st++;"
        ],
        [
          3222,
          "      if (val) push();"
        ]
      ],
      "statements": [
        [
          2957,
          "else if (s2)"
        ],
        [
          2959,
          "genop_1(s, OP_LOADNIL, cursp());"
        ],
        [
          2960,
          "push();"
        ],
        [
          2964,
          "if (s2)"
        ],
        [
          2965,
          "else"
        ],
        [
          2966,
          "genop_1(s, OP_LOADNIL, cursp());"
        ],
        [
          2967,
          "push();"
        ],
        [
          2968,
          "        }\n"
        ],
        [
          2970,
          "st++;"
        ],
        [
          3222,
          "if (val)"
        ]
      ],
      "cve": "CVE-2022-0632"
    },
    {
      "commit_id": "5524fa301ba649f8cf00848f91468e0ba7e4f24c",
      "filepath": "drivers/gpu/drm/amd/display/dc/link/protocols/link_dpcd.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "dpcd_extend_address_range",
      "func_body": "static void dpcd_extend_address_range(\n\t\tconst uint32_t in_address,\n\t\tuint8_t * const in_data,\n\t\tconst uint32_t in_size,\n\t\tuint32_t *out_address,\n\t\tuint8_t **out_data,\n\t\tuint32_t *out_size)\n{\n\tconst uint32_t end_address = END_ADDRESS(in_address, in_size);\n\tconst struct dpcd_address_range *addr_range;\n\tstruct dpcd_address_range new_addr_range;\n\tuint32_t i;\n\n\tnew_addr_range.start = in_address;\n\tnew_addr_range.end = end_address;\n\tfor (i = 0; i < ARRAY_SIZE(mandatory_dpcd_blocks); i++) {\n\t\taddr_range = &mandatory_dpcd_blocks[i];\n\t\tif (addr_range->start <= in_address && addr_range->end >= in_address)\n\t\t\tnew_addr_range.start = addr_range->start;\n\n\t\tif (addr_range->start <= end_address && addr_range->end >= end_address)\n\t\t\tnew_addr_range.end = addr_range->end;\n\t}\n\t*out_address = in_address;\n\t*out_size = in_size;\n\t*out_data = in_data;\n\tif (new_addr_range.start != in_address || new_addr_range.end != end_address) {\n\t\t*out_address = new_addr_range.start;\n\t\t*out_size = ADDRESS_RANGE_SIZE(new_addr_range.start, new_addr_range.end);\n\t\t*out_data = kcalloc(*out_size, sizeof(**out_data), GFP_KERNEL);\n\t\tASSERT(*out_data);\n\t}\n}\n",
      "line_statements": [
        [
          168,
          "\t\tASSERT(*out_data);\n"
        ]
      ],
      "statements": [
        [
          168,
          "ASSERT(*out_data);"
        ]
      ],
      "cve": "CVE-2024-46808"
    },
    {
      "commit_id": "efa56305908ba20de2104f1b8508c6a7401833be",
      "filepath": "drivers/nvme/target/tcp.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "nvmet_tcp_handle_icreq",
      "func_body": "static int nvmet_tcp_handle_icreq(struct nvmet_tcp_queue *queue)\n{\n\tstruct nvme_tcp_icreq_pdu *icreq = &queue->pdu.icreq;\n\tstruct nvme_tcp_icresp_pdu *icresp = &queue->pdu.icresp;\n\tstruct msghdr msg = {};\n\tstruct kvec iov;\n\tint ret;\n\n\tif (le32_to_cpu(icreq->hdr.plen) != sizeof(struct nvme_tcp_icreq_pdu)) {\n\t\tpr_err(\"bad nvme-tcp pdu length (%d)\\n\",\n\t\t\tle32_to_cpu(icreq->hdr.plen));\n\t\tnvmet_tcp_fatal_error(queue);\n\t}\n\n\tif (icreq->pfv != NVME_TCP_PFV_1_0) {\n\t\tpr_err(\"queue %d: bad pfv %d\\n\", queue->idx, icreq->pfv);\n\t\treturn -EPROTO;\n\t}\n\n\tif (icreq->hpda != 0) {\n\t\tpr_err(\"queue %d: unsupported hpda %d\\n\", queue->idx,\n\t\t\ticreq->hpda);\n\t\treturn -EPROTO;\n\t}\n\n\tqueue->hdr_digest = !!(icreq->digest & NVME_TCP_HDR_DIGEST_ENABLE);\n\tqueue->data_digest = !!(icreq->digest & NVME_TCP_DATA_DIGEST_ENABLE);\n\tif (queue->hdr_digest || queue->data_digest) {\n\t\tret = nvmet_tcp_alloc_crypto(queue);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmemset(icresp, 0, sizeof(*icresp));\n\ticresp->hdr.type = nvme_tcp_icresp;\n\ticresp->hdr.hlen = sizeof(*icresp);\n\ticresp->hdr.pdo = 0;\n\ticresp->hdr.plen = cpu_to_le32(icresp->hdr.hlen);\n\ticresp->pfv = cpu_to_le16(NVME_TCP_PFV_1_0);\n\ticresp->maxdata = cpu_to_le32(NVMET_TCP_MAXH2CDATA);\n\ticresp->cpda = 0;\n\tif (queue->hdr_digest)\n\t\ticresp->digest |= NVME_TCP_HDR_DIGEST_ENABLE;\n\tif (queue->data_digest)\n\t\ticresp->digest |= NVME_TCP_DATA_DIGEST_ENABLE;\n\n\tiov.iov_base = icresp;\n\tiov.iov_len = sizeof(*icresp);\n\tret = kernel_sendmsg(queue->sock, &msg, &iov, 1, iov.iov_len);\n\tif (ret < 0) {\n\t\tqueue->state = NVMET_TCP_Q_FAILED;\n\t\treturn ret; /* queue removal will cleanup */\n\t}\n\n\tqueue->state = NVMET_TCP_Q_LIVE;\n\tnvmet_prepare_receive_pdu(queue);\n\treturn 0;\n}\n",
      "line_statements": [
        [
          927,
          "\ticresp->maxdata = cpu_to_le32(NVMET_TCP_MAXH2CDATA);\n"
        ]
      ],
      "statements": [
        [
          927,
          "icresp->maxdata = cpu_to_le32(NVMET_TCP_MAXH2CDATA);"
        ]
      ],
      "cve": "CVE-2023-52454"
    },
    {
      "commit_id": "37307f7020ab38dde0892a578249bf63d00bca64",
      "filepath": "drivers/usb/cdns3/cdnsp-mem.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "cdnsp_endpoint_init",
      "func_body": "int cdnsp_endpoint_init(struct cdnsp_device *pdev,\n\t\t\tstruct cdnsp_ep *pep,\n\t\t\tgfp_t mem_flags)\n{\n\tenum cdnsp_ring_type ring_type;\n\tstruct cdnsp_ep_ctx *ep_ctx;\n\tunsigned int err_count = 0;\n\tunsigned int avg_trb_len;\n\tunsigned int max_packet;\n\tunsigned int max_burst;\n\tunsigned int interval;\n\tu32 max_esit_payload;\n\tunsigned int mult;\n\tu32 endpoint_type;\n\tint ret;\n\n\tep_ctx = pep->in_ctx;\n\n\tendpoint_type = cdnsp_get_endpoint_type(pep->endpoint.desc);\n\tif (!endpoint_type)\n\t\treturn -EINVAL;\n\n\tring_type = usb_endpoint_type(pep->endpoint.desc);\n\n\t/*\n\t * Get values to fill the endpoint context, mostly from ep descriptor.\n\t * The average TRB buffer length for bulk endpoints is unclear as we\n\t * have no clue on scatter gather list entry size. For Isoc and Int,\n\t * set it to max available.\n\t */\n\tmax_esit_payload = cdnsp_get_max_esit_payload(&pdev->gadget, pep);\n\tinterval = cdnsp_get_endpoint_interval(&pdev->gadget, pep);\n\tmult = cdnsp_get_endpoint_mult(&pdev->gadget, pep);\n\tmax_packet = usb_endpoint_maxp(pep->endpoint.desc);\n\tmax_burst = cdnsp_get_endpoint_max_burst(&pdev->gadget, pep);\n\tavg_trb_len = max_esit_payload;\n\n\t/* Allow 3 retries for everything but isoc, set CErr = 3. */\n\tif (!usb_endpoint_xfer_isoc(pep->endpoint.desc))\n\t\terr_count = 3;\n\tif (usb_endpoint_xfer_bulk(pep->endpoint.desc) &&\n\t    pdev->gadget.speed == USB_SPEED_HIGH)\n\t\tmax_packet = 512;\n\t/* Controller spec indicates that ctrl ep avg TRB Length should be 8. */\n\tif (usb_endpoint_xfer_control(pep->endpoint.desc))\n\t\tavg_trb_len = 8;\n\n\t/* Set up the endpoint ring. */\n\tpep->ring = cdnsp_ring_alloc(pdev, 2, ring_type, max_packet, mem_flags);\n\tif (!pep->ring)\n\t\treturn -ENOMEM;\n\n\tpep->skip = false;\n\n\t/* Fill the endpoint context */\n\tep_ctx->ep_info = cpu_to_le32(EP_MAX_ESIT_PAYLOAD_HI(max_esit_payload) |\n\t\t\t\tEP_INTERVAL(interval) | EP_MULT(mult));\n\tep_ctx->ep_info2 = cpu_to_le32(EP_TYPE(endpoint_type) |\n\t\t\t\tMAX_PACKET(max_packet) | MAX_BURST(max_burst) |\n\t\t\t\tERROR_COUNT(err_count));\n\tep_ctx->deq = cpu_to_le64(pep->ring->first_seg->dma |\n\t\t\t\t  pep->ring->cycle_state);\n\n\tep_ctx->tx_info = cpu_to_le32(EP_MAX_ESIT_PAYLOAD_LO(max_esit_payload) |\n\t\t\t\tEP_AVG_TRB_LENGTH(avg_trb_len));\n\n\tif (usb_endpoint_xfer_bulk(pep->endpoint.desc) &&\n\t    pdev->gadget.speed > USB_SPEED_HIGH) {\n\t\tret = cdnsp_alloc_streams(pdev, pep);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
      "line_statements": [
        [
          990,
          "\tif (!pep->ring)\n"
        ],
        [
          991,
          "\t\treturn -ENOMEM;\n"
        ],
        [
          992,
          "\n"
        ]
      ],
      "statements": [
        [
          990,
          "if (!pep->ring)"
        ],
        [
          991,
          "return -ENOMEM;"
        ],
        [
          992,
          "\n"
        ]
      ],
      "cve": "CVE-2021-47528"
    }
  ],
  "CWE-125": [
    {
      "commit_id": "a63d01854987d9fd846cdc9265af38ee9eb72490",
      "filepath": "src/drachtio.cpp",
      "project": "drachtio-server",
      "project_repo_path": "symbol_backend_projects/drachtio-server",
      "is_vulnerable": true,
      "func_name": "drachtio::normalizeSipUri",
      "func_body": "    bool normalizeSipUri( std::string& uri, int brackets ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n\n        // buf gets passed into sip_name_addr_d which puts NULs in various locations so the url_t members can point to their bits\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n\n        // first we decode the string\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            // no go: if we can't decode it then we have an invalid input\n            return false ;\n        }\n\n        /* we allow applications to just give us a phone number sometimes, and that ends up parsed into the host portion with no scheme */\n        if( NULL == url->url_scheme && NULL == url->url_user && NULL != url->url_host ) {\n            url->url_scheme = \"sip\" ;\n            url->url_user = url->url_host ;\n            url->url_host = \"localhost\" ;   //placeholder\n         }\n\n        // now we re-encode it\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, brackets, url, params, comment) ;\n\n        // cleanup: free the msg_params if any were allocated        \n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }",
      "line_statements": [
        [
          339,
          "        char buf[255];"
        ],
        [
          340,
          "        char obuf[255] ;"
        ],
        [
          349,
          "        s = strncpy( buf, uri.c_str(), 255 ) ;"
        ],
        [
          377,
          "        return true ;"
        ]
      ],
      "statements": [
        [
          339,
          "char buf[255];"
        ],
        [
          340,
          "char obuf[255] ;"
        ],
        [
          349,
          "s = strncpy( buf, uri.c_str(), 255 ) ;"
        ],
        [
          377,
          "return true ;"
        ]
      ],
      "cve": "CVE-2022-45909"
    },
    {
      "commit_id": "f50940531dd57135fe60aa393ac9d3281f352d88",
      "filepath": "src/regexp.c",
      "project": "vim",
      "project_repo_path": "symbol_backend_projects/vim",
      "is_vulnerable": false,
      "func_name": "cstrchr",
      "func_body": "cstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    // tolower() and toupper() can be slow, comparing twice should be a lot\n    // faster (esp. when using MS Visual C++!).\n    // For UTF-8 need to use folded case.\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tint uc = utf_ptr2char(p);\n\n\t\t// Do not match an illegal byte.  E.g. 0xff matches 0xc3 0xbf,\n\t\t// not 0xff.\n\t\tif ((uc < 0x80 || uc != *p) && utf_fold(uc) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\t// Faster version for when there are no multi-byte characters.\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}",
      "line_statements": [
        [
          1644,
          "\t\tint uc = utf_ptr2char(p);"
        ],
        [
          1645,
          ""
        ],
        [
          1648,
          "\t\tif ((uc < 0x80 || uc != *p) && utf_fold(uc) == cc)"
        ]
      ],
      "statements": [
        [
          1644,
          "int uc = utf_ptr2char(p);"
        ],
        [
          1645,
          "\n"
        ],
        [
          1648,
          "if ((uc < 0x80 || uc != *p) && utf_fold(uc) == cc)"
        ]
      ],
      "cve": "CVE-2022-2581"
    },
    {
      "commit_id": "c8c083cb750606b2da81582cd8e43b442bb143e6",
      "filepath": "mrbgems/mruby-compiler/core/codegen.c",
      "project": "mruby",
      "project_repo_path": "symbol_backend_projects/mruby",
      "is_vulnerable": false,
      "func_name": "gen_assignment",
      "func_body": "gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 13 || n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_massignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}",
      "line_statements": [
        [
          1908,
          "          if (n == 13 || n == 14) {"
        ]
      ],
      "statements": [
        [
          1908,
          "if (n == 13 || n == 14)"
        ]
      ],
      "cve": "CVE-2022-1276"
    },
    {
      "commit_id": "bf911e985d6bbaa328c20c3e05f4eb03de11fdd6",
      "filepath": "net/sctp/sm_statefuns.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "sctp_sf_ootb",
      "func_body": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\t/* Report violation if the chunk is less then minimal */\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\t/* Now that we know we at least have a chunk header,\n\t\t * do things that are type appropriate.\n\t\t */\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\n\t\t/* RFC 2960, Section 3.3.7\n\t\t *   Moreover, under any circumstances, an endpoint that\n\t\t *   receives an ABORT  MUST NOT respond to that ABORT by\n\t\t *   sending an ABORT of its own.\n\t\t */\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* RFC 8.4, 7) If the packet contains a \"Stale cookie\" ERROR\n\t\t * or a COOKIE ACK the SCTP Packet should be silently\n\t\t * discarded.\n\t\t */\n\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}\n",
      "line_statements": [
        [
          3425,
          "\t\t/* Report violation if chunk len overflows */\n"
        ],
        [
          3426,
          "\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n"
        ],
        [
          3427,
          "\t\tif (ch_end > skb_tail_pointer(skb))\n"
        ],
        [
          3428,
          "\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n"
        ],
        [
          3429,
          "\t\t\t\t\t\t  commands);\n"
        ],
        [
          3430,
          "\n"
        ]
      ],
      "statements": [
        [
          3425,
          "/* Report violation if chunk len overflows */"
        ],
        [
          3426,
          "ch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));"
        ],
        [
          3427,
          "if (ch_end > skb_tail_pointer(skb))"
        ],
        [
          3428,
          "return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);"
        ],
        [
          3430,
          "\n"
        ]
      ],
      "cve": "CVE-2016-9555"
    },
    {
      "commit_id": "7e78c597c3ebfd0cb329aa09a838734147e4f117",
      "filepath": "net/qrtr/qrtr.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "qrtr_endpoint_post",
      "func_body": "int qrtr_endpoint_post(struct qrtr_endpoint *ep, const void *data, size_t len)\n{\n\tstruct qrtr_node *node = ep->node;\n\tconst struct qrtr_hdr_v1 *v1;\n\tconst struct qrtr_hdr_v2 *v2;\n\tstruct qrtr_sock *ipc;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tsize_t size;\n\tunsigned int ver;\n\tsize_t hdrlen;\n\n\tif (len == 0 || len & 3)\n\t\treturn -EINVAL;\n\n\tskb = __netdev_alloc_skb(NULL, len, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcb = (struct qrtr_cb *)skb->cb;\n\n\t/* Version field in v1 is little endian, so this works for both cases */\n\tver = *(u8*)data;\n\n\tswitch (ver) {\n\tcase QRTR_PROTO_VER_1:\n\t\tif (len < sizeof(*v1))\n\t\t\tgoto err;\n\t\tv1 = data;\n\t\thdrlen = sizeof(*v1);\n\n\t\tcb->type = le32_to_cpu(v1->type);\n\t\tcb->src_node = le32_to_cpu(v1->src_node_id);\n\t\tcb->src_port = le32_to_cpu(v1->src_port_id);\n\t\tcb->confirm_rx = !!v1->confirm_rx;\n\t\tcb->dst_node = le32_to_cpu(v1->dst_node_id);\n\t\tcb->dst_port = le32_to_cpu(v1->dst_port_id);\n\n\t\tsize = le32_to_cpu(v1->size);\n\t\tbreak;\n\tcase QRTR_PROTO_VER_2:\n\t\tif (len < sizeof(*v2))\n\t\t\tgoto err;\n\t\tv2 = data;\n\t\thdrlen = sizeof(*v2) + v2->optlen;\n\n\t\tcb->type = v2->type;\n\t\tcb->confirm_rx = !!(v2->flags & QRTR_FLAGS_CONFIRM_RX);\n\t\tcb->src_node = le16_to_cpu(v2->src_node_id);\n\t\tcb->src_port = le16_to_cpu(v2->src_port_id);\n\t\tcb->dst_node = le16_to_cpu(v2->dst_node_id);\n\t\tcb->dst_port = le16_to_cpu(v2->dst_port_id);\n\n\t\tif (cb->src_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->src_port = QRTR_PORT_CTRL;\n\t\tif (cb->dst_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->dst_port = QRTR_PORT_CTRL;\n\n\t\tsize = le32_to_cpu(v2->size);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"qrtr: Invalid version %d\\n\", ver);\n\t\tgoto err;\n\t}\n\n\tif (len != ALIGN(size, 4) + hdrlen)\n\t\tgoto err;\n\n\tif (cb->dst_port != QRTR_PORT_CTRL && cb->type != QRTR_TYPE_DATA &&\n\t    cb->type != QRTR_TYPE_RESUME_TX)\n\t\tgoto err;\n\n\tskb_put_data(skb, data + hdrlen, size);\n\n\tqrtr_node_assign(node, cb->src_node);\n\n\tif (cb->type == QRTR_TYPE_NEW_SERVER) {\n\t\t/* Remote node endpoint can bridge other distant nodes */\n\t\tconst struct qrtr_ctrl_pkt *pkt = data + hdrlen;\n\n\t\tqrtr_node_assign(node, le32_to_cpu(pkt->server.node));\n\t}\n\n\tif (cb->type == QRTR_TYPE_RESUME_TX) {\n\t\tqrtr_tx_resume(node, skb);\n\t} else {\n\t\tipc = qrtr_port_lookup(cb->dst_port);\n\t\tif (!ipc)\n\t\t\tgoto err;\n\n\t\tif (sock_queue_rcv_skb(&ipc->sk, skb)) {\n\t\t\tqrtr_port_put(ipc);\n\t\t\tgoto err;\n\t\t}\n\n\t\tqrtr_port_put(ipc);\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n\n}\n",
      "line_statements": [
        [
          496,
          "\tif (len != ALIGN(size, 4) + hdrlen)\n"
        ]
      ],
      "statements": [
        [
          496,
          "if (len != ALIGN(size, 4) + hdrlen)"
        ]
      ],
      "cve": "CVE-2021-3743"
    },
    {
      "commit_id": "e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d",
      "filepath": "print-isakmp.c",
      "project": "tcpdump",
      "project_repo_path": "symbol_backend_projects/tcpdump",
      "is_vulnerable": true,
      "func_name": "ikev1_attr_print",
      "func_body": "ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep)\n{\n\tint totlen;\n\tuint32_t t;\n\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tt = p[2];\n\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}",
      "line_statements": [
        [
          952,
          "ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep)"
        ],
        [
          959,
          "\telse"
        ],
        [
          961,
          "\tif (ep < p + totlen) {"
        ],
        [
          963,
          "\t\treturn ep + 1;"
        ],
        [
          972,
          "\t\trawprint(ndo, (const uint8_t *)&p[2], 2);"
        ],
        [
          974,
          "\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));"
        ],
        [
          975,
          "\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));"
        ]
      ],
      "statements": [
        [
          952,
          "ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep)"
        ],
        [
          959,
          "else"
        ],
        [
          961,
          "if (ep < p + totlen)"
        ],
        [
          963,
          "return ep + 1;"
        ],
        [
          972,
          "rawprint(ndo, (const uint8_t *)&p[2], 2);"
        ],
        [
          974,
          "ND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));"
        ],
        [
          975,
          "rawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));"
        ]
      ],
      "cve": "CVE-2017-13039"
    },
    {
      "commit_id": "6046aded8da002b08d380db29de2ba0268b6616e",
      "filepath": "src/ex_getln.c",
      "project": "vim",
      "project_repo_path": "symbol_backend_projects/vim",
      "is_vulnerable": false,
      "func_name": "cmdline_insert_reg",
      "func_body": "cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n    int\t\tsave_new_cmdpos = new_cmdpos;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    // use ESC to cancel inserting register\n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n\n#ifdef FEAT_EVAL\n\t// When there was a serious error abort getting the\n\t// command line.\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  // will free ccline.cmdbuff after\n\t    // putting it in history\n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t// Don't do p_wc completion.\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    new_cmdpos = save_new_cmdpos;\n\n    // remove the double quote\n    redrawcmd();\n\n    // The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;\n}",
      "line_statements": [
        [
          1209,
          "    int\t\tsave_new_cmdpos = new_cmdpos;"
        ],
        [
          1268,
          "    new_cmdpos = save_new_cmdpos;"
        ],
        [
          1269,
          ""
        ]
      ],
      "statements": [
        [
          1209,
          "int\t\tsave_new_cmdpos = new_cmdpos;"
        ],
        [
          1268,
          "new_cmdpos = save_new_cmdpos;"
        ],
        [
          1269,
          "\n"
        ]
      ],
      "cve": "CVE-2022-2175"
    },
    {
      "commit_id": "cef31d9af908243421258f1df35a4a644604efbe",
      "filepath": "kernel/time/posix-timers.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "good_sigevent",
      "func_body": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct task_struct *rtn = current->group_leader;\n\n\tswitch (event->sigev_notify) {\n\tcase SIGEV_SIGNAL | SIGEV_THREAD_ID:\n\t\trtn = find_task_by_vpid(event->sigev_notify_thread_id);\n\t\tif (!rtn || !same_thread_group(rtn, current))\n\t\t\treturn NULL;\n\t\t/* FALLTHRU */\n\tcase SIGEV_SIGNAL:\n\tcase SIGEV_THREAD:\n\t\tif (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)\n\t\t\treturn NULL;\n\t\t/* FALLTHRU */\n\tcase SIGEV_NONE:\n\t\treturn task_pid(rtn);\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n",
      "line_statements": [
        [
          437,
          "\tswitch (event->sigev_notify) {\n"
        ],
        [
          438,
          "\tcase SIGEV_SIGNAL | SIGEV_THREAD_ID:\n"
        ],
        [
          439,
          "\t\trtn = find_task_by_vpid(event->sigev_notify_thread_id);\n"
        ],
        [
          440,
          "\t\tif (!rtn || !same_thread_group(rtn, current))\n"
        ],
        [
          441,
          "\t\t\treturn NULL;\n"
        ],
        [
          442,
          "\t\t/* FALLTHRU */\n"
        ],
        [
          443,
          "\tcase SIGEV_SIGNAL:\n"
        ],
        [
          444,
          "\tcase SIGEV_THREAD:\n"
        ],
        [
          445,
          "\t\tif (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)\n"
        ],
        [
          446,
          "\t\t\treturn NULL;\n"
        ],
        [
          447,
          "\t\t/* FALLTHRU */\n"
        ],
        [
          448,
          "\tcase SIGEV_NONE:\n"
        ],
        [
          449,
          "\t\treturn task_pid(rtn);\n"
        ],
        [
          450,
          "\tdefault:\n"
        ],
        [
          452,
          "\t}\n"
        ]
      ],
      "statements": [
        [
          437,
          "switch (event->sigev_notify) {"
        ],
        [
          438,
          "case SIGEV_SIGNAL | SIGEV_THREAD_ID:"
        ],
        [
          439,
          "rtn = find_task_by_vpid(event->sigev_notify_thread_id);"
        ],
        [
          440,
          "if (!rtn || !same_thread_group(rtn, current))"
        ],
        [
          441,
          "return NULL;"
        ],
        [
          442,
          "/* FALLTHRU */"
        ],
        [
          443,
          "case SIGEV_SIGNAL:"
        ],
        [
          444,
          "case SIGEV_THREAD:"
        ],
        [
          445,
          "if (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)"
        ],
        [
          446,
          "return NULL;"
        ],
        [
          447,
          "/* FALLTHRU */"
        ],
        [
          448,
          "case SIGEV_NONE:"
        ],
        [
          449,
          "return task_pid(rtn);"
        ],
        [
          450,
          "default:"
        ],
        [
          452,
          "\t}\n"
        ]
      ],
      "cve": "CVE-2017-18344"
    },
    {
      "commit_id": "4c3aee4bb0294c232d56b6d34e9eeb74f630fe8c",
      "filepath": "print-mptcp.c",
      "project": "tcpdump",
      "project_repo_path": "symbol_backend_projects/tcpdump",
      "is_vulnerable": false,
      "func_name": "mp_dss_print",
      "func_body": "mp_dss_print(netdissect_options *ndo,\n             const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_dss *mdss = (const struct mp_dss *) opt;\n\n        /* We need the flags, at a minimum. */\n        if (opt_len < 4)\n                return 0;\n\n        if (flags & TH_SYN)\n                return 0;\n\n        if (mdss->flags & MP_DSS_F)\n                ND_PRINT((ndo, \" fin\"));\n\n        opt += 4;\n        opt_len -= 4;\n        if (mdss->flags & MP_DSS_A) {\n                /* Ack present */\n                ND_PRINT((ndo, \" ack \"));\n                /*\n                 * If the a flag is set, we have an 8-byte ack; if it's\n                 * clear, we have a 4-byte ack.\n                 */\n                if (mdss->flags & MP_DSS_a) {\n                        if (opt_len < 8)\n                                return 0;\n                        ND_PRINT((ndo, \"%\" PRIu64, EXTRACT_64BITS(opt)));\n                        opt += 8;\n                        opt_len -= 8;\n                } else {\n                        if (opt_len < 4)\n                                return 0;\n                        ND_PRINT((ndo, \"%u\", EXTRACT_32BITS(opt)));\n                        opt += 4;\n                        opt_len -= 4;\n                }\n        }\n\n        if (mdss->flags & MP_DSS_M) {\n                /*\n                 * Data Sequence Number (DSN), Subflow Sequence Number (SSN),\n                 * Data-Level Length present, and Checksum possibly present.\n                 */\n                ND_PRINT((ndo, \" seq \"));\n\t\t/*\n                 * If the m flag is set, we have an 8-byte NDS; if it's clear,\n                 * we have a 4-byte DSN.\n                 */\n                if (mdss->flags & MP_DSS_m) {\n                        if (opt_len < 8)\n                                return 0;\n                        ND_PRINT((ndo, \"%\" PRIu64, EXTRACT_64BITS(opt)));\n                        opt += 8;\n                        opt_len -= 8;\n                } else {\n                        if (opt_len < 4)\n                                return 0;\n                        ND_PRINT((ndo, \"%u\", EXTRACT_32BITS(opt)));\n                        opt += 4;\n                        opt_len -= 4;\n                }\n                if (opt_len < 4)\n                        return 0;\n                ND_PRINT((ndo, \" subseq %u\", EXTRACT_32BITS(opt)));\n                opt += 4;\n                opt_len -= 4;\n                if (opt_len < 2)\n                        return 0;\n                ND_PRINT((ndo, \" len %u\", EXTRACT_16BITS(opt)));\n                opt += 2;\n                opt_len -= 2;\n\n                /*\n                 * The Checksum is present only if negotiated.\n                 * If there are at least 2 bytes left, process the next 2\n                 * bytes as the Checksum.\n                 */\n                if (opt_len >= 2) {\n                        ND_PRINT((ndo, \" csum 0x%x\", EXTRACT_16BITS(opt)));\n                        opt_len -= 2;\n                }\n        }\n        if (opt_len != 0)\n                return 0;\n        return 1;\n}",
      "line_statements": [
        [
          246,
          "        if (opt_len < 4)"
        ],
        [
          247,
          "                return 0;"
        ],
        [
          248,
          ""
        ],
        [
          249,
          "        if (flags & TH_SYN)"
        ],
        [
          256,
          "        opt_len -= 4;"
        ],
        [
          265,
          "                        if (opt_len < 8)"
        ],
        [
          266,
          "                                return 0;"
        ],
        [
          269,
          "                        opt_len -= 8;"
        ],
        [
          271,
          "                        if (opt_len < 4)"
        ],
        [
          272,
          "                                return 0;"
        ],
        [
          275,
          "                        opt_len -= 4;"
        ],
        [
          290,
          "                        if (opt_len < 8)"
        ],
        [
          291,
          "                                return 0;"
        ],
        [
          294,
          "                        opt_len -= 8;"
        ],
        [
          296,
          "                        if (opt_len < 4)"
        ],
        [
          297,
          "                                return 0;"
        ],
        [
          300,
          "                        opt_len -= 4;"
        ],
        [
          302,
          "                if (opt_len < 4)"
        ],
        [
          303,
          "                        return 0;"
        ],
        [
          306,
          "                opt_len -= 4;"
        ],
        [
          307,
          "                if (opt_len < 2)"
        ],
        [
          308,
          "                        return 0;"
        ],
        [
          311,
          "                opt_len -= 2;"
        ],
        [
          318,
          "                if (opt_len >= 2) {"
        ],
        [
          320,
          "                        opt_len -= 2;"
        ],
        [
          321,
          "                }"
        ],
        [
          323,
          "        if (opt_len != 0)"
        ],
        [
          324,
          "                return 0;"
        ]
      ],
      "statements": [
        [
          246,
          "if (opt_len < 4)"
        ],
        [
          247,
          "return 0;"
        ],
        [
          248,
          "\n"
        ],
        [
          249,
          "if (flags & TH_SYN)"
        ],
        [
          256,
          "opt_len -= 4;"
        ],
        [
          265,
          "if (opt_len < 8)"
        ],
        [
          266,
          "return 0;"
        ],
        [
          269,
          "opt_len -= 8;"
        ],
        [
          271,
          "if (opt_len < 4)"
        ],
        [
          272,
          "return 0;"
        ],
        [
          275,
          "opt_len -= 4;"
        ],
        [
          290,
          "if (opt_len < 8)"
        ],
        [
          291,
          "return 0;"
        ],
        [
          294,
          "opt_len -= 8;"
        ],
        [
          296,
          "if (opt_len < 4)"
        ],
        [
          297,
          "return 0;"
        ],
        [
          300,
          "opt_len -= 4;"
        ],
        [
          302,
          "if (opt_len < 4)"
        ],
        [
          303,
          "return 0;"
        ],
        [
          306,
          "opt_len -= 4;"
        ],
        [
          307,
          "if (opt_len < 2)"
        ],
        [
          308,
          "return 0;"
        ],
        [
          311,
          "opt_len -= 2;"
        ],
        [
          318,
          "if (opt_len >= 2)"
        ],
        [
          320,
          "opt_len -= 2;"
        ],
        [
          321,
          "                }\n"
        ],
        [
          323,
          "if (opt_len != 0)"
        ],
        [
          324,
          "return 0;"
        ]
      ],
      "cve": "CVE-2017-13040"
    },
    {
      "commit_id": "6acb47d1a318e5b3b7115354ebc4ea060c59d3a1",
      "filepath": "drivers/phy/mscc/phy-ocelot-serdes.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "serdes_probe",
      "func_body": "static int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}",
      "line_statements": [
        [
          263,
          "\tfor (i = 0; i < SERDES_MAX; i++) {"
        ]
      ],
      "statements": [
        [
          263,
          "for (i = 0; i < SERDES_MAX; i++) {"
        ]
      ],
      "cve": "CVE-2018-20854"
    },
    {
      "commit_id": "8e05648d6b4459facbc783025c5c42d301fef5c3",
      "filepath": "src/isomedia/box_code_adobe.c",
      "project": "gpac",
      "project_repo_path": "symbol_backend_projects/gpac",
      "is_vulnerable": false,
      "func_name": "abst_box_read",
      "func_body": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}",
      "line_statements": [
        [
          96,
          "\ttmp_strsize =(u32)ptr->size;"
        ]
      ],
      "statements": [
        [
          96,
          "tmp_strsize =(u32)ptr->size;"
        ]
      ],
      "cve": "CVE-2020-23928"
    },
    {
      "commit_id": "ec65c42052d95d2c23d1d837136d1cf1d9ecef9e",
      "filepath": "evdns.c",
      "project": "libevent",
      "project_repo_path": "symbol_backend_projects/libevent",
      "is_vulnerable": false,
      "func_name": "search_make_new",
      "func_body": "search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tchar need_to_append_dot;\n\tstruct search_domain *dom;\n\n\tif (!base_len) return NULL;\n\tneed_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\t/* this is the postfix we want */\n\t\t\t/* the actual postfix string is kept at the end of the structure */\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\n\t/* we ran off the end of the list and still didn't find the requested string */\n\tEVUTIL_ASSERT(0);\n\treturn NULL; /* unreachable; stops warnings in some compilers. */\n}",
      "line_statements": [
        [
          3178,
          "\tchar need_to_append_dot;"
        ],
        [
          3181,
          "\tif (!base_len) return NULL;"
        ],
        [
          3182,
          "\tneed_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;"
        ],
        [
          3183,
          ""
        ]
      ],
      "statements": [
        [
          3176,
          "search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tchar need_to_append_dot;\n\tstruct search_domain *dom;\n\n\tif (!base_len) return NULL;\n\tneed_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\t/* this is the postfix we want */\n\t\t\t/* the actual postfix string is kept at the end of the structure */\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\n\t/* we ran off the end of the list and still didn't find the requested string */\n\tEVUTIL_ASSERT(0);\n\treturn NULL; /* unreachable; stops warnings in some compilers. */\n}"
        ],
        [
          3178,
          "char need_to_append_dot;"
        ],
        [
          3181,
          "if (!base_len)"
        ],
        [
          3182,
          "need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;"
        ]
      ],
      "cve": "CVE-2016-10197"
    },
    {
      "commit_id": "6364463d6f5b6254cac3d6aedf999b6a96225038",
      "filepath": "tensorflow/lite/kernels/internal/utils/sparsity_format_converter.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tflite::internal::sparsity::FormatConverter<T>::InitSparseToDenseConverter",
      "func_body": "void FormatConverter<T>::InitSparseToDenseConverter(\n    std::vector<int> shape, std::vector<int> traversal_order,\n    std::vector<TfLiteDimensionType> format, std::vector<int> dense_size,\n    std::vector<std::vector<int>> segments,\n    std::vector<std::vector<int>> indices, std::vector<int> block_map) {\n  dense_shape_ = std::move(shape);\n  traversal_order_ = std::move(traversal_order);\n  block_map_ = std::move(block_map);\n  format_ = std::move(format);\n\n  dense_size_ = 1;\n  for (int i = 0; i < dense_shape_.size(); i++) {\n    dense_size_ *= dense_shape_[i];\n  }\n\n  dim_metadata_.resize(2 * format_.size());\n  for (int i = 0; i < format_.size(); i++) {\n    if (format_[i] == kTfLiteDimDense) {\n      dim_metadata_[2 * i] = {dense_size[i]};\n    } else {\n      dim_metadata_[2 * i] = std::move(segments[i]);\n      dim_metadata_[2 * i + 1] = std::move(indices[i]);\n    }\n  }\n\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      if (original_rank + block_dim < traversal_order_.size()) {\n        int orig_dim = traversal_order_[original_rank + block_dim];\n        block_size_[block_dim] = dense_size[orig_dim];\n        blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n        block_dim++;\n      }\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}",
      "line_statements": [
        [
          285,
          "      if (original_rank + block_dim < traversal_order_.size()) {"
        ],
        [
          286,
          "        int orig_dim = traversal_order_[original_rank + block_dim];"
        ],
        [
          287,
          "        block_size_[block_dim] = dense_size[orig_dim];"
        ],
        [
          288,
          "        blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];"
        ],
        [
          289,
          "        block_dim++;"
        ],
        [
          290,
          "      }"
        ]
      ],
      "statements": [
        [
          285,
          "if (original_rank + block_dim < traversal_order_.size())"
        ],
        [
          286,
          "int orig_dim = traversal_order_[original_rank + block_dim];"
        ],
        [
          287,
          "block_size_[block_dim] = dense_size[orig_dim];"
        ],
        [
          288,
          "blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];"
        ],
        [
          289,
          "block_dim++;"
        ],
        [
          290,
          "      }\n"
        ]
      ],
      "cve": "CVE-2022-23560"
    },
    {
      "commit_id": "d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6",
      "filepath": "libclamav/xar.c",
      "project": "clamav",
      "project_repo_path": "symbol_backend_projects/clamav",
      "is_vulnerable": true,
      "func_name": "xar_get_toc_data_values",
      "func_body": "static int xar_get_toc_data_values(xmlTextReaderPtr reader, long *length, long *offset, long *size, int *encoding,\n                                   unsigned char ** a_cksum, int * a_hash, unsigned char ** e_cksum, int * e_hash)\n{\n    const xmlChar *name;\n    int indata = 0, inea = 0;\n    int rc, gotoffset=0, gotlength=0, gotsize=0;\n\n    *a_cksum = NULL;\n    *a_hash = XAR_CKSUM_NONE;\n    *e_cksum = NULL;\n    *e_hash = XAR_CKSUM_NONE;\n    *encoding = CL_TYPE_ANY;\n\n    rc = xmlTextReaderRead(reader);\n    while (rc == 1) {\n        name = xmlTextReaderConstLocalName(reader);\n        if (indata || inea) {\n            /*  cli_dbgmsg(\"cli_scanxar: xmlTextReaderRead read %s\\n\", name); */\n            if (xmlStrEqual(name, (const xmlChar *)\"offset\") && \n                xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, offset))\n                    gotoffset=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"length\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, length))\n                    gotlength=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"size\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, size))\n                    gotsize=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"archived-checksum\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                cli_dbgmsg(\"cli_scanxar: <archived-checksum>:\\n\");\n                xar_get_checksum_values(reader, a_cksum, a_hash);\n                \n            } else if ((xmlStrEqual(name, (const xmlChar *)\"extracted-checksum\") ||\n                        xmlStrEqual(name, (const xmlChar *)\"unarchived-checksum\")) &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                cli_dbgmsg(\"cli_scanxar: <extracted-checksum>:\\n\");\n                xar_get_checksum_values(reader, e_cksum, e_hash);\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"encoding\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)\"style\");\n                if (style == NULL) {\n                    cli_dbgmsg(\"cli_scaxar: xmlTextReaderGetAttribute no style attribute \"\n                               \"for encoding element\\n\");\n                    *encoding = CL_TYPE_ANY;\n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-gzip\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-gzip.\\n\");\n                    *encoding = CL_TYPE_GZ; \n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/octet-stream\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/octet-stream.\\n\");\n                    *encoding = CL_TYPE_ANY; \n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-bzip2\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-bzip2.\\n\");\n                    *encoding = CL_TYPE_BZ;\n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-lzma\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-lzma.\\n\");\n                    *encoding = CL_TYPE_7Z;\n                 } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-xz\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-xz.\\n\");\n                    *encoding = CL_TYPE_XZ;\n                } else {\n                    cli_dbgmsg(\"cli_scaxar: unknown style value=%s for encoding element\\n\", style);\n                    *encoding = CL_TYPE_ANY;\n                }\n                if (style != NULL)\n                    xmlFree(style);\n\n           } else if (indata && xmlStrEqual(name, (const xmlChar *)\"data\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {\n                break;\n\n            } else if (inea && xmlStrEqual(name, (const xmlChar *)\"ea\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {\n                break;\n            }\n            \n        } else {\n            if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (xmlStrEqual(name, (const xmlChar *)\"data\")) {\n                    cli_dbgmsg(\"cli_scanxar: xmlTextReaderRead read <data>\\n\");\n                    indata = 1;\n                } else if (xmlStrEqual(name, (const xmlChar *)\"ea\")) {\n                    cli_dbgmsg(\"cli_scanxar: xmlTextReaderRead read <ea>\\n\");\n                    inea = 1;\n                }\n            } else if ((xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) &&\n                       xmlStrEqual(name, (const xmlChar *)\"xar\")) {\n                cli_dbgmsg(\"cli_scanxar: finished parsing xar TOC.\\n\");   \n                break;\n            }\n        }\n        rc = xmlTextReaderRead(reader);\n    }\n    \n    if (gotoffset && gotlength && gotsize) {\n        rc = CL_SUCCESS;\n    }\n    else if (0 == gotoffset + gotlength + gotsize)\n        rc = CL_BREAK;\n    else\n        rc = CL_EFORMAT;\n\n    return rc;\n}",
      "line_statements": [
        [
          152,
          "static int xar_get_toc_data_values(xmlTextReaderPtr reader, long *length, long *offset, long *size, int *encoding,"
        ]
      ],
      "statements": [
        [
          152,
          "static int xar_get_toc_data_values(xmlTextReaderPtr reader, long *length, long *offset, long *size, int *encoding,\n                                   unsigned char ** a_cksum, int * a_hash, unsigned char ** e_cksum, int * e_hash)"
        ]
      ],
      "cve": "CVE-2018-1000085"
    },
    {
      "commit_id": "f1cd34e63c2a0d9702be3d41462db7bfd0ae7da3",
      "filepath": "hphp/runtime/ext/gd/ext_gd.cpp",
      "project": "hhvm",
      "project_repo_path": "symbol_backend_projects/hhvm",
      "is_vulnerable": true,
      "func_name": "HPHP::exif_process_APP12",
      "func_body": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}",
      "line_statements": [
        [
          6967,
          "      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);"
        ]
      ],
      "statements": [
        [
          6967,
          "l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);"
        ]
      ],
      "cve": "CVE-2019-11925"
    },
    {
      "commit_id": "9c78a04df4e44ef6487eee99c4258397f4fdca55",
      "filepath": "rdbmp.c",
      "project": "libjpeg-turbo",
      "project_repo_path": "symbol_backend_projects/libjpeg-turbo",
      "is_vulnerable": false,
      "func_name": "get_8bit_row",
      "func_body": "get_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 8-bit colormap indexes */\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  register JSAMPARRAY colormap = source->colormap;\n  int cmaplen = source->cmap_length;\n  JSAMPARRAY image_ptr;\n  register int t;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n\n  if (source->use_inversion_array) {\n    /* Fetch next row from virtual array */\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n\n  /* Expand the colormap indexes to real data */\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_GRAYSCALE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      t = GETJSAMPLE(*inptr++);\n      if (t >= cmaplen)\n        ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n      *outptr++ = colormap[0][t];\n    }\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      t = GETJSAMPLE(*inptr++);\n      if (t >= cmaplen)\n        ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n      rgb_to_cmyk(colormap[0][t], colormap[1][t], colormap[2][t], outptr,\n                  outptr + 1, outptr + 2, outptr + 3);\n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        t = GETJSAMPLE(*inptr++);\n        if (t >= cmaplen)\n          ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n        outptr[rindex] = colormap[0][t];\n        outptr[gindex] = colormap[1][t];\n        outptr[bindex] = colormap[2][t];\n        outptr[aindex] = 0xFF;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        t = GETJSAMPLE(*inptr++);\n        if (t >= cmaplen)\n          ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n        outptr[rindex] = colormap[0][t];\n        outptr[gindex] = colormap[1][t];\n        outptr[bindex] = colormap[2][t];\n        outptr += ps;\n      }\n    }\n  }\n\n  return 1;\n}",
      "line_statements": [
        [
          159,
          "  int cmaplen = source->cmap_length;"
        ],
        [
          183,
          "      if (t >= cmaplen)"
        ],
        [
          184,
          "        ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);"
        ],
        [
          190,
          "      if (t >= cmaplen)"
        ],
        [
          191,
          "        ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);"
        ],
        [
          206,
          "        if (t >= cmaplen)"
        ],
        [
          207,
          "          ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);"
        ],
        [
          217,
          "        if (t >= cmaplen)"
        ],
        [
          218,
          "          ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);"
        ]
      ],
      "statements": [
        [
          159,
          "int cmaplen = source->cmap_length;"
        ],
        [
          183,
          "if (t >= cmaplen)"
        ],
        [
          184,
          "ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);"
        ],
        [
          190,
          "if (t >= cmaplen)"
        ],
        [
          191,
          "ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);"
        ],
        [
          206,
          "if (t >= cmaplen)"
        ],
        [
          207,
          "ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);"
        ],
        [
          217,
          "if (t >= cmaplen)"
        ],
        [
          218,
          "ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);"
        ]
      ],
      "cve": "CVE-2018-14498"
    },
    {
      "commit_id": "354dd3924a2e43806774953de536257548b5002c",
      "filepath": "drivers/media/pci/saa7164/saa7164-bus.c",
      "project": "media-tree",
      "project_repo_path": "symbol_backend_projects/media-tree",
      "is_vulnerable": false,
      "func_name": "saa7164_bus_get",
      "func_body": "int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,\n\tvoid *buf, int peekonly)\n{\n\tstruct tmComResBusInfo *bus = &dev->bus;\n\tu32 bytes_to_read, write_distance, curr_grp, curr_gwp,\n\t\tnew_grp, buf_size, space_rem;\n\tstruct tmComResInfo msg_tmp;\n\tint ret = SAA_ERR_BAD_PARAMETER;\n\n\tsaa7164_bus_verify(dev);\n\n\tif (msg == NULL)\n\t\treturn ret;\n\n\tif (msg->size > dev->bus.m_wMaxReqSize) {\n\t\tprintk(KERN_ERR \"%s() Exceeded dev->bus.m_wMaxReqSize\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif ((peekonly == 0) && (msg->size > 0) && (buf == NULL)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"%s() Missing msg buf, size should be %d bytes\\n\",\n\t\t\t__func__, msg->size);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&bus->lock);\n\n\t/* Peek the bus to see if a msg exists, if it's not what we're expecting\n\t * then return cleanly else read the message from the bus.\n\t */\n\tcurr_gwp = saa7164_readl(bus->m_dwGetWritePos);\n\tcurr_grp = saa7164_readl(bus->m_dwGetReadPos);\n\n\tif (curr_gwp == curr_grp) {\n\t\tret = SAA_ERR_EMPTY;\n\t\tgoto out;\n\t}\n\n\tbytes_to_read = sizeof(*msg);\n\n\t/* Calculate write distance to current read position */\n\twrite_distance = 0;\n\tif (curr_gwp >= curr_grp)\n\t\t/* Write doesn't wrap around the ring */\n\t\twrite_distance = curr_gwp - curr_grp;\n\telse\n\t\t/* Write wraps around the ring */\n\t\twrite_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;\n\n\tif (bytes_to_read > write_distance) {\n\t\tprintk(KERN_ERR \"%s() No message/response found\\n\", __func__);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Calculate the new read position */\n\tnew_grp = curr_grp + bytes_to_read;\n\tif (new_grp > bus->m_dwSizeGetRing) {\n\n\t\t/* Ring wraps */\n\t\tnew_grp -= bus->m_dwSizeGetRing;\n\t\tspace_rem = bus->m_dwSizeGetRing - curr_grp;\n\n\t\tmemcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, space_rem);\n\t\tmemcpy_fromio((u8 *)&msg_tmp + space_rem, bus->m_pdwGetRing,\n\t\t\tbytes_to_read - space_rem);\n\n\t} else {\n\t\t/* No wrapping */\n\t\tmemcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, bytes_to_read);\n\t}\n\t/* Convert from little endian to CPU */\n\tmsg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);\n\tmsg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);\n\tmsg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);\n\tmemcpy(msg, &msg_tmp, sizeof(*msg));\n\n\t/* No need to update the read positions, because this was a peek */\n\t/* If the caller specifically want to peek, return */\n\tif (peekonly) {\n\t\tgoto peekout;\n\t}\n\n\t/* Check if the command/response matches what is expected */\n\tif ((msg_tmp.id != msg->id) || (msg_tmp.command != msg->command) ||\n\t\t(msg_tmp.controlselector != msg->controlselector) ||\n\t\t(msg_tmp.seqno != msg->seqno) || (msg_tmp.size != msg->size)) {\n\n\t\tprintk(KERN_ERR \"%s() Unexpected msg miss-match\\n\", __func__);\n\t\tsaa7164_bus_dumpmsg(dev, msg, buf);\n\t\tsaa7164_bus_dumpmsg(dev, &msg_tmp, NULL);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Get the actual command and response from the bus */\n\tbuf_size = msg->size;\n\n\tbytes_to_read = sizeof(*msg) + msg->size;\n\t/* Calculate write distance to current read position */\n\twrite_distance = 0;\n\tif (curr_gwp >= curr_grp)\n\t\t/* Write doesn't wrap around the ring */\n\t\twrite_distance = curr_gwp - curr_grp;\n\telse\n\t\t/* Write wraps around the ring */\n\t\twrite_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;\n\n\tif (bytes_to_read > write_distance) {\n\t\tprintk(KERN_ERR \"%s() Invalid bus state, missing msg or mangled ring, faulty H/W / bad code?\\n\",\n\t\t       __func__);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Calculate the new read position */\n\tnew_grp = curr_grp + bytes_to_read;\n\tif (new_grp > bus->m_dwSizeGetRing) {\n\n\t\t/* Ring wraps */\n\t\tnew_grp -= bus->m_dwSizeGetRing;\n\t\tspace_rem = bus->m_dwSizeGetRing - curr_grp;\n\n\t\tif (space_rem < sizeof(*msg)) {\n\t\t\tif (buf)\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + sizeof(*msg) -\n\t\t\t\t\tspace_rem, buf_size);\n\n\t\t} else if (space_rem == sizeof(*msg)) {\n\t\t\tif (buf)\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing, buf_size);\n\t\t} else {\n\t\t\t/* Additional data wraps around the ring */\n\t\t\tif (buf) {\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + curr_grp +\n\t\t\t\t\tsizeof(*msg), space_rem - sizeof(*msg));\n\t\t\t\tmemcpy_fromio(buf + space_rem - sizeof(*msg),\n\t\t\t\t\tbus->m_pdwGetRing, bytes_to_read -\n\t\t\t\t\tspace_rem);\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\t\t/* No wrapping */\n\t\tif (buf)\n\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),\n\t\t\t\tbuf_size);\n\t}\n\n\t/* Update the read positions, adjusting the ring */\n\tsaa7164_writel(bus->m_dwGetReadPos, new_grp);\n\npeekout:\n\tret = SAA_OK;\nout:\n\tmutex_unlock(&bus->lock);\n\tsaa7164_bus_verify(dev);\n\treturn ret;\n}",
      "line_statements": [
        [
          392,
          "\tmemcpy(msg, &msg_tmp, sizeof(*msg));"
        ]
      ],
      "statements": [
        [
          392,
          "memcpy(msg, &msg_tmp, sizeof(*msg));"
        ]
      ],
      "cve": "CVE-2017-8831"
    },
    {
      "commit_id": "eee0b04bcfdae319c242b0b8fc3d07029ee65b8c",
      "filepath": "print-ip.c",
      "project": "tcpdump",
      "project_repo_path": "symbol_backend_projects/tcpdump",
      "is_vulnerable": false,
      "func_name": "ip_optprint",
      "func_body": "ip_optprint(netdissect_options *ndo,\n            register const u_char *cp, u_int length)\n{\n\tregister u_int option_len;\n\tconst char *sep = \"\";\n\n\tfor (; length > 0; cp += option_len, length -= option_len) {\n\t\tu_int option_code;\n\n\t\tND_PRINT((ndo, \"%s\", sep));\n\t\tsep = \",\";\n\n\t\tND_TCHECK(*cp);\n\t\toption_code = *cp;\n\n\t\tND_PRINT((ndo, \"%s\",\n\t\t          tok2str(ip_option_values,\"unknown %u\",option_code)));\n\n\t\tif (option_code == IPOPT_NOP ||\n                    option_code == IPOPT_EOL)\n\t\t\toption_len = 1;\n\n\t\telse {\n\t\t\tND_TCHECK(cp[1]);\n\t\t\toption_len = cp[1];\n\t\t\tif (option_len < 2) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (option_len > length) {\n\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\treturn;\n\t\t}\n\n\t\tND_TCHECK2(*cp, option_len);\n\n\t\tswitch (option_code) {\n\t\tcase IPOPT_EOL:\n\t\t\treturn;\n\n\t\tcase IPOPT_TS:\n\t\t\tip_printts(ndo, cp, option_len);\n\t\t\tbreak;\n\n\t\tcase IPOPT_RR:       /* fall through */\n\t\tcase IPOPT_SSRR:\n\t\tcase IPOPT_LSRR:\n\t\t\tif (ip_printroute(ndo, cp, option_len) == -1)\n\t\t\t\tgoto trunc;\n\t\t\tbreak;\n\n\t\tcase IPOPT_RA:\n\t\t\tif (option_len < 4) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_TCHECK(cp[3]);\n\t\t\tif (EXTRACT_16BITS(&cp[2]) != 0)\n\t\t\t\tND_PRINT((ndo, \" value %u\", EXTRACT_16BITS(&cp[2])));\n\t\t\tbreak;\n\n\t\tcase IPOPT_NOP:       /* nothing to print - fall through */\n\t\tcase IPOPT_SECURITY:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}",
      "line_statements": [
        [
          287,
          "\t\t\tif (ip_printroute(ndo, cp, option_len) == -1)"
        ],
        [
          288,
          "\t\t\t\tgoto trunc;"
        ]
      ],
      "statements": [
        [
          287,
          "if (ip_printroute(ndo, cp, option_len) == -1)"
        ],
        [
          288,
          "goto trunc;"
        ]
      ],
      "cve": "CVE-2017-13022"
    },
    {
      "commit_id": "15f081c89650dccee4aa4ae66f614c3fdb268767",
      "filepath": "src/bin/common/color.c",
      "project": "openjpeg",
      "project_repo_path": "symbol_backend_projects/openjpeg",
      "is_vulnerable": false,
      "func_name": "sycc422_to_rgb",
      "func_body": "static void sycc422_to_rgb(opj_image_t *img)\n{\t\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tsize_t maxw, maxh, max, offx, loopmaxw;\n\tint offset, upb;\n\tsize_t i;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * max);\n\td1 = g = (int*)malloc(sizeof(int) * max);\n\td2 = b = (int*)malloc(sizeof(int) * max);\n\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\n\t/* if img->x0 is odd, then first column shall use Cb/Cr = 0 */\n\toffx = img->x0 & 1U;\n\tloopmaxw = maxw - offx;\n\t\n\tfor(i=0U; i < maxh; ++i)\n\t{\n\t\tsize_t j;\n\t\t\n\t\tif (offx > 0U) {\n\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t}\n\t\t\n\t\tfor(j=0U; j < (loopmaxw & ~(size_t)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t\tif (j < loopmaxw) {\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t}\n\t\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\n\timg->comps[1].w = img->comps[2].w = img->comps[0].w;\n\timg->comps[1].h = img->comps[2].h = img->comps[0].h;\n\timg->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n\timg->color_space = OPJ_CLRSPC_SRGB;\n\treturn;\n\nfails:\n\tfree(r);\n\tfree(g);\n\tfree(b);\n}/* sycc422_to_rgb() */",
      "line_statements": [
        [
          134,
          "\tsize_t maxw, maxh, max, offx, loopmaxw;"
        ],
        [
          136,
          "\tsize_t i;"
        ],
        [
          141,
          "\tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;"
        ],
        [
          148,
          "\td0 = r = (int*)malloc(sizeof(int) * max);"
        ],
        [
          149,
          "\td1 = g = (int*)malloc(sizeof(int) * max);"
        ],
        [
          150,
          "\td2 = b = (int*)malloc(sizeof(int) * max);"
        ],
        [
          155,
          "\toffx = img->x0 & 1U;"
        ],
        [
          156,
          "\tloopmaxw = maxw - offx;"
        ],
        [
          157,
          ""
        ],
        [
          160,
          "\t\tsize_t j;"
        ],
        [
          161,
          ""
        ],
        [
          162,
          "\t\tif (offx > 0U) {"
        ],
        [
          163,
          "\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);"
        ],
        [
          164,
          "\t\t\t++y; ++r; ++g; ++b;"
        ],
        [
          165,
          "\t\t}"
        ],
        [
          166,
          ""
        ],
        [
          167,
          "\t\tfor(j=0U; j < (loopmaxw & ~(size_t)1U); j += 2U)"
        ],
        [
          174,
          "\t\tif (j < loopmaxw) {"
        ],
        [
          179,
          ""
        ],
        [
          184,
          "\timg->comps[1].w = img->comps[2].w = img->comps[0].w;"
        ],
        [
          185,
          "\timg->comps[1].h = img->comps[2].h = img->comps[0].h;"
        ],
        [
          186,
          "\timg->comps[1].dx = img->comps[2].dx = img->comps[0].dx;"
        ],
        [
          187,
          "\timg->comps[1].dy = img->comps[2].dy = img->comps[0].dy;"
        ],
        [
          188,
          "\timg->color_space = OPJ_CLRSPC_SRGB;"
        ],
        [
          192,
          "\tfree(r);"
        ],
        [
          193,
          "\tfree(g);"
        ],
        [
          194,
          "\tfree(b);"
        ]
      ],
      "statements": [
        [
          134,
          "size_t maxw, maxh, max, offx, loopmaxw;"
        ],
        [
          136,
          "size_t i;"
        ],
        [
          141,
          "\tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;\n"
        ],
        [
          148,
          "d0 = r = (int*)malloc(sizeof(int) * max);"
        ],
        [
          149,
          "d1 = g = (int*)malloc(sizeof(int) * max);"
        ],
        [
          150,
          "d2 = b = (int*)malloc(sizeof(int) * max);"
        ],
        [
          155,
          "offx = img->x0 & 1U;"
        ],
        [
          156,
          "loopmaxw = maxw - offx;"
        ],
        [
          157,
          "\t\n"
        ],
        [
          160,
          "size_t j;"
        ],
        [
          161,
          "\t\t\n"
        ],
        [
          162,
          "if (offx > 0U)"
        ],
        [
          163,
          "sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);"
        ],
        [
          164,
          "\t\t\t++y; ++r; ++g; ++b;\n"
        ],
        [
          165,
          "\t\t}\n"
        ],
        [
          166,
          "\t\t\n"
        ],
        [
          167,
          "for(j=0U; j < (loopmaxw & ~(size_t)1U); j += 2U)"
        ],
        [
          174,
          "if (j < loopmaxw)"
        ],
        [
          179,
          "\t\n"
        ],
        [
          184,
          "img->comps[1].w = img->comps[2].w = img->comps[0].w;"
        ],
        [
          185,
          "img->comps[1].h = img->comps[2].h = img->comps[0].h;"
        ],
        [
          186,
          "img->comps[1].dx = img->comps[2].dx = img->comps[0].dx;"
        ],
        [
          187,
          "img->comps[1].dy = img->comps[2].dy = img->comps[0].dy;"
        ],
        [
          188,
          "img->color_space = OPJ_CLRSPC_SRGB;"
        ],
        [
          192,
          "free(r);"
        ],
        [
          193,
          "free(g);"
        ],
        [
          194,
          "free(b);"
        ]
      ],
      "cve": "CVE-2016-3183"
    },
    {
      "commit_id": "c09581a52765a85f19fc35340127396d5e3379cc",
      "filepath": "drivers/scsi/qedi/qedi_dbg.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "qedi_dbg_err",
      "func_body": "void\nqedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t     const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       func, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\n\tva_end(va);\n}\n",
      "line_statements": [
        [
          27,
          "\t\t       func, line, qedi->host_no, &vaf);\n"
        ],
        [
          29,
          "\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n"
        ]
      ],
      "statements": [
        [
          26,
          "pr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       func, line, qedi->host_no, &vaf);"
        ],
        [
          29,
          "pr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);"
        ]
      ],
      "cve": "CVE-2019-15090"
    },
    {
      "commit_id": "a1eefe986065846b6c69dbc09afd9fa1a02c4a3d",
      "filepath": "print-chdlc.c",
      "project": "tcpdump",
      "project_repo_path": "symbol_backend_projects/tcpdump",
      "is_vulnerable": false,
      "func_name": "chdlc_if_print",
      "func_body": "chdlc_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p)\n{\n\treturn chdlc_print(ndo, p, h->len);\n}",
      "line_statements": [
        [
          49,
          "\treturn chdlc_print(ndo, p, h->len);"
        ]
      ],
      "statements": [
        [
          49,
          "return chdlc_print(ndo, p, h->len);"
        ]
      ],
      "cve": "CVE-2017-13687"
    },
    {
      "commit_id": "612562bc1ea38f1708b044e7a079c47a05b1291d",
      "filepath": "src/index.c",
      "project": "libmobi",
      "project_repo_path": "symbol_backend_projects/libmobi",
      "is_vulnerable": true,
      "func_name": "mobi_parse_index_entry",
      "func_body": "static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n        debug_print(\"%s\", \"INDX structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t entry_offset = indx->entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number >= indx->total_entries_count) {\n        debug_print(\"Entry number beyond array: %zu\\n\", entry_number);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* save original record maxlen */\n    const size_t buf_maxlen = buf->maxlen;\n    if (buf->offset + entry_length >= buf_maxlen) {\n        debug_print(\"Entry length too long: %zu\\n\", entry_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    buf->maxlen = buf->offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length > entry_length) {\n        debug_print(\"Label length too long: %zu\\n\", label_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    char text[INDX_LABEL_SIZEMAX];\n    /* FIXME: what is ORDT1 for? */\n    if (ordt->ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n    }\n    indx->entries[entry_number].label = malloc(label_length + 1);\n    if (indx->entries[entry_number].label == NULL) {\n        debug_print(\"Memory allocation failed (%zu bytes)\\n\", label_length);\n        return MOBI_MALLOC_FAILED;\n    }\n    strncpy(indx->entries[entry_number].label, text, label_length + 1);\n    //debug_print(\"tag label[%zu]: %s\\n\", entry_number, indx->entries[entry_number].label);\n    unsigned char *control_bytes;\n    control_bytes = buf->data + buf->offset;\n    mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n    indx->entries[entry_number].tags_count = 0;\n    indx->entries[entry_number].tags = NULL;\n    if (tagx->tags_count > 0) {\n        typedef struct {\n            uint8_t tag;\n            uint8_t tag_value_count;\n            uint32_t value_count;\n            uint32_t value_bytes;\n        } MOBIPtagx;\n        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t ptagx_count = 0;\n        size_t len;\n        size_t i = 0;\n        while (i < tagx->tags_count) {\n            if (tagx->tags[i].control_byte == 1) {\n                control_bytes++;\n                i++;\n                continue;\n            }\n            uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;\n            if (value != 0) {\n                /* FIXME: is it safe to use MOBI_NOTSET? */\n                uint32_t value_count = MOBI_NOTSET;\n                uint32_t value_bytes = MOBI_NOTSET;\n                /* all bits of masked value are set */\n                if (value == tagx->tags[i].bitmask) {\n                    /* more than 1 bit set */\n                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                        /* read value bytes from entry */\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    } else {\n                        value_count = 1;\n                    }\n                } else {\n                    uint8_t mask = tagx->tags[i].bitmask;\n                    while ((mask & 1) == 0) {\n                        mask >>= 1;\n                        value >>= 1;\n                    }\n                    value_count = value;\n                }\n                ptagx[ptagx_count].tag = tagx->tags[i].tag;\n                ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;\n                ptagx[ptagx_count].value_count = value_count;\n                ptagx[ptagx_count].value_bytes = value_bytes;\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n        if (indx->entries[entry_number].tags == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));\n            free(ptagx);\n            return MOBI_MALLOC_FAILED;\n        }\n        i = 0;\n        while (i < ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            /* FIXME: is it safe to use MOBI_NOTSET? */\n            /* value count is set */\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;\n                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            /* value count is not set */\n            } else {\n                /* read value_bytes bytes */\n                len = 0;\n                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                    debug_print(\"Memory allocation failed (%zu bytes)\\n\", arr_size);\n                    free(ptagx);\n                    return MOBI_MALLOC_FAILED;\n                }\n                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx->entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;\n            indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;\n            indx->entries[entry_number].tags_count++;\n            i++;\n        }\n        free(ptagx);\n    }\n    /* restore buffer maxlen */\n    buf->maxlen = buf_maxlen;\n    return MOBI_SUCCESS;\n}",
      "line_statements": [
        [
          365,
          "    char text[INDX_LABEL_SIZEMAX];"
        ]
      ],
      "statements": [
        [
          365,
          "char text[INDX_LABEL_SIZEMAX];"
        ]
      ],
      "cve": "CVE-2022-1987"
    },
    {
      "commit_id": "bd4e697ebd6c8457efa8f28f6831fc929b88a014",
      "filepath": "print-bgp.c",
      "project": "tcpdump",
      "project_repo_path": "symbol_backend_projects/tcpdump",
      "is_vulnerable": true,
      "func_name": "decode_rt_routing_info",
      "func_body": "decode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\tif (0 == plen) {\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\n\tif (32 > plen)\n\t\treturn -1;\n\n        plen-=32; /* adjust prefix length */\n\n\tif (64 < plen)\n\t\treturn -1;\n\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\n\treturn 5 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}",
      "line_statements": [
        [
          782,
          "\tND_TCHECK2(pptr[1], (plen + 7) / 8);"
        ],
        [
          783,
          "\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);"
        ],
        [
          789,
          "\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),"
        ]
      ],
      "statements": [
        [
          782,
          "ND_TCHECK2(pptr[1], (plen + 7) / 8);"
        ],
        [
          783,
          "memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
        ],
        [
          788,
          "snprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));"
        ]
      ],
      "cve": "CVE-2017-13053"
    },
    {
      "commit_id": "f1cd34e63c2a0d9702be3d41462db7bfd0ae7da3",
      "filepath": "hphp/runtime/ext/gd/ext_gd.cpp",
      "project": "hhvm",
      "project_repo_path": "symbol_backend_projects/hhvm",
      "is_vulnerable": false,
      "func_name": "HPHP::exif_process_APP12",
      "func_body": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1-1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}",
      "line_statements": [
        [
          6967,
          "      l2 = php_strnlen(buffer+2+l1+1, length-2-l1-1);"
        ]
      ],
      "statements": [
        [
          6967,
          "l2 = php_strnlen(buffer+2+l1+1, length-2-l1-1);"
        ]
      ],
      "cve": "CVE-2019-11925"
    },
    {
      "commit_id": "ee004b18b976eeb5a758020af8880236cd707d05",
      "filepath": "tensorflow/core/kernels/dynamic_stitch_op.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tensorflow::DynamicStitchOpImplBase::CheckArgsAndAllocateResult",
      "func_body": "  void CheckArgsAndAllocateResult(OpKernelContext* c,\n                                  OpInputList* indices_inputs,\n                                  OpInputList* data_inputs, int* first_dim_size,\n                                  int* data_elements_size,\n                                  Tensor** result_ptr) {\n    // Find maximum index in the indices vectors\n    OP_REQUIRES_OK(c, c->input_list(\"indices\", indices_inputs));\n\n    int32_t max_index = -1;\n    if (data_elements_size) {\n      *data_elements_size = 0;\n    }\n    for (const Tensor& indices : *indices_inputs) {\n      if (indices.NumElements() > 0) {\n        Eigen::Tensor<int32, 0, Eigen::RowMajor> m =\n            indices.flat<int32>().maximum();\n        max_index = std::max(m(), max_index);\n      }\n      if (data_elements_size) {\n        *data_elements_size += indices.NumElements();\n      }\n    }\n\n    *first_dim_size = max_index + 1;\n\n    for (const Tensor& indices : *indices_inputs) {\n      auto indices_vec = indices.flat<int32>();\n\n      for (int i = 0; i < indices_vec.size(); i++) {\n        int32_t index = internal::SubtleMustCopy(indices_vec(i));\n        OP_REQUIRES(\n            c, FastBoundsCheck(index, *first_dim_size),\n            errors::InvalidArgument(\"indices[\", i, \"] is out of range\"));\n      }\n    }\n\n    // Validate that data[i].shape = indices[i].shape + constant\n    OP_REQUIRES_OK(c, c->input_list(\"data\", data_inputs));\n    const Tensor& data0 = (*data_inputs)[0];\n    const Tensor& indices0 = (*indices_inputs)[0];\n    for (int input_num = 0; input_num < indices_inputs->size(); input_num++) {\n      const Tensor& indices = (*indices_inputs)[input_num];\n      const Tensor& data = (*data_inputs)[input_num];\n      OP_REQUIRES(\n          c, TensorShapeUtils::StartsWith(data.shape(), indices.shape()),\n          errors::InvalidArgument(\"data[\", input_num,\n                                  \"].shape = \", data.shape().DebugString(),\n                                  \" does not start with indices[\", input_num,\n                                  \"].shape = \", indices.shape().DebugString()));\n      OP_REQUIRES(\n          c, input_num == 0 || SameExtraShape(data0, indices0, data, indices),\n          errors::InvalidArgument(\n              \"Need data[0].shape[\", indices0.dims(), \":] = data[\", input_num,\n              \"].shape[\", indices.dims(),\n              \":], got data[0].shape = \", data0.shape().DebugString(),\n              \", data[\", input_num, \"].shape = \", data.shape().DebugString(),\n              \", indices[0].shape = \", indices0.shape().DebugString(),\n              \", indices[\", input_num,\n              \"].shape = \", indices.shape().DebugString()));\n    }\n\n    // Allocate result tensor of shape\n    //   [*first_dim_size] + data.shape[indices.dims:]\n    TensorShape result_shape;\n    OP_REQUIRES_OK(c, result_shape.AddDimWithStatus(*first_dim_size));\n    for (int d = indices0.dims(); d < data0.dims(); d++) {\n      OP_REQUIRES_OK(c, result_shape.AddDimWithStatus(data0.dim_size(d)));\n    }\n    OP_REQUIRES_OK(c, c->allocate_output(0, result_shape, result_ptr));\n  }",
      "line_statements": [
        [
          100,
          "    for (const Tensor& indices : *indices_inputs) {"
        ],
        [
          101,
          "      auto indices_vec = indices.flat<int32>();"
        ],
        [
          102,
          ""
        ],
        [
          103,
          "      for (int i = 0; i < indices_vec.size(); i++) {"
        ],
        [
          104,
          "        int32_t index = internal::SubtleMustCopy(indices_vec(i));"
        ],
        [
          105,
          "        OP_REQUIRES("
        ],
        [
          106,
          "            c, FastBoundsCheck(index, *first_dim_size),"
        ],
        [
          107,
          "            errors::InvalidArgument(\"indices[\", i, \"] is out of range\"));"
        ],
        [
          108,
          "      }"
        ],
        [
          109,
          "    }"
        ],
        [
          110,
          ""
        ]
      ],
      "statements": [
        [
          100,
          "for (const Tensor& indices : *indices_inputs) {"
        ],
        [
          101,
          "auto indices_vec = indices.flat<int32>();"
        ],
        [
          102,
          "\n"
        ],
        [
          103,
          "for (int i = 0; i < indices_vec.size(); i++) {"
        ],
        [
          104,
          "int32_t index = internal::SubtleMustCopy(indices_vec(i));"
        ],
        [
          105,
          "OP_REQUIRES(\n            c, FastBoundsCheck(index, *first_dim_size),\n            errors::InvalidArgument(\"indices[\", i, \"] is out of range\"));"
        ],
        [
          108,
          "      }\n"
        ],
        [
          109,
          "    }\n"
        ],
        [
          110,
          "\n"
        ]
      ],
      "cve": "CVE-2023-25659"
    },
    {
      "commit_id": "093283e727f396130651280609e687cd4778e0d1",
      "filepath": "src/isomedia/box_code_adobe.c",
      "project": "gpac",
      "project_repo_path": "symbol_backend_projects/gpac",
      "is_vulnerable": false,
      "func_name": "abst_box_read",
      "func_body": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size-8;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}",
      "line_statements": [
        [
          102,
          "\t\tISOM_DECREASE_SIZE(ptr, 1)"
        ],
        [
          113,
          "\tISOM_DECREASE_SIZE(ptr, 1)"
        ],
        [
          117,
          "\t\ttmp_strsize=(u32)ptr->size;"
        ],
        [
          119,
          "\t\t\tISOM_DECREASE_SIZE(ptr, 1)"
        ],
        [
          131,
          "\tISOM_DECREASE_SIZE(ptr, 1)"
        ],
        [
          135,
          "\t\ttmp_strsize=(u32)ptr->size;"
        ],
        [
          137,
          "\t\t\tISOM_DECREASE_SIZE(ptr, 1)"
        ],
        [
          151,
          "\ttmp_strsize=(u32)ptr->size;"
        ],
        [
          153,
          "\t\tISOM_DECREASE_SIZE(ptr, 1)"
        ],
        [
          165,
          "\ttmp_strsize=(u32)ptr->size;"
        ],
        [
          167,
          "\t\tISOM_DECREASE_SIZE(ptr, 1)"
        ],
        [
          178,
          "\tISOM_DECREASE_SIZE(ptr, 1)"
        ],
        [
          191,
          "\tISOM_DECREASE_SIZE(ptr, 1)"
        ]
      ],
      "statements": [
        [
          102,
          "ISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);"
        ],
        [
          113,
          "ISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);"
        ],
        [
          117,
          "tmp_strsize=(u32)ptr->size;"
        ],
        [
          119,
          "ISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);"
        ],
        [
          131,
          "ISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);"
        ],
        [
          135,
          "tmp_strsize=(u32)ptr->size;"
        ],
        [
          137,
          "ISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);"
        ],
        [
          151,
          "tmp_strsize=(u32)ptr->size;"
        ],
        [
          153,
          "ISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);"
        ],
        [
          165,
          "tmp_strsize=(u32)ptr->size;"
        ],
        [
          167,
          "ISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);"
        ],
        [
          178,
          "ISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);"
        ],
        [
          191,
          "ISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);"
        ]
      ],
      "cve": "CVE-2020-23931"
    },
    {
      "commit_id": "dea704f0ab7f625e1e7b3f9a1110b45b63157317",
      "filepath": "libqpdf/QPDF_encryption.cc",
      "project": "qpdf",
      "project_repo_path": "symbol_backend_projects/qpdf",
      "is_vulnerable": false,
      "func_name": "compute_U_value_R2",
      "func_body": "compute_U_value_R2(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.4 from the PDF 1.7 Reference Manual\n\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    char udata[key_bytes];\n    pad_or_truncate_password_V4(\"\", udata);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 1, false);\n    return std::string(udata, key_bytes);\n}",
      "line_statements": [
        [
          500,
          "    pad_short_parameter(k1, data.getLengthBytes());"
        ]
      ],
      "statements": [
        [
          500,
          "pad_short_parameter(k1, data.getLengthBytes());"
        ]
      ],
      "cve": "CVE-2017-18184"
    },
    {
      "commit_id": "8ec8ce7d3d58bf42dabc47e4cc53aa27051bd602",
      "filepath": "src/libbz3.c",
      "project": "bzip3",
      "project_repo_path": "symbol_backend_projects/bzip3",
      "is_vulnerable": true,
      "func_name": "bz3_decode_block",
      "func_body": "BZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8 * buffer, s32 data_size, s32 orig_size) {\n    // Read the header.\n    u32 crc32 = read_neutral_s32(buffer);\n    s32 bwt_idx = read_neutral_s32(buffer + 4);\n\n    if (data_size > bz3_bound(state->block_size) || data_size < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (bwt_idx == -1) {\n        if (data_size - 8 > 64) {\n            state->last_error = BZ3_ERR_MALFORMED_HEADER;\n            return -1;\n        }\n\n        memmove(buffer, buffer + 8, data_size - 8);\n\n        if (crc32sum(1, buffer, data_size - 8) != crc32) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n\n        return data_size - 8;\n    }\n\n    s8 model = buffer[8];\n    s32 lzp_size = -1, rle_size = -1, p = 0;\n\n    if (model & 2) lzp_size = read_neutral_s32(buffer + 9 + 4 * p++);\n    if (model & 4) rle_size = read_neutral_s32(buffer + 9 + 4 * p++);\n\n    p += 2;\n\n    data_size -= p * 4 + 1;\n\n    if (((model & 2) && (lzp_size > bz3_bound(state->block_size) || lzp_size < 0)) ||\n        ((model & 4) && (rle_size > bz3_bound(state->block_size) || rle_size < 0))) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (orig_size > bz3_bound(state->block_size) || orig_size < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    // Decode the data.\n    u8 *b1 = buffer, *b2 = state->swap_buffer;\n\n    begin(state->cm_state);\n    state->cm_state->in_queue = b1 + p * 4 + 1;\n    state->cm_state->input_ptr = 0;\n    state->cm_state->input_max = data_size;\n\n    s32 size_src;\n\n    if (model & 2)\n        size_src = lzp_size;\n    else if (model & 4)\n        size_src = rle_size;\n    else\n        size_src = orig_size;\n\n    decode_bytes(state->cm_state, b2, size_src);\n    swap(b1, b2);\n\n    if (bwt_idx >= size_src) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    // Undo BWT\n    if (libsais_unbwt(b1, b2, state->sais_array, size_src, NULL, bwt_idx) < 0) {\n        state->last_error = BZ3_ERR_BWT;\n        return -1;\n    }\n    swap(b1, b2);\n\n    // Undo LZP\n    if (model & 2) {\n        size_src = lzp_decompress(b1, b2, lzp_size, bz3_bound(state->block_size), state->lzp_lut);\n        if (size_src == -1) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n        swap(b1, b2);\n    }\n\n    if (model & 4) {\n        mrled(b1, b2, orig_size);\n        size_src = orig_size;\n        swap(b1, b2);\n    }\n\n    state->last_error = BZ3_OK;\n\n    if (size_src > bz3_bound(state->block_size) || size_src < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (b1 != buffer) memcpy(buffer, b1, size_src);\n\n    if (crc32 != crc32sum(1, buffer, size_src)) {\n        state->last_error = BZ3_ERR_CRC;\n        return -1;\n    }\n\n    return size_src;\n}",
      "line_statements": [
        [
          697,
          "        mrled(b1, b2, orig_size);"
        ]
      ],
      "statements": [
        [
          697,
          "mrled(b1, b2, orig_size);"
        ]
      ],
      "cve": "CVE-2023-29419"
    },
    {
      "commit_id": "5dc1860d8267b1e0cb78c9ffa2a40bea2fdb3ddc",
      "filepath": "print-pim.c",
      "project": "tcpdump",
      "project_repo_path": "symbol_backend_projects/tcpdump",
      "is_vulnerable": true,
      "func_name": "cisco_autorp_print",
      "func_body": "cisco_autorp_print(netdissect_options *ndo,\n                   register const u_char *bp, register u_int len)\n{\n\tint type;\n\tint numrps;\n\tint hold;\n\n\tND_TCHECK(bp[0]);\n\tND_PRINT((ndo, \" auto-rp \"));\n\ttype = bp[0];\n\tswitch (type) {\n\tcase 0x11:\n\t\tND_PRINT((ndo, \"candidate-advert\"));\n\t\tbreak;\n\tcase 0x12:\n\t\tND_PRINT((ndo, \"mapping\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"type-0x%02x\", type));\n\t\tbreak;\n\t}\n\n\tND_TCHECK(bp[1]);\n\tnumrps = bp[1];\n\n\tND_TCHECK2(bp[2], 2);\n\tND_PRINT((ndo, \" Hold \"));\n\thold = EXTRACT_16BITS(&bp[2]);\n\tif (hold)\n\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[2]));\n\telse\n\t\tND_PRINT((ndo, \"FOREVER\"));\n\n\t/* Next 4 bytes are reserved. */\n\n\tbp += 8; len -= 8;\n\n\t/*XXX skip unless -v? */\n\n\t/*\n\t * Rest of packet:\n\t * numrps entries of the form:\n\t * 32 bits: RP\n\t * 6 bits: reserved\n\t * 2 bits: PIM version supported, bit 0 is \"supports v1\", 1 is \"v2\".\n\t * 8 bits: # of entries for this RP\n\t * each entry: 7 bits: reserved, 1 bit: negative,\n\t *\t       8 bits: mask 32 bits: source\n\t * lather, rinse, repeat.\n\t */\n\twhile (numrps--) {\n\t\tint nentries;\n\t\tchar s;\n\n\t\tND_TCHECK2(bp[0], 4);\n\t\tND_PRINT((ndo, \" RP %s\", ipaddr_string(ndo, bp)));\n\t\tND_TCHECK(bp[4]);\n\t\tswitch (bp[4] & 0x3) {\n\t\tcase 0: ND_PRINT((ndo, \" PIMv?\"));\n\t\t\tbreak;\n\t\tcase 1:\tND_PRINT((ndo, \" PIMv1\"));\n\t\t\tbreak;\n\t\tcase 2:\tND_PRINT((ndo, \" PIMv2\"));\n\t\t\tbreak;\n\t\tcase 3:\tND_PRINT((ndo, \" PIMv1+2\"));\n\t\t\tbreak;\n\t\t}\n\t\tif (bp[4] & 0xfc)\n\t\t\tND_PRINT((ndo, \" [rsvd=0x%02x]\", bp[4] & 0xfc));\n\t\tND_TCHECK(bp[5]);\n\t\tnentries = bp[5];\n\t\tbp += 6; len -= 6;\n\t\ts = ' ';\n\t\tfor (; nentries; nentries--) {\n\t\t\tND_TCHECK2(bp[0], 6);\n\t\t\tND_PRINT((ndo, \"%c%s%s/%d\", s, bp[0] & 1 ? \"!\" : \"\",\n\t\t\t          ipaddr_string(ndo, &bp[2]), bp[1]));\n\t\t\tif (bp[0] & 0x02) {\n\t\t\t\tND_PRINT((ndo, \" bidir\"));\n\t\t\t}\n\t\t\tif (bp[0] & 0xfc) {\n\t\t\t\tND_PRINT((ndo, \"[rsvd=0x%02x]\", bp[0] & 0xfc));\n\t\t\t}\n\t\t\ts = ',';\n\t\t\tbp += 6; len -= 6;\n\t\t}\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|autorp]\"));\n\treturn;\n}",
      "line_statements": [
        [
          382,
          "\t\tND_TCHECK(bp[4]);"
        ],
        [
          383,
          "\t\tswitch (bp[4] & 0x3) {"
        ],
        [
          393,
          "\t\tif (bp[4] & 0xfc)"
        ],
        [
          394,
          "\t\t\tND_PRINT((ndo, \" [rsvd=0x%02x]\", bp[4] & 0xfc));"
        ],
        [
          395,
          "\t\tND_TCHECK(bp[5]);"
        ],
        [
          396,
          "\t\tnentries = bp[5];"
        ],
        [
          397,
          "\t\tbp += 6; len -= 6;"
        ]
      ],
      "statements": [
        [
          382,
          "ND_TCHECK(bp[4]);"
        ],
        [
          383,
          "switch (bp[4] & 0x3) {"
        ],
        [
          393,
          "if (bp[4] & 0xfc)"
        ],
        [
          394,
          "ND_PRINT((ndo, \" [rsvd=0x%02x]\", bp[4] & 0xfc));"
        ],
        [
          395,
          "ND_TCHECK(bp[5]);"
        ],
        [
          396,
          "nentries = bp[5];"
        ],
        [
          397,
          "\t\tbp += 6; len -= 6;\n"
        ]
      ],
      "cve": "CVE-2017-13030"
    },
    {
      "commit_id": "a1098f81c252b317ad34ea978aea2bc47760b215",
      "filepath": "library/ssl_cli.c",
      "project": "mbedtls",
      "project_repo_path": "symbol_backend_projects/mbedtls",
      "is_vulnerable": false,
      "func_name": "ssl_parse_server_key_exchange",
      "func_body": "static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    unsigned char *p = NULL, *end = NULL;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server key exchange\" ) );\n\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    ((void) p);\n    ((void) end);\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )\n    {\n        if( ( ret = ssl_get_ecdh_params_from_cert( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_get_ecdh_params_from_cert\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    ((void) p);\n    ((void) end);\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /*\n     * ServerKeyExchange may be skipped with PSK and RSA-PSK when the server\n     * doesn't use a psk_identity_hint\n     */\n    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )\n    {\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n            ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        {\n            /* Current message is probably either\n             * CertificateRequest or ServerHelloDone */\n            ssl->keep_current_message = 1;\n            goto exit;\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key exchange message must \"\n                                    \"not be skipped\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n    end = ssl->in_msg + ssl->in_hslen;\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"server key exchange\", p, end - p );\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n    {\n        if( ssl_parse_server_psk_hint( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    } /* FALLTROUGH */\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        ; /* nothing more to do */\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )\n    {\n        if( ssl_parse_server_dh_params( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )\n    {\n        if( ssl_parse_server_ecdh_params( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,\n                                              p, end - p );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_two\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )\n    {\n        size_t sig_len, hashlen;\n        unsigned char hash[64];\n        mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;\n        mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;\n        unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n        size_t params_len = p - params;\n\n        /*\n         * Handle the digitally-signed structure\n         */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            if( ssl_parse_signature_algorithm( ssl, &p, end,\n                                               &md_alg, &pk_alg ) != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n            }\n\n            if( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n            }\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            pk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );\n\n            /* Default hash for ECDSA is SHA-1 */\n            if( pk_alg == MBEDTLS_PK_ECDSA && md_alg == MBEDTLS_MD_NONE )\n                md_alg = MBEDTLS_MD_SHA1;\n        }\n        else\n#endif\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        /*\n         * Read signature\n         */\n\n        if( p > end - 2 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n        sig_len = ( p[0] << 8 ) | p[1];\n        p += 2;\n\n        if( end != p + sig_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"signature\", p, sig_len );\n\n        /*\n         * Compute the hash that has been signed\n         */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( md_alg == MBEDTLS_MD_NONE )\n        {\n            hashlen = 36;\n            ret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash, params,\n                                                           params_len );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( md_alg != MBEDTLS_MD_NONE )\n        {\n            /* Info from md_alg will be used instead */\n            hashlen = 0;\n            ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, params,\n                                                          params_len, md_alg );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_2 */\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"parameters hash\", hash, hashlen != 0 ? hashlen :\n            (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );\n\n        if( ssl->session_negotiate->peer_cert == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n        }\n\n        /*\n         * Verify signature\n         */\n        if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n        }\n\n        if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,\n                               md_alg, hash, hashlen, p, sig_len ) ) != 0 )\n        {\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR );\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_verify\", ret );\n            return( ret );\n        }\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */\n\nexit:\n    ssl->state++;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server key exchange\" ) );\n\n    return( 0 );\n}",
      "line_statements": [
        [
          2481,
          ""
        ],
        [
          2482,
          "        if( p > end - 2 )"
        ],
        [
          2483,
          "        {"
        ],
        [
          2484,
          "            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );"
        ],
        [
          2485,
          "            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,"
        ],
        [
          2486,
          "                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );"
        ],
        [
          2487,
          "            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );"
        ],
        [
          2488,
          "        }"
        ]
      ],
      "statements": [
        [
          2481,
          "\n"
        ],
        [
          2482,
          "if( p > end - 2 )"
        ],
        [
          2483,
          "        {\n"
        ],
        [
          2484,
          "MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );"
        ],
        [
          2485,
          "mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );"
        ],
        [
          2487,
          "return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );"
        ],
        [
          2488,
          "        }\n"
        ]
      ],
      "cve": "CVE-2018-9988"
    },
    {
      "commit_id": "92e470163d96df8db6c4fa0f484e4a229edb903d",
      "filepath": "fs/smb/server/asn1.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "ksmbd_neg_token_alloc",
      "func_body": "static int ksmbd_neg_token_alloc(void *context, size_t hdrlen,\n\t\t\t\t unsigned char tag, const void *value,\n\t\t\t\t size_t vlen)\n{\n\tstruct ksmbd_conn *conn = context;\n\n\tconn->mechToken = kmemdup_nul(value, vlen, GFP_KERNEL);\n\tif (!conn->mechToken)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2024-26594"
    },
    {
      "commit_id": "4f04351888a83e595571de672e0a4a8b74f4fb31",
      "filepath": "fs/ext4/super.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "ext4_group_desc_csum",
      "func_body": "static __le16 ext4_group_desc_csum(struct super_block *sb, __u32 block_group,\n\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tint offset = offsetof(struct ext4_group_desc, bg_checksum);\n\t__u16 crc = 0;\n\t__le32 le_group = cpu_to_le32(block_group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (ext4_has_metadata_csum(sbi->s_sb)) {\n\t\t/* Use new metadata_csum algorithm */\n\t\t__u32 csum32;\n\t\t__u16 dummy_csum = 0;\n\n\t\tcsum32 = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&le_group,\n\t\t\t\t     sizeof(le_group));\n\t\tcsum32 = ext4_chksum(sbi, csum32, (__u8 *)gdp, offset);\n\t\tcsum32 = ext4_chksum(sbi, csum32, (__u8 *)&dummy_csum,\n\t\t\t\t     sizeof(dummy_csum));\n\t\toffset += sizeof(dummy_csum);\n\t\tif (offset < sbi->s_desc_size)\n\t\t\tcsum32 = ext4_chksum(sbi, csum32, (__u8 *)gdp + offset,\n\t\t\t\t\t     sbi->s_desc_size - offset);\n\n\t\tcrc = csum32 & 0xFFFF;\n\t\tgoto out;\n\t}\n\n\t/* old crc16 code */\n\tif (!ext4_has_feature_gdt_csum(sb))\n\t\treturn 0;\n\n\tcrc = crc16(~0, sbi->s_es->s_uuid, sizeof(sbi->s_es->s_uuid));\n\tcrc = crc16(crc, (__u8 *)&le_group, sizeof(le_group));\n\tcrc = crc16(crc, (__u8 *)gdp, offset);\n\toffset += sizeof(gdp->bg_checksum); /* skip checksum */\n\t/* for checksum of struct ext4_group_desc do the rest...*/\n\tif (ext4_has_feature_64bit(sb) &&\n\t    offset < le16_to_cpu(sbi->s_es->s_desc_size))\n\t\tcrc = crc16(crc, (__u8 *)gdp + offset,\n\t\t\t    le16_to_cpu(sbi->s_es->s_desc_size) -\n\t\t\t\toffset);\n\nout:\n\treturn cpu_to_le16(crc);\n}\n",
      "line_statements": [
        [
          3243,
          "\tif (ext4_has_feature_64bit(sb) &&\n"
        ],
        [
          3244,
          "\t    offset < le16_to_cpu(sbi->s_es->s_desc_size))\n"
        ],
        [
          3246,
          "\t\t\t    le16_to_cpu(sbi->s_es->s_desc_size) -\n"
        ],
        [
          3247,
          "\t\t\t\toffset);\n"
        ]
      ],
      "statements": [
        [
          3243,
          "if (ext4_has_feature_64bit(sb) &&\n\t    offset < le16_to_cpu(sbi->s_es->s_desc_size))"
        ],
        [
          3245,
          "crc = crc16(crc, (__u8 *)gdp + offset,\n\t\t\t    le16_to_cpu(sbi->s_es->s_desc_size) -\n\t\t\t\toffset);"
        ],
        [
          3246,
          "le16_to_cpu(sbi->s_es->s_desc_size) -\n\t\t\t\toffset"
        ]
      ],
      "cve": "CVE-2023-34256"
    },
    {
      "commit_id": "60208765887f5f008b3b9a883f3addc8bdb9c134",
      "filepath": "libr/bin/format/mach0/mach0.c",
      "project": "radare2",
      "project_repo_path": "symbol_backend_projects/radare2",
      "is_vulnerable": true,
      "func_name": "MACH0_( get_imports)",
      "func_body": "struct import_t* MACH0_(get_imports)(struct MACH0_(obj_t)* bin) {\n\tstruct import_t *imports;\n\tint i, j, idx, stridx;\n\tconst char *symstr;\n\n\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)\n\t\treturn NULL;\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\tif (!(imports = malloc ((bin->dysymtab.nundefsym + 1) * sizeof (struct import_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = j = 0; i < bin->dysymtab.nundefsym; i++) {\n\t\tidx = bin->dysymtab.iundefsym + i;\n\t\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\t\tbprintf (\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");\n\t\t\tfree (imports);\n\t\t\treturn NULL;\n\t\t}\n\t\tstridx = bin->symtab[idx].n_strx;\n\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\tsymstr = (char *)bin->symstr + stridx;\n\t\t} else {\n\t\t\tsymstr = \"\";\n\t\t}\n\t\tif (!*symstr) {\n\t\t\tcontinue;\n\t\t}\n\t\t{\n\t\t\tint i = 0;\n\t\t\tint len = 0;\n\t\t\tchar *symstr_dup = NULL;\n\t\t\tlen = bin->symstrlen - stridx;\n\t\t\timports[j].name[0] = 0;\n\t\t\tif (len > 0) {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tif ((unsigned char)symstr[i] == 0xff || !symstr[i]) {\n\t\t\t\t\t\tlen = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsymstr_dup = r_str_ndup (symstr, len);\n\t\t\t\tif (symstr_dup) {\n\t\t\t\t\tr_str_ncpy (imports[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH);\n\t\t\t\t\tr_str_filter (imports[j].name, - 1);\n\t\t\t\t\timports[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;\n\t\t\t\t\tfree (symstr_dup);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\timports[j].ord = i;\n\t\timports[j++].last = 0;\n\t}\n\timports[j].last = 1;\n\n\tif (!bin->imports_by_ord_size) {\n\t\tif (j > 0) {\n\t\t\tbin->imports_by_ord_size = j;\n\t\t\tbin->imports_by_ord = (RBinImport**)calloc (j, sizeof (RBinImport*));\n\t\t} else {\n\t\t\tbin->imports_by_ord_size = 0;\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t}\n\n\treturn imports;\n}",
      "line_statements": [
        [
          1684,
          "\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)"
        ]
      ],
      "statements": [
        [
          1684,
          "if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)"
        ]
      ],
      "cve": "CVE-2018-11380"
    },
    {
      "commit_id": "cef25028de5ff872c2e1f0a6c562eb3ea9ecbce4",
      "filepath": "src/UriParse.c",
      "project": "uriparser",
      "project_repo_path": "symbol_backend_projects/uriparser",
      "is_vulnerable": false,
      "func_name": "URI_FUNC( ParseIPv6address2)",
      "func_body": "static const URI_CHAR * URI_FUNC(ParseIPv6address2)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tint zipperEver = 0;\n\tint quadsDone = 0;\n\tint digitCount = 0;\n\tunsigned char digitHistory[4];\n\tint ip4OctetsDone = 0;\n\n\tunsigned char quadsAfterZipper[14];\n\tint quadsAfterZipperCount = 0;\n\n\n\tfor (;;) {\n\t\tif (first >= afterLast) {\n\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Inside IPv4 part? */\n\t\tif (ip4OctetsDone > 0) {\n\t\t\t/* Eat rest of IPv4 address */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (*first) {\n\t\t\t\tcase URI_SET_DIGIT:\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount++] = (unsigned char)(9 + *first - _UT('9'));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT('.'):\n\t\t\t\t\tif ((ip4OctetsDone == 4) /* NOTE! */\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid digit or octet count */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4 + ip4OctetsDone] = uriGetOctetValue(digitHistory, digitCount);\n\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\tip4OctetsDone++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(']'):\n\t\t\t\t\tif ((ip4OctetsDone != 3) /* NOTE! */\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid digit or octet count */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\n\t\t\t\t\t/* Copy missing quads right before IPv4 */\n\t\t\t\t\tmemcpy(state->uri->hostData.ip6->data + 16 - 4 - 2 * quadsAfterZipperCount,\n\t\t\t\t\t\t\t\tquadsAfterZipper, 2 * quadsAfterZipperCount);\n\n\t\t\t\t\t/* Copy last IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4 + 3] = uriGetOctetValue(digitHistory, digitCount);\n\n\t\t\t\t\treturn first + 1;\n\n\t\t\t\tdefault:\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tfirst++;\n\n\t\t\t\tif (first >= afterLast) {\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* Eat while no dot in sight */\n\t\t\tint letterAmong = 0;\n\t\t\tint walking = 1;\n\t\t\tdo {\n\t\t\t\tswitch (*first) {\n\t\t\t\tcase URI_SET_HEX_LETTER_LOWER:\n\t\t\t\t\tletterAmong = 1;\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(15 + *first - _UT('f'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase URI_SET_HEX_LETTER_UPPER:\n\t\t\t\t\tletterAmong = 1;\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(15 + *first - _UT('F'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase URI_SET_DIGIT:\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(9 + *first - _UT('9'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(':'):\n\t\t\t\t\t{\n\t\t\t\t\t\tint setZipper = 0;\n\n\t\t\t\t\t\tif (digitCount > 0) {\n\t\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, quadsAfterZipper + 2 * quadsAfterZipperCount);\n\t\t\t\t\t\t\t\tquadsAfterZipperCount++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, state->uri->hostData.ip6->data + 2 * quadsDone);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tquadsDone++;\n\t\t\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tletterAmong = 0;\n\n\t\t\t\t\t\t/* Too many quads? */\n\t\t\t\t\t\tif (quadsDone >= 8 - zipperEver) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* \"::\"? */\n\t\t\t\t\t\tif (first + 1 >= afterLast) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (first[1] == _UT(':')) {\n\t\t\t\t\t\t\tconst int resetOffset = 2 * (quadsDone + (digitCount > 0));\n\n\t\t\t\t\t\t\tfirst++;\n\t\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* \"::.+::\" */\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Zero everything after zipper */\n\t\t\t\t\t\t\tmemset(state->uri->hostData.ip6->data + resetOffset, 0, 16 - resetOffset);\n\t\t\t\t\t\t\tsetZipper = 1;\n\n\t\t\t\t\t\t\t/* \":::+\"? */\n\t\t\t\t\t\t\tif (first + 1 >= afterLast) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* No ']' yet */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (first[1] == _UT(':')) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* \":::+ \"*/\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (setZipper) {\n\t\t\t\t\t\t\tzipperEver = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT('.'):\n\t\t\t\t\tif ((quadsDone > 6) /* NOTE */\n\t\t\t\t\t\t\t|| (!zipperEver && (quadsDone < 6))\n\t\t\t\t\t\t\t|| letterAmong\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid octet before */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy first IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4] = uriGetOctetValue(digitHistory, digitCount);\n\t\t\t\t\tdigitCount = 0;\n\n\t\t\t\t\t/* Switch over to IPv4 loop */\n\t\t\t\t\tip4OctetsDone = 1;\n\t\t\t\t\twalking = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(']'):\n\t\t\t\t\t/* Too little quads? */\n\t\t\t\t\tif (!zipperEver && !((quadsDone == 7) && (digitCount > 0))) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (digitCount > 0) {\n\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, quadsAfterZipper + 2 * quadsAfterZipperCount);\n\t\t\t\t\t\t\tquadsAfterZipperCount++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, state->uri->hostData.ip6->data + 2 * quadsDone);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tquadsDone++;\n\t\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy missing quads to the end */\n\t\t\t\t\tmemcpy(state->uri->hostData.ip6->data + 16 - 2 * quadsAfterZipperCount,\n\t\t\t\t\t\t\t\tquadsAfterZipper, 2 * quadsAfterZipperCount);\n\n\t\t\t\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\t\t\t\t\treturn first + 1; /* Fine */\n\n\t\t\t\tdefault:\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tfirst++;\n\n\t\t\t\tif (first >= afterLast) {\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL; /* No ']' yet */\n\t\t\t\t}\n\t\t\t} while (walking);\n\t\t}\n\t}\n}",
      "line_statements": [
        [
          695,
          ""
        ],
        [
          696,
          "\t\t\t\tif (first >= afterLast) {"
        ],
        [
          697,
          "\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);"
        ],
        [
          698,
          "\t\t\t\t\treturn NULL;"
        ],
        [
          699,
          "\t\t\t\t}"
        ]
      ],
      "statements": [
        [
          695,
          "\n"
        ],
        [
          696,
          "if (first >= afterLast)"
        ],
        [
          697,
          "URI_FUNC(StopSyntax)(state, first, memory);"
        ],
        [
          698,
          "return NULL;"
        ],
        [
          699,
          "\t\t\t\t}\n"
        ]
      ],
      "cve": "CVE-2018-20721"
    },
    {
      "commit_id": "dea704f0ab7f625e1e7b3f9a1110b45b63157317",
      "filepath": "libqpdf/QPDF_encryption.cc",
      "project": "qpdf",
      "project_repo_path": "symbol_backend_projects/qpdf",
      "is_vulnerable": true,
      "func_name": "QPDF::initializeEncryption",
      "func_body": "QPDF::initializeEncryption()\n{\n    if (this->m->encryption_initialized)\n    {\n\treturn;\n    }\n    this->m->encryption_initialized = true;\n\n    // After we initialize encryption parameters, we must used stored\n    // key information and never look at /Encrypt again.  Otherwise,\n    // things could go wrong if someone mutates the encryption\n    // dictionary.\n\n    if (! this->m->trailer.hasKey(\"/Encrypt\"))\n    {\n\treturn;\n    }\n\n    // Go ahead and set this->m->encrypted here.  That way, isEncrypted\n    // will return true even if there were errors reading the\n    // encryption dictionary.\n    this->m->encrypted = true;\n\n    std::string id1;\n    QPDFObjectHandle id_obj = this->m->trailer.getKey(\"/ID\");\n    if ((id_obj.isArray() &&\n         (id_obj.getArrayNItems() == 2) &&\n         id_obj.getArrayItem(0).isString()))\n    {\n        id1 = id_obj.getArrayItem(0).getStringValue();\n    }\n    else\n    {\n        // Treating a missing ID as the empty string enables qpdf to\n        // decrypt some invalid encrypted files with no /ID that\n        // poppler can read but Adobe Reader can't.\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                     \"trailer\", this->m->file->getLastOffset(),\n                     \"invalid /ID in trailer dictionary\"));\n    }\n\n    QPDFObjectHandle encryption_dict = this->m->trailer.getKey(\"/Encrypt\");\n    if (! encryption_dict.isDictionary())\n    {\n\tthrow QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t      this->m->last_object_description,\n\t\t      this->m->file->getLastOffset(),\n\t\t      \"/Encrypt in trailer dictionary is not a dictionary\");\n    }\n\n    if (! (encryption_dict.getKey(\"/Filter\").isName() &&\n\t   (encryption_dict.getKey(\"/Filter\").getName() == \"/Standard\")))\n    {\n\tthrow QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t      \"encryption dictionary\", this->m->file->getLastOffset(),\n\t\t      \"unsupported encryption filter\");\n    }\n    if (! encryption_dict.getKey(\"/SubFilter\").isNull())\n    {\n\twarn(QPDFExc(qpdf_e_unsupported, this->m->file->getName(),\n\t\t     \"encryption dictionary\", this->m->file->getLastOffset(),\n\t\t     \"file uses encryption SubFilters,\"\n\t\t     \" which qpdf does not support\"));\n    }\n\n    if (! (encryption_dict.getKey(\"/V\").isInteger() &&\n\t   encryption_dict.getKey(\"/R\").isInteger() &&\n\t   encryption_dict.getKey(\"/O\").isString() &&\n\t   encryption_dict.getKey(\"/U\").isString() &&\n\t   encryption_dict.getKey(\"/P\").isInteger()))\n    {\n\tthrow QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t      \"encryption dictionary\", this->m->file->getLastOffset(),\n\t\t      \"some encryption dictionary parameters are missing \"\n\t\t      \"or the wrong type\");\n    }\n\n    int V = encryption_dict.getKey(\"/V\").getIntValue();\n    int R = encryption_dict.getKey(\"/R\").getIntValue();\n    std::string O = encryption_dict.getKey(\"/O\").getStringValue();\n    std::string U = encryption_dict.getKey(\"/U\").getStringValue();\n    unsigned int P = encryption_dict.getKey(\"/P\").getIntValue();\n\n    // If supporting new encryption R/V values, remember to update\n    // error message inside this if statement.\n    if (! (((R >= 2) && (R <= 6)) &&\n\t   ((V == 1) || (V == 2) || (V == 4) || (V == 5))))\n    {\n\tthrow QPDFExc(qpdf_e_unsupported, this->m->file->getName(),\n\t\t      \"encryption dictionary\", this->m->file->getLastOffset(),\n\t\t      \"Unsupported /R or /V in encryption dictionary; R = \" +\n                      QUtil::int_to_string(R) + \" (max 6), V = \" +\n                      QUtil::int_to_string(V) + \" (max 5)\");\n    }\n\n    this->m->encryption_V = V;\n    this->m->encryption_R = R;\n\n    // OE, UE, and Perms are only present if V >= 5.\n    std::string OE;\n    std::string UE;\n    std::string Perms;\n\n    if (V < 5)\n    {\n        pad_short_parameter(O, key_bytes);\n        pad_short_parameter(U, key_bytes);\n        if (! ((O.length() == key_bytes) && (U.length() == key_bytes)))\n        {\n            throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                          \"encryption dictionary\",\n                          this->m->file->getLastOffset(),\n                          \"incorrect length for /O and/or /U in \"\n                          \"encryption dictionary\");\n        }\n    }\n    else\n    {\n        if (! (encryption_dict.getKey(\"/OE\").isString() &&\n               encryption_dict.getKey(\"/UE\").isString() &&\n               encryption_dict.getKey(\"/Perms\").isString()))\n        {\n            throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                          \"encryption dictionary\",\n                          this->m->file->getLastOffset(),\n                          \"some V=5 encryption dictionary parameters are \"\n                          \"missing or the wrong type\");\n        }\n        OE = encryption_dict.getKey(\"/OE\").getStringValue();\n        UE = encryption_dict.getKey(\"/UE\").getStringValue();\n        Perms = encryption_dict.getKey(\"/Perms\").getStringValue();\n\n        pad_short_parameter(O, OU_key_bytes_V5);\n        pad_short_parameter(U, OU_key_bytes_V5);\n        pad_short_parameter(OE, OUE_key_bytes_V5);\n        pad_short_parameter(UE, OUE_key_bytes_V5);\n        pad_short_parameter(Perms, Perms_key_bytes_V5);\n        if ((O.length() < OU_key_bytes_V5) ||\n            (U.length() < OU_key_bytes_V5) ||\n            (OE.length() < OUE_key_bytes_V5) ||\n            (UE.length() < OUE_key_bytes_V5) ||\n            (Perms.length() < Perms_key_bytes_V5))\n        {\n            throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                          \"encryption dictionary\",\n                          this->m->file->getLastOffset(),\n                          \"incorrect length for some of\"\n                          \" /O, /U, /OE, /UE, or /Perms in\"\n                          \" encryption dictionary\");\n        }\n    }\n\n    int Length = 40;\n    if (encryption_dict.getKey(\"/Length\").isInteger())\n    {\n\tLength = encryption_dict.getKey(\"/Length\").getIntValue();\n\tif ((Length % 8) || (Length < 40) || (Length > 256))\n\t{\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n\t\t\t  \"encryption dictionary\",\n                          this->m->file->getLastOffset(),\n\t\t\t  \"invalid /Length value in encryption dictionary\");\n\t}\n    }\n\n    this->m->encrypt_metadata = true;\n    if ((V >= 4) && (encryption_dict.getKey(\"/EncryptMetadata\").isBool()))\n    {\n\tthis->m->encrypt_metadata =\n\t    encryption_dict.getKey(\"/EncryptMetadata\").getBoolValue();\n    }\n\n    if ((V == 4) || (V == 5))\n    {\n\tQPDFObjectHandle CF = encryption_dict.getKey(\"/CF\");\n\tstd::set<std::string> keys = CF.getKeys();\n\tfor (std::set<std::string>::iterator iter = keys.begin();\n\t     iter != keys.end(); ++iter)\n\t{\n\t    std::string const& filter = *iter;\n\t    QPDFObjectHandle cdict = CF.getKey(filter);\n\t    if (cdict.isDictionary())\n\t    {\n\t\tencryption_method_e method = e_none;\n\t\tif (cdict.getKey(\"/CFM\").isName())\n\t\t{\n\t\t    std::string method_name = cdict.getKey(\"/CFM\").getName();\n\t\t    if (method_name == \"/V2\")\n\t\t    {\n\t\t\tQTC::TC(\"qpdf\", \"QPDF_encryption CFM V2\");\n\t\t\tmethod = e_rc4;\n\t\t    }\n\t\t    else if (method_name == \"/AESV2\")\n\t\t    {\n\t\t\tQTC::TC(\"qpdf\", \"QPDF_encryption CFM AESV2\");\n\t\t\tmethod = e_aes;\n\t\t    }\n\t\t    else if (method_name == \"/AESV3\")\n\t\t    {\n\t\t\tQTC::TC(\"qpdf\", \"QPDF_encryption CFM AESV3\");\n\t\t\tmethod = e_aesv3;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Don't complain now -- maybe we won't need\n\t\t\t// to reference this type.\n\t\t\tmethod = e_unknown;\n\t\t    }\n\t\t}\n\t\tthis->m->crypt_filters[filter] = method;\n\t    }\n\t}\n\n\tQPDFObjectHandle StmF = encryption_dict.getKey(\"/StmF\");\n\tQPDFObjectHandle StrF = encryption_dict.getKey(\"/StrF\");\n\tQPDFObjectHandle EFF = encryption_dict.getKey(\"/EFF\");\n\tthis->m->cf_stream = interpretCF(StmF);\n\tthis->m->cf_string = interpretCF(StrF);\n\tif (EFF.isName())\n\t{\n\t    this->m->cf_file = interpretCF(EFF);\n\t}\n\telse\n\t{\n\t    this->m->cf_file = this->m->cf_stream;\n\t}\n    }\n\n    EncryptionData data(V, R, Length / 8, P, O, U, OE, UE, Perms,\n                        id1, this->m->encrypt_metadata);\n    if (check_owner_password(\n\t    this->m->user_password, this->m->provided_password, data))\n    {\n\t// password supplied was owner password; user_password has\n\t// been initialized for V < 5\n    }\n    else if (check_user_password(this->m->provided_password, data))\n    {\n\tthis->m->user_password = this->m->provided_password;\n    }\n    else\n    {\n\tthrow QPDFExc(qpdf_e_password, this->m->file->getName(),\n\t\t      \"\", 0, \"invalid password\");\n    }\n\n    if (V < 5)\n    {\n        // For V < 5, the user password is encrypted with the owner\n        // password, and the user password is always used for\n        // computing the encryption key.\n        this->m->encryption_key = compute_encryption_key(\n            this->m->user_password, data);\n    }\n    else\n    {\n        // For V >= 5, either password can be used independently to\n        // compute the encryption key, and neither password can be\n        // used to recover the other.\n        bool perms_valid;\n        this->m->encryption_key = recover_encryption_key_with_password(\n            this->m->provided_password, data, perms_valid);\n        if (! perms_valid)\n        {\n            warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                         \"encryption dictionary\",\n                         this->m->file->getLastOffset(),\n                         \"/Perms field in encryption dictionary\"\n                         \" doesn't match expected value\"));\n        }\n    }\n}",
      "line_statements": [
        [
          921,
          "        if ((O.length() < OU_key_bytes_V5) ||"
        ],
        [
          922,
          "            (U.length() < OU_key_bytes_V5) ||"
        ],
        [
          923,
          "            (OE.length() < OUE_key_bytes_V5) ||"
        ],
        [
          924,
          "            (UE.length() < OUE_key_bytes_V5) ||"
        ],
        [
          925,
          "            (Perms.length() < Perms_key_bytes_V5))"
        ],
        [
          926,
          "        {"
        ],
        [
          927,
          "            throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),"
        ],
        [
          928,
          "                          \"encryption dictionary\","
        ],
        [
          929,
          "                          this->m->file->getLastOffset(),"
        ],
        [
          930,
          "                          \"incorrect length for some of\""
        ],
        [
          931,
          "                          \" /O, /U, /OE, /UE, or /Perms in\""
        ],
        [
          932,
          "                          \" encryption dictionary\");"
        ],
        [
          933,
          "        }"
        ]
      ],
      "statements": [
        [
          921,
          "if ((O.length() < OU_key_bytes_V5) ||\n            (U.length() < OU_key_bytes_V5) ||\n            (OE.length() < OUE_key_bytes_V5) ||\n            (UE.length() < OUE_key_bytes_V5) ||\n            (Perms.length() < Perms_key_bytes_V5))"
        ],
        [
          926,
          "        {\n"
        ],
        [
          927,
          "throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),\n                          \"encryption dictionary\",\n                          this->m->file->getLastOffset(),\n                          \"incorrect length for some of\"\n                          \" /O, /U, /OE, /UE, or /Perms in\"\n                          \" encryption dictionary\");"
        ],
        [
          933,
          "        }\n"
        ]
      ],
      "cve": "CVE-2017-18184"
    },
    {
      "commit_id": "b8caf69a6946e18ffebad49847e258f5b6d52ac2",
      "filepath": "drivers/tty/serial/qcom_geni_serial.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "qcom_geni_serial_port_setup",
      "func_body": "static int qcom_geni_serial_port_setup(struct uart_port *uport)\n{\n\tstruct qcom_geni_serial_port *port = to_dev_port(uport, uport);\n\tu32 rxstale = DEFAULT_BITS_PER_CHAR * STALE_TIMEOUT;\n\tu32 proto;\n\tu32 pin_swap;\n\n\tproto = geni_se_read_proto(&port->se);\n\tif (proto != GENI_SE_UART) {\n\t\tdev_err(uport->dev, \"Invalid FW loaded, proto: %d\\n\", proto);\n\t\treturn -ENXIO;\n\t}\n\n\tqcom_geni_serial_stop_rx(uport);\n\n\tget_tx_fifo_size(port);\n\n\twritel(rxstale, uport->membase + SE_UART_RX_STALE_CNT);\n\n\tpin_swap = readl(uport->membase + SE_UART_IO_MACRO_CTRL);\n\tif (port->rx_tx_swap) {\n\t\tpin_swap &= ~DEFAULT_IO_MACRO_IO2_IO3_MASK;\n\t\tpin_swap |= IO_MACRO_IO2_IO3_SWAP;\n\t}\n\tif (port->cts_rts_swap) {\n\t\tpin_swap &= ~DEFAULT_IO_MACRO_IO0_IO1_MASK;\n\t\tpin_swap |= IO_MACRO_IO0_SEL;\n\t}\n\t/* Configure this register if RX-TX, CTS-RTS pins are swapped */\n\tif (port->rx_tx_swap || port->cts_rts_swap)\n\t\twritel(pin_swap, uport->membase + SE_UART_IO_MACRO_CTRL);\n\n\t/*\n\t * Make an unconditional cancel on the main sequencer to reset\n\t * it else we could end up in data loss scenarios.\n\t */\n\tif (uart_console(uport))\n\t\tqcom_geni_serial_poll_tx_done(uport);\n\tgeni_se_config_packing(&port->se, BITS_PER_BYTE, BYTES_PER_FIFO_WORD,\n\t\t\t       false, true, true);\n\tgeni_se_init(&port->se, UART_RX_WM, port->rx_fifo_depth - 2);\n\tgeni_se_select_mode(&port->se, GENI_SE_FIFO);\n\tqcom_geni_serial_start_rx(uport);\n\tport->setup = true;\n\n\treturn 0;\n}\n",
      "line_statements": [
        [
          900,
          "\tget_tx_fifo_size(port);\n"
        ]
      ],
      "statements": [
        [
          900,
          "get_tx_fifo_size(port);"
        ]
      ],
      "cve": "CVE-2022-48871"
    },
    {
      "commit_id": "7d3aba9f06899d0128ef46e8a2fa143c6fad8f62",
      "filepath": "print-mobility.c",
      "project": "tcpdump",
      "project_repo_path": "symbol_backend_projects/tcpdump",
      "is_vulnerable": false,
      "func_name": "mobility_opt_print",
      "func_body": "mobility_opt_print(netdissect_options *ndo,\n                   const u_char *bp, const unsigned len)\n{\n\tunsigned i, optlen;\n\n\tfor (i = 0; i < len; i += optlen) {\n\t\tND_TCHECK(bp[i]);\n\t\tif (bp[i] == IP6MOPT_PAD1)\n\t\t\toptlen = 1;\n\t\telse {\n\t\t\tif (i + 1 < len) {\n\t\t\t\tND_TCHECK(bp[i + 1]);\n\t\t\t\toptlen = bp[i + 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tif (i + optlen > len)\n\t\t\tgoto trunc;\n\t\tND_TCHECK(bp[i + optlen]);\n\n\t\tswitch (bp[i]) {\n\t\tcase IP6MOPT_PAD1:\n\t\t\tND_PRINT((ndo, \"(pad1)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_PADN:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(padn: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(padn)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_REFRESH:\n\t\t\tif (len - i < IP6MOPT_REFRESH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(refresh: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\t/* units of 4 secs */\n\t\t\tND_TCHECK_16BITS(&bp[i+2]);\n\t\t\tND_PRINT((ndo, \"(refresh: %u)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n\t\t\tbreak;\n\t\tcase IP6MOPT_ALTCOA:\n\t\t\tif (len - i < IP6MOPT_ALTCOA_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(altcoa: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(alt-CoA: %s)\", ip6addr_string(ndo, &bp[i+2])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_NONCEID:\n\t\t\tif (len - i < IP6MOPT_NONCEID_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(ni: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_TCHECK_16BITS(&bp[i+2]);\n\t\t\tND_TCHECK_16BITS(&bp[i+4]);\n\t\t\tND_PRINT((ndo, \"(ni: ho=0x%04x co=0x%04x)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]),\n\t\t\t\tEXTRACT_16BITS(&bp[i+4])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_AUTH:\n\t\t\tif (len - i < IP6MOPT_AUTH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(auth: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(auth)\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(sopt_type %u: trunc)\", bp[i]));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(type-0x%02x: len=%u)\", bp[i], bp[i + 1]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\ntrunc:\n\treturn 1;\n}",
      "line_statements": [
        [
          169,
          "\t\t\tND_TCHECK_16BITS(&bp[i+2]);"
        ],
        [
          170,
          "\t\t\tND_TCHECK_16BITS(&bp[i+4]);"
        ]
      ],
      "statements": [
        [
          169,
          "ND_TCHECK_16BITS(&bp[i+2]);"
        ],
        [
          170,
          "ND_TCHECK_16BITS(&bp[i+4]);"
        ]
      ],
      "cve": "CVE-2017-13024"
    },
    {
      "commit_id": "4e1cf0d3e6f6fe2552a269def0af1cd2403e266c",
      "filepath": "libr/bin/format/pe/pe.c",
      "project": "radare2",
      "project_repo_path": "symbol_backend_projects/radare2",
      "is_vulnerable": true,
      "func_name": "get_nb10",
      "func_body": "static void get_nb10(ut8* dbg_data, SCV_NB10_HEADER* res) {\n\tconst int nb10sz = 16;\n\tmemcpy (res, dbg_data, nb10sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n}",
      "line_statements": [
        [
          2735,
          "\tmemcpy (res, dbg_data, nb10sz);"
        ],
        [
          2736,
          "\tres->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);"
        ]
      ],
      "statements": [
        [
          2735,
          "memcpy (res, dbg_data, nb10sz);"
        ],
        [
          2736,
          "res->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);"
        ]
      ],
      "cve": "CVE-2018-11379"
    }
  ],
  "CWE-416": [
    {
      "commit_id": "a0f1d21c1ccb1da66629627a74059dd7f5ac9c61",
      "filepath": "virt/kvm/kvm_main.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "kvm_ioctl_create_device",
      "func_body": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\n\tif (test)\n\t\treturn 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\n\tif (ops->init)\n\t\tops->init(dev);\n\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}\n",
      "line_statements": [
        [
          2892,
          "\t\tops->destroy(dev);\n"
        ]
      ],
      "statements": [
        [
          2892,
          "ops->destroy(dev);"
        ]
      ],
      "cve": "CVE-2016-10150"
    },
    {
      "commit_id": "31ed93a5623f24ca94e6d47e895ba735d9d97d46",
      "filepath": "src/njs_promise.c",
      "project": "njs",
      "project_repo_path": "symbol_backend_projects/njs",
      "is_vulnerable": false,
      "func_name": "njs_promise_perform_all_handler",
      "func_body": "njs_promise_perform_all_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_fulfilled;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n\n    pargs = (njs_promise_iterator_args_t *) args;\n\n    capability = pargs->capability;\n\n    array = args->data;\n    njs_set_undefined(&array->start[index]);\n\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    on_fulfilled = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_fulfilled == NULL)) {\n        return NJS_ERROR;\n    }\n\n    on_fulfilled->u.native = njs_promise_all_resolve_element_functions;\n    on_fulfilled->args_count = 1;\n\n    context = on_fulfilled->context;\n\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n\n    (*pargs->remaining)++;\n\n    njs_set_function(&arguments[0], on_fulfilled);\n    arguments[1] = capability->reject;\n\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    return NJS_OK;\n}",
      "line_statements": [
        [
          1372,
          "    if (!njs_is_valid(value)) {"
        ],
        [
          1373,
          "        value = njs_value_arg(&njs_value_undefined);"
        ],
        [
          1374,
          "    }"
        ],
        [
          1375,
          ""
        ]
      ],
      "statements": [
        [
          1372,
          "if (!njs_is_valid(value))"
        ],
        [
          1373,
          "value = njs_value_arg(&njs_value_undefined);"
        ],
        [
          1374,
          "    }\n"
        ],
        [
          1375,
          "\n"
        ]
      ],
      "cve": "CVE-2022-32414"
    },
    {
      "commit_id": "37f47958b8a2a44abc60614271d9537e7f14e51a",
      "filepath": "src/ex_cmds.c",
      "project": "vim",
      "project_repo_path": "symbol_backend_projects/vim",
      "is_vulnerable": false,
      "func_name": "ex_substitute",
      "func_body": "ex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    char_u\t*sub_copy = NULL;\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST, pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * If the substitute pattern starts with \"\\=\" then it's an expression.\n     * Make a copy, a recursive function may free it.\n     * Otherwise, '~' in the substitute pattern is replaced with the old\n     * pattern.  We do it here once to avoid it to be replaced over and over\n     * again.\n     */\n    if (sub[0] == '\\\\' && sub[1] == '=')\n    {\n\tsub = vim_strsave(sub);\n\tif (sub == NULL)\n\t    return;\n\tsub_copy = sub;\n    }\n    else\n\tsub = regtilde(sub, magic_isset());\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n#endif\n\t\t// get length of substitution part\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, FALSE, magic_isset(), TRUE);\n#ifdef FEAT_EVAL\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    if (sandbox > 0)\n\t\t\tsandbox--;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, TRUE, magic_isset(), TRUE);\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n    vim_free(sub_copy);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}",
      "line_statements": [
        [
          3690,
          "    char_u\t*sub_copy = NULL;"
        ],
        [
          3990,
          "    if (sub[0] == '\\\\' && sub[1] == '=')"
        ],
        [
          3991,
          "    {"
        ],
        [
          3992,
          "\tsub = vim_strsave(sub);"
        ],
        [
          3993,
          "\tif (sub == NULL)"
        ],
        [
          3994,
          "\t    return;"
        ],
        [
          3995,
          "\tsub_copy = sub;"
        ],
        [
          3996,
          "    }"
        ],
        [
          3997,
          "    else"
        ],
        [
          4803,
          "    vim_free(sub_copy);"
        ]
      ],
      "statements": [
        [
          3690,
          "char_u\t*sub_copy = NULL;"
        ],
        [
          3990,
          "if (sub[0] == '\\\\' && sub[1] == '=')"
        ],
        [
          3991,
          "    {\n"
        ],
        [
          3992,
          "sub = vim_strsave(sub);"
        ],
        [
          3993,
          "if (sub == NULL)"
        ],
        [
          3994,
          "return;"
        ],
        [
          3995,
          "sub_copy = sub;"
        ],
        [
          3996,
          "    }\n"
        ],
        [
          3997,
          "else"
        ],
        [
          4803,
          "vim_free(sub_copy);"
        ]
      ],
      "cve": "CVE-2022-0413"
    },
    {
      "commit_id": "2123adf8e5e1c2b48791f9d22fc8c747e974180e",
      "filepath": "libtransmission/variant.c",
      "project": "transmission",
      "project_repo_path": "symbol_backend_projects/transmission",
      "is_vulnerable": true,
      "func_name": "nodeDestruct",
      "func_body": "static void nodeDestruct(struct SaveNode* node)\n{\n    if (node->v == &node->sorted)\n    {\n        tr_free(node->sorted.val.l.vals);\n    }\n}",
      "line_statements": [
        [
          807,
          "    if (node->v == &node->sorted)"
        ],
        [
          809,
          "        tr_free(node->sorted.val.l.vals);"
        ]
      ],
      "statements": [
        [
          807,
          "if (node->v == &node->sorted)"
        ],
        [
          809,
          "tr_free(node->sorted.val.l.vals);"
        ]
      ],
      "cve": "CVE-2018-10756"
    },
    {
      "commit_id": "69c7b2fe4c9cc1d3b1186d1c5606627ecf0de883",
      "filepath": "net/ceph/mon_client.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "ceph_monc_stop",
      "func_body": "void ceph_monc_stop(struct ceph_mon_client *monc)\n{\n\tdout(\"stop\\n\");\n\n\tmutex_lock(&monc->mutex);\n\t__close_session(monc);\n\tmonc->hunting = false;\n\tmonc->cur_mon = -1;\n\tmutex_unlock(&monc->mutex);\n\n\tcancel_delayed_work_sync(&monc->delayed_work);\n\n\t/*\n\t * flush msgr queue before we destroy ourselves to ensure that:\n\t *  - any work that references our embedded con is finished.\n\t *  - any osd_client or other work that may reference an authorizer\n\t *    finishes before we shut down the auth subsystem.\n\t */\n\tceph_msgr_flush();\n\n\tceph_auth_destroy(monc->auth);\n\n\tWARN_ON(!RB_EMPTY_ROOT(&monc->generic_request_tree));\n\n\tceph_msg_put(monc->m_auth);\n\tceph_msg_put(monc->m_auth_reply);\n\tceph_msg_put(monc->m_subscribe);\n\tceph_msg_put(monc->m_subscribe_ack);\n\n\tkfree(monc->monmap);\n}\n",
      "line_statements": [
        [
          1246,
          "\tmonc->hunting = false;\n"
        ],
        [
          1250,
          "\tcancel_delayed_work_sync(&monc->delayed_work);\n"
        ],
        [
          1251,
          "\n"
        ]
      ],
      "statements": [
        [
          1246,
          "monc->hunting = false;"
        ],
        [
          1250,
          "cancel_delayed_work_sync(&monc->delayed_work);"
        ],
        [
          1251,
          "\n"
        ]
      ],
      "cve": "CVE-2024-42232"
    },
    {
      "commit_id": "c8bcd9c5be24fb9e6132e97da5a35e55a83e36b9",
      "filepath": "drivers/tty/tty_io.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "__do_SAK",
      "func_body": "void __do_SAK(struct tty_struct *tty)\n{\n// #ifdef TTY_SOFT_SAK\n\ttty_hangup(tty);\n#else\n\tstruct task_struct *g, *p;\n\tstruct pid *session;\n\tint\t\ti;\n\n\tif (!tty)\n\t\treturn;\n\tsession = tty->session;\n\n\ttty_ldisc_flush(tty);\n\n\ttty_driver_flush_buffer(tty);\n\n\tread_lock(&tasklist_lock);\n\t/* Kill the entire session */\n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\ttty_notice(tty, \"SAK: killed process %d (%s): by session\\n\",\n\t\t\t   task_pid_nr(p), p->comm);\n\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n\n\t/* Now kill any processes that happen to have the tty open */\n\tdo_each_thread(g, p) {\n\t\tif (p->signal->tty == tty) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by controlling tty\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_lock(p);\n\t\ti = iterate_fd(p->files, 0, this_tty, tty);\n\t\tif (i != 0) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by fd#%d\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm, i - 1);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t}\n\t\ttask_unlock(p);\n\t} while_each_thread(g, p);\n\tread_unlock(&tasklist_lock);\n#endif\n}\n",
      "line_statements": [
        [
          2903,
          "\tsession = tty->session;\n"
        ]
      ],
      "statements": [
        [
          2903,
          "session = tty->session;"
        ]
      ],
      "cve": "CVE-2020-29660"
    },
    {
      "commit_id": "6934da9238da947628be83635e365df41064b09b",
      "filepath": "fs/ext4/ext4_jbd2.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "__ext4_journal_stop",
      "func_body": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\n\tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n\t}\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = jbd2_journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}\n",
      "line_statements": [
        [
          92,
          "\t\terr = jbd2_journal_stop(handle);\n"
        ],
        [
          93,
          "\t\treturn handle->h_err ? handle->h_err : err;\n"
        ],
        [
          97,
          "\terr = handle->h_err;\n"
        ]
      ],
      "statements": [
        [
          92,
          "err = jbd2_journal_stop(handle);"
        ],
        [
          93,
          "return handle->h_err ? handle->h_err : err;"
        ],
        [
          97,
          "err = handle->h_err;"
        ]
      ],
      "cve": "CVE-2015-8961"
    },
    {
      "commit_id": "b90d77e5fd784ada62ddd714d15ee2400c28e1cf",
      "filepath": "kernel/bpf/arena.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "arena_vm_close",
      "func_body": "static void arena_vm_close(struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = vma->vm_file->private_data;\n\tstruct bpf_arena *arena = container_of(map, struct bpf_arena, map);\n\tstruct vma_list *vml = vma->vm_private_data;\n\n\tif (!atomic_dec_and_test(&vml->mmap_count))\n\t\treturn;\n\tguard(mutex)(&arena->lock);\n\t/* update link list under lock */\n\tlist_del(&vml->head);\n\tvma->vm_private_data = NULL;\n\tkfree(vml);\n}\n",
      "line_statements": [
        [
          243,
          "\tstruct vma_list *vml = vma->vm_private_data;\n"
        ],
        [
          245,
          "\tif (!atomic_dec_and_test(&vml->mmap_count))\n"
        ],
        [
          246,
          "\t\treturn;\n"
        ],
        [
          248,
          "\t/* update link list under lock */\n"
        ]
      ],
      "statements": [
        [
          243,
          "struct vma_list *vml = vma->vm_private_data;"
        ],
        [
          245,
          "if (!atomic_dec_and_test(&vml->mmap_count))"
        ],
        [
          246,
          "return;"
        ],
        [
          248,
          "/* update link list under lock */"
        ]
      ],
      "cve": "CVE-2024-42075"
    },
    {
      "commit_id": "c898afdc15645efb555acb6d85b484eb40a45409",
      "filepath": "fs/9p/vfs_dentry.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "v9fs_dentry_release",
      "func_body": "static void v9fs_dentry_release(struct dentry *dentry)\n{\n\tstruct hlist_node *p, *n;\n\n\tp9_debug(P9_DEBUG_VFS, \" dentry: %pd (%p)\\n\",\n\t\t dentry, dentry);\n\thlist_for_each_safe(p, n, (struct hlist_head *)&dentry->d_fsdata)\n\t\tp9_fid_put(hlist_entry(p, struct p9_fid, dlist));\n\tdentry->d_fsdata = NULL;\n}\n",
      "line_statements": [
        [
          54,
          "\thlist_for_each_safe(p, n, (struct hlist_head *)&dentry->d_fsdata)\n"
        ],
        [
          56,
          "\tdentry->d_fsdata = NULL;\n"
        ]
      ],
      "statements": [
        [
          54,
          "hlist_for_each_safe(p, n, (struct hlist_head *)&dentry->d_fsdata)"
        ],
        [
          56,
          "dentry->d_fsdata = NULL;"
        ]
      ],
      "cve": "CVE-2024-39463"
    },
    {
      "commit_id": "7f4a9a9b2a49547eae24d2e19bc5c346e9026479",
      "filepath": "lib/multi.c",
      "project": "curl",
      "project_repo_path": "symbol_backend_projects/curl",
      "is_vulnerable": false,
      "func_name": "Curl_detach_connnection",
      "func_body": "void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn) {\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n    Curl_ssl_detach_conn(data, conn);\n  }\n  data->conn = NULL;\n}",
      "line_statements": [
        [
          881,
          "  if(conn) {"
        ],
        [
          883,
          "    Curl_ssl_detach_conn(data, conn);"
        ],
        [
          884,
          "  }"
        ]
      ],
      "statements": [
        [
          881,
          "if(conn)"
        ],
        [
          883,
          "Curl_ssl_detach_conn(data, conn);"
        ],
        [
          884,
          "  }\n"
        ]
      ],
      "cve": "CVE-2021-22901"
    },
    {
      "commit_id": "e2fa213cf571041dbd04ab0329303ffdc980678a",
      "filepath": "src/normal.c",
      "project": "vim",
      "project_repo_path": "symbol_backend_projects/vim",
      "is_vulnerable": false,
      "func_name": "nv_brackets",
      "func_body": "nv_brackets(cmdarg_T *cap)\n{\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n#ifdef FEAT_SEARCHPATH\n    // \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n#endif\n\n#ifdef FEAT_FIND_ID\n    // Find the occurrence(s) of the identifier or define under cursor\n    // in current and included files or jump to the first occurrence.\n    //\n    //\t\t\tsearch\t     list\t    jump\n    //\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n    // identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n    // define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n    if (vim_strchr((char_u *)\"iI\\011dD\\004\", cap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    // Make a copy, if the line was changed it will be freed.\n\t    ptr = vim_strnsave(ptr, len);\n\t    if (ptr == NULL)\n\t\treturn;\n\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    vim_free(ptr);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    // \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n    // \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n    // \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n    // \"[m\" or \"]m\" search for prev/next start of (Java) method.\n    // \"[M\" or \"]M\" search for prev/next end of (Java) method.\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n\tnv_bracket_block(cap, &old_pos);\n\n    // \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t// Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t// we also stop at '}'.\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    // \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    // \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    // [ or ] followed by a middle mouse click: put selected text with\n    // indent adjustment.  Any other button just does as usual.\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    // \"[z\" and \"]z\": move to start or end of open fold.\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // \"[c\" and \"]c\": move to next or previous diff-change.\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}",
      "line_statements": [
        [
          4468,
          "\t    ptr = vim_strnsave(ptr, len);"
        ],
        [
          4469,
          "\t    if (ptr == NULL)"
        ],
        [
          4470,
          "\t\treturn;"
        ],
        [
          4471,
          ""
        ],
        [
          4480,
          "\t    vim_free(ptr);"
        ]
      ],
      "statements": [
        [
          4468,
          "ptr = vim_strnsave(ptr, len);"
        ],
        [
          4469,
          "if (ptr == NULL)"
        ],
        [
          4470,
          "return;"
        ],
        [
          4471,
          "\n"
        ],
        [
          4480,
          "vim_free(ptr);"
        ]
      ],
      "cve": "CVE-2022-1898"
    },
    {
      "commit_id": "b88393f08a558eec14964a55d3c680fe67407712",
      "filepath": "ext/wddx/wddx.c",
      "project": "php-src",
      "project_repo_path": "symbol_backend_projects/php-src",
      "is_vulnerable": true,
      "func_name": "wddx_stack_destroy",
      "func_body": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;",
      "line_statements": [
        [
          233,
          "\t\t\tif (((st_entry *)stack->elements[i])->data)\t{"
        ]
      ],
      "statements": [
        [
          233,
          "if (((st_entry *)stack->elements[i])->data)"
        ]
      ],
      "cve": "CVE-2016-7413"
    },
    {
      "commit_id": "a58d9166a756a0f4a6618e4f593232593d6df134",
      "filepath": "arch/x86/kvm/svm/nested.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "nested_svm_vmrun",
      "func_body": "int nested_svm_vmrun(struct vcpu_svm *svm)\n{\n\tint ret;\n\tstruct vmcb *vmcb12;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_host_map map;\n\tu64 vmcb12_gpa;\n\n\tif (is_smm(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmcb12_gpa = svm->vmcb->save.rax;\n\tret = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(vmcb12_gpa), &map);\n\tif (ret == -EINVAL) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t} else if (ret) {\n\t\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n\t}\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\n\tvmcb12 = map.hva;\n\n\tif (WARN_ON_ONCE(!svm->nested.initialized))\n\t\treturn -EINVAL;\n\n\tload_nested_vmcb_control(svm, &vmcb12->control);\n\n\tif (!nested_vmcb_check_save(svm, vmcb12) ||\n\t    !nested_vmcb_check_controls(&svm->nested.ctl)) {\n\t\tvmcb12->control.exit_code    = SVM_EXIT_ERR;\n\t\tvmcb12->control.exit_code_hi = 0;\n\t\tvmcb12->control.exit_info_1  = 0;\n\t\tvmcb12->control.exit_info_2  = 0;\n\t\tgoto out;\n\t}\n\n\ttrace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb12_gpa,\n\t\t\t       vmcb12->save.rip,\n\t\t\t       vmcb12->control.int_ctl,\n\t\t\t       vmcb12->control.event_inj,\n\t\t\t       vmcb12->control.nested_ctl);\n\n\ttrace_kvm_nested_intercepts(vmcb12->control.intercepts[INTERCEPT_CR] & 0xffff,\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_CR] >> 16,\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_EXCEPTION],\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD3],\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD4],\n\t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD5]);\n\n\t/* Clear internal status */\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\t/*\n\t * Save the old vmcb, so we don't need to pick what we save, but can\n\t * restore everything when a VMEXIT occurs\n\t */\n\thsave->save.es     = vmcb->save.es;\n\thsave->save.cs     = vmcb->save.cs;\n\thsave->save.ss     = vmcb->save.ss;\n\thsave->save.ds     = vmcb->save.ds;\n\thsave->save.gdtr   = vmcb->save.gdtr;\n\thsave->save.idtr   = vmcb->save.idtr;\n\thsave->save.efer   = svm->vcpu.arch.efer;\n\thsave->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\thsave->save.cr4    = svm->vcpu.arch.cr4;\n\thsave->save.rflags = kvm_get_rflags(&svm->vcpu);\n\thsave->save.rip    = kvm_rip_read(&svm->vcpu);\n\thsave->save.rsp    = vmcb->save.rsp;\n\thsave->save.rax    = vmcb->save.rax;\n\tif (npt_enabled)\n\t\thsave->save.cr3    = vmcb->save.cr3;\n\telse\n\t\thsave->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\n\tcopy_vmcb_control_area(&hsave->control, &vmcb->control);\n\n\tsvm->nested.nested_run_pending = 1;\n\n\tif (enter_svm_guest_mode(svm, vmcb12_gpa, vmcb12))\n\t\tgoto out_exit_err;\n\n\tif (nested_svm_vmrun_msrpm(svm))\n\t\tgoto out;\n\nout_exit_err:\n\tsvm->nested.nested_run_pending = 0;\n\n\tsvm->vmcb->control.exit_code    = SVM_EXIT_ERR;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1  = 0;\n\tsvm->vmcb->control.exit_info_2  = 0;\n\n\tnested_svm_vmexit(svm);\n\nout:\n\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\treturn ret;\n}\n",
      "line_statements": [
        [
          486,
          "\tload_nested_vmcb_control(svm, &vmcb12->control);\n"
        ],
        [
          487,
          "\n"
        ],
        [
          488,
          "\tif (!nested_vmcb_check_save(svm, vmcb12) ||\n"
        ],
        [
          489,
          "\t    !nested_vmcb_check_controls(&svm->nested.ctl)) {\n"
        ]
      ],
      "statements": [
        [
          486,
          "load_nested_vmcb_control(svm, &vmcb12->control);"
        ],
        [
          487,
          "\n"
        ],
        [
          488,
          "if (!nested_vmcb_check_save(svm, vmcb12) ||\n\t    !nested_vmcb_check_controls(&svm->nested.ctl))"
        ]
      ],
      "cve": "CVE-2021-29657"
    },
    {
      "commit_id": "687cb0884a714ff484d038e9190edc874edcf146",
      "filepath": "mm/oom_kill.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "__oom_reap_task_mm",
      "func_body": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * We have to make sure to not race with the victim exit path\n\t * and cause premature new oom victim selection:\n\t * __oom_reap_task_mm\t\texit_mm\n\t *   mmget_not_zero\n\t *\t\t\t\t  mmput\n\t *\t\t\t\t    atomic_dec_and_test\n\t *\t\t\t\t  exit_oom_victim\n\t *\t\t\t\t[...]\n\t *\t\t\t\tout_of_memory\n\t *\t\t\t\t  select_bad_process\n\t *\t\t\t\t    # no TIF_MEMDIE task selects new victim\n\t *  unmap_page_range # frees some memory\n\t */\n\tmutex_lock(&oom_lock);\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * If the mm has notifiers then we would need to invalidate them around\n\t * unmap_page_range and that is risky because notifiers can sleep and\n\t * what they do is basically undeterministic.  So let's have a short\n\t * sleep to give the oom victim some more time.\n\t * TODO: we really want to get rid of this ugly hack and make sure that\n\t * notifiers cannot block for unbounded amount of time and add\n\t * mmu_notifier_invalidate_range_{start,end} around unmap_page_range\n\t */\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't\n\t * work on the mm anymore. The check for MMF_OOM_SKIP must run\n\t * under mmap_sem for reading because it serializes against the\n\t * down_write();up_write() cycle in exit_mmap().\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\ttrace_start_task_reaping(tsk->pid);\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n\t */\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n\t\t * we do not want to block exit_mmap by keeping mm ref\n\t\t * count elevated without a good reason.\n\t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}\n",
      "line_statements": [
        [
          553,
          "\ttlb_gather_mmu(&tlb, mm, 0, -1);\n"
        ],
        [
          568,
          "\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n"
        ],
        [
          572,
          "\ttlb_finish_mmu(&tlb, 0, -1);\n"
        ]
      ],
      "statements": [
        [
          553,
          "tlb_gather_mmu(&tlb, mm, 0, -1);"
        ],
        [
          568,
          "if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))"
        ],
        [
          572,
          "tlb_finish_mmu(&tlb, 0, -1);"
        ]
      ],
      "cve": "CVE-2017-18202"
    },
    {
      "commit_id": "860f025468feb31c43227153d8fb3f34210a522e",
      "filepath": "src/request-handler.cpp",
      "project": "drachtio-server",
      "project_repo_path": "symbol_backend_projects/drachtio-server",
      "is_vulnerable": false,
      "func_name": "drachtio::RequestHandler::startRequest",
      "func_body": "  void RequestHandler::startRequest(const string& transactionId, \n    const string& httpMethod, const string& url, const string& body, bool verifyPeer) {\n\n    RequestHandler::ConnInfo *conn;\n    CURLMcode rc;\n\n    if (0 == url.find(\"tcp://\") || 0 == url.find(\"tls://\")) {\n      string json = \"{\\\"action\\\": \\\"route\\\", \\\"data\\\": {\\\"uri\\\": \\\"\";\n      json.append(url.substr(6));\n      if (0 == url.find(\"tcp://\")) json.append(\";transport=tcp\");\n      else json.append(\";transport=tls\");\n      json.append(\"\\\"}}\");\n      DR_LOG(log_info) << \"RequestHandler::startRequest: no web callback required, sending directly to \" << url << \":\" << json.c_str() ;\n      m_pController->httpCallRoutingComplete(transactionId, 200, json);\n      return;\n    }\n\n\n    DR_LOG(log_info) << \"RequestHandler::startRequest: sending http \" << httpMethod << \": \" << url ;\n\n    conn = m_pool.malloc() ;\n    CURL* easy = NULL ;\n    {\n      //alloc and free happen in the same thread\n      //std::lock_guard<std::mutex> l( m_lock ) ;\n      if( m_cacheEasyHandles.empty() ) {\n        m_cacheEasyHandles.push_back(createEasyHandle()) ;\n      }\n      easy = m_cacheEasyHandles.front() ;\n      m_cacheEasyHandles.pop_front() ;\n      DR_LOG(log_debug) << \"RequestHandler::makeRequestForRoute - after acquiring handle in thread \" << \n        std::this_thread::get_id() << \" \" << dec <<\n        m_cacheEasyHandles.size() << \" handles remain in cache\";\n    }\n\n    conn->easy = easy;\n\n    conn->global = &m_g;\n    strncpy(conn->url, url.c_str(), URL_LEN) ;\n    strncpy(conn->body, body.c_str(), HTTP_BODY_LEN);\n    strncpy(conn->transactionId, transactionId.c_str(), TXNID_LEN);\n    conn->hdr_list = NULL ;\n    *conn->response = '\\0' ;\n\n    curl_easy_setopt(easy, CURLOPT_URL, conn->url);\n    curl_easy_setopt(easy, CURLOPT_WRITEFUNCTION, write_cb);\n    curl_easy_setopt(easy, CURLOPT_WRITEDATA, conn);\n    curl_easy_setopt(easy, CURLOPT_ERRORBUFFER, conn->error);\n    curl_easy_setopt(easy, CURLOPT_PRIVATE, conn);\n    //curl_easy_setopt(easy, CURLOPT_PROGRESSFUNCTION, prog_cb);\n    //curl_easy_setopt(easy, CURLOPT_PROGRESSDATA, conn);\n    //curl_easy_setopt(easy, CURLOPT_LOW_SPEED_TIME, 3L);\n    //curl_easy_setopt(easy, CURLOPT_LOW_SPEED_LIMIT, 10L);\n    //curl_easy_setopt(easy, CURLOPT_DEBUGFUNCTION, debug_callback);\n    //curl_easy_setopt(easy, CURLOPT_DEBUGDATA, &conn);\n    curl_easy_setopt(easy, CURLOPT_VERBOSE, 0L);\n    curl_easy_setopt(easy, CURLOPT_NOPROGRESS, 1L);\n    //curl_easy_setopt(easy, CURLOPT_HEADERFUNCTION, header_callback);\n    //curl_easy_setopt(easy, CURLOPT_HEADERDATA, conn);\n\n    \n    /* call this function to get a socket */\n    curl_easy_setopt(easy, CURLOPT_OPENSOCKETFUNCTION, opensocket);\n\n    /* call this function to close a socket */\n    curl_easy_setopt(easy, CURLOPT_CLOSESOCKETFUNCTION, close_socket);\n\n    if( 0 == url.find(\"https:\") ) {\n      curl_easy_setopt(easy, CURLOPT_SSL_VERIFYPEER, verifyPeer);\n    }\n\n    conn->hdr_list = curl_slist_append(conn->hdr_list, \"Accept: application/json\");\n    \n    if( 0 == httpMethod.compare(\"POST\") ) {\n      curl_easy_setopt(easy, CURLOPT_POSTFIELDS, conn->body);\n      curl_easy_setopt(easy, CURLOPT_POSTFIELDSIZE, strlen(conn->body));\n      conn->hdr_list = curl_slist_append(conn->hdr_list, \"Content-Type: text/plain; charset=UTF-8\");\n    }\n    curl_easy_setopt(easy, CURLOPT_HTTPHEADER, conn->hdr_list);\n\n    rc = curl_multi_add_handle(m_g.multi, conn->easy);\n    mcode_test(\"new_conn: curl_multi_add_handle\", rc);\n\n    /* note that the add_handle() will set a time-out to trigger very soon so\n       that the necessary socket_action() call will be called by this app */\n  }",
      "line_statements": [
        [
          501,
          "    *conn->response = '\\0' ;"
        ]
      ],
      "statements": [
        [
          501,
          "*conn->response = '\\0' ;"
        ]
      ],
      "cve": "CVE-2022-45474"
    },
    {
      "commit_id": "d86e185e485b6330216dee8e854455c694e3a36e",
      "filepath": "lib/VM/Interpreter.cpp",
      "project": "hermes",
      "project_repo_path": "symbol_backend_projects/hermes",
      "is_vulnerable": true,
      "func_name": "hermes::vm::transientObjectPutErrorMessage",
      "func_body": "transientObjectPutErrorMessage(Runtime *runtime, Handle<> base, SymbolID id) {\n  // Emit an error message that looks like:\n  // \"Cannot create property '%{id}' on ${typeof base} '${String(base)}'\".\n  StringView propName =\n      runtime->getIdentifierTable().getStringView(runtime, id);\n  Handle<StringPrimitive> baseType =\n      runtime->makeHandle(vmcast<StringPrimitive>(typeOf(runtime, base)));\n  StringView baseTypeAsString =\n      StringPrimitive::createStringView(runtime, baseType);\n  MutableHandle<StringPrimitive> valueAsString{runtime};\n  if (base->isSymbol()) {\n    // Special workaround for Symbol which can't be stringified.\n    auto str = symbolDescriptiveString(runtime, Handle<SymbolID>::vmcast(base));\n    if (str != ExecutionStatus::EXCEPTION) {\n      valueAsString = *str;\n    } else {\n      runtime->clearThrownValue();\n      valueAsString = StringPrimitive::createNoThrow(\n          runtime, \"<<Exception occurred getting the value>>\");\n    }\n  } else {\n    auto str = toString_RJS(runtime, base);\n    assert(\n        str != ExecutionStatus::EXCEPTION &&\n        \"Primitives should be convertible to string without exceptions\");\n    valueAsString = std::move(*str);\n  }\n  StringView valueAsStringPrintable =\n      StringPrimitive::createStringView(runtime, valueAsString);\n\n  SmallU16String<32> tmp;\n  return runtime->raiseTypeError(\n      TwineChar16(\"Cannot create property '\") + propName + \"' on \" +\n      baseTypeAsString.getUTF16Ref(tmp) + \" '\" +\n      valueAsStringPrintable.getUTF16Ref(tmp) + \"'\");\n}",
      "line_statements": [
        [
          448,
          "  SmallU16String<32> tmp;"
        ],
        [
          451,
          "      baseTypeAsString.getUTF16Ref(tmp) + \" '\" +"
        ],
        [
          452,
          "      valueAsStringPrintable.getUTF16Ref(tmp) + \"'\");"
        ]
      ],
      "statements": [
        [
          448,
          "SmallU16String<32> tmp;"
        ],
        [
          449,
          "return runtime->raiseTypeError(\n      TwineChar16(\"Cannot create property '\") + propName + \"' on \" +\n      baseTypeAsString.getUTF16Ref(tmp) + \" '\" +\n      valueAsStringPrintable.getUTF16Ref(tmp) + \"'\");"
        ],
        [
          450,
          "TwineChar16(\"Cannot create property '\") + propName + \"' on \" +\n      baseTypeAsString.getUTF16Ref(tmp) + \" '\" +\n      valueAsStringPrintable.getUTF16Ref(tmp) + \"'\""
        ]
      ],
      "cve": "CVE-2021-24037"
    },
    {
      "commit_id": "47c29d69212911f50bdcdd0564b5999a559010d4",
      "filepath": "drivers/power/supply/bq24190_charger.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "bq24190_remove",
      "func_body": "static void bq24190_remove(struct i2c_client *client)\n{\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\tint error;\n\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0)\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\n\tbq24190_register_reset(bdi);\n\tif (bdi->battery)\n\t\tpower_supply_unregister(bdi->battery);\n\tpower_supply_unregister(bdi->charger);\n\tif (error >= 0)\n\t\tpm_runtime_put_sync(bdi->dev);\n\tpm_runtime_dont_use_autosuspend(bdi->dev);\n\tpm_runtime_disable(bdi->dev);\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2023-33288"
    },
    {
      "commit_id": "22e9f71072fa605cbf033158db58e0790101928d",
      "filepath": "drivers/infiniband/core/cma.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "cma_bind_addr",
      "func_body": "static int cma_bind_addr(struct rdma_cm_id *id, struct sockaddr *src_addr,\n\t\t\t const struct sockaddr *dst_addr)\n{\n\tif (!src_addr || !src_addr->sa_family) {\n\t\tsrc_addr = (struct sockaddr *) &id->route.addr.src_addr;\n\t\tsrc_addr->sa_family = dst_addr->sa_family;\n\t\tif (IS_ENABLED(CONFIG_IPV6) &&\n\t\t    dst_addr->sa_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6 *src_addr6 = (struct sockaddr_in6 *) src_addr;\n\t\t\tstruct sockaddr_in6 *dst_addr6 = (struct sockaddr_in6 *) dst_addr;\n\t\t\tsrc_addr6->sin6_scope_id = dst_addr6->sin6_scope_id;\n\t\t\tif (ipv6_addr_type(&dst_addr6->sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\t\tid->route.addr.dev_addr.bound_dev_if = dst_addr6->sin6_scope_id;\n\t\t} else if (dst_addr->sa_family == AF_IB) {\n\t\t\t((struct sockaddr_ib *) src_addr)->sib_pkey =\n\t\t\t\t((struct sockaddr_ib *) dst_addr)->sib_pkey;\n\t\t}\n\t}\n\treturn rdma_bind_addr(id, src_addr);\n}\n",
      "line_statements": [
        [
          3373,
          "\tif (!src_addr || !src_addr->sa_family) {\n"
        ],
        [
          3374,
          "\t\tsrc_addr = (struct sockaddr *) &id->route.addr.src_addr;\n"
        ],
        [
          3375,
          "\t\tsrc_addr->sa_family = dst_addr->sa_family;\n"
        ],
        [
          3376,
          "\t\tif (IS_ENABLED(CONFIG_IPV6) &&\n"
        ],
        [
          3377,
          "\t\t    dst_addr->sa_family == AF_INET6) {\n"
        ],
        [
          3378,
          "\t\t\tstruct sockaddr_in6 *src_addr6 = (struct sockaddr_in6 *) src_addr;\n"
        ],
        [
          3379,
          "\t\t\tstruct sockaddr_in6 *dst_addr6 = (struct sockaddr_in6 *) dst_addr;\n"
        ],
        [
          3380,
          "\t\t\tsrc_addr6->sin6_scope_id = dst_addr6->sin6_scope_id;\n"
        ],
        [
          3381,
          "\t\t\tif (ipv6_addr_type(&dst_addr6->sin6_addr) & IPV6_ADDR_LINKLOCAL)\n"
        ],
        [
          3382,
          "\t\t\t\tid->route.addr.dev_addr.bound_dev_if = dst_addr6->sin6_scope_id;\n"
        ],
        [
          3383,
          "\t\t} else if (dst_addr->sa_family == AF_IB) {\n"
        ],
        [
          3384,
          "\t\t\t((struct sockaddr_ib *) src_addr)->sib_pkey =\n"
        ],
        [
          3385,
          "\t\t\t\t((struct sockaddr_ib *) dst_addr)->sib_pkey;\n"
        ],
        [
          3386,
          "\t\t}\n"
        ],
        [
          3387,
          "\t}\n"
        ],
        [
          3388,
          "\treturn rdma_bind_addr(id, src_addr);\n"
        ]
      ],
      "statements": [
        [
          3373,
          "if (!src_addr || !src_addr->sa_family)"
        ],
        [
          3374,
          "src_addr = (struct sockaddr *) &id->route.addr.src_addr;"
        ],
        [
          3375,
          "src_addr->sa_family = dst_addr->sa_family;"
        ],
        [
          3376,
          "if (IS_ENABLED(CONFIG_IPV6) &&\n\t\t    dst_addr->sa_family == AF_INET6)"
        ],
        [
          3378,
          "struct sockaddr_in6 *src_addr6 = (struct sockaddr_in6 *) src_addr;"
        ],
        [
          3379,
          "struct sockaddr_in6 *dst_addr6 = (struct sockaddr_in6 *) dst_addr;"
        ],
        [
          3380,
          "src_addr6->sin6_scope_id = dst_addr6->sin6_scope_id;"
        ],
        [
          3381,
          "if (ipv6_addr_type(&dst_addr6->sin6_addr) & IPV6_ADDR_LINKLOCAL)"
        ],
        [
          3382,
          "id->route.addr.dev_addr.bound_dev_if = dst_addr6->sin6_scope_id;"
        ],
        [
          3383,
          "else if (dst_addr->sa_family == AF_IB)"
        ],
        [
          3384,
          "((struct sockaddr_ib *) src_addr)->sib_pkey =\n\t\t\t\t((struct sockaddr_ib *) dst_addr)->sib_pkey;"
        ],
        [
          3386,
          "\t\t}\n"
        ],
        [
          3387,
          "\t}\n"
        ],
        [
          3388,
          "return rdma_bind_addr(id, src_addr);"
        ]
      ],
      "cve": "CVE-2022-48925"
    },
    {
      "commit_id": "5352a761308397a0e6250fdc629bb3f615b94747",
      "filepath": "net/ax25/af_ax25.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "ax25_release",
      "func_body": "static int ax25_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tax25_dev *ax25_dev;\n\n\tif (sk == NULL)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tsock_orphan(sk);\n\tax25 = sk_to_ax25(sk);\n\tax25_dev = ax25->ax25_dev;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tswitch (ax25->state) {\n\t\tcase AX25_STATE_0:\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_1:\n\t\tcase AX25_STATE_2:\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_3:\n\t\tcase AX25_STATE_4:\n\t\t\tax25_clear_queues(ax25);\n\t\t\tax25->n2count = 0;\n\n\t\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\t\t\tcase AX25_PROTO_STD_SIMPLEX:\n\t\t\tcase AX25_PROTO_STD_DUPLEX:\n\t\t\t\tax25_send_control(ax25,\n\t\t\t\t\t\t  AX25_DISC,\n\t\t\t\t\t\t  AX25_POLLON,\n\t\t\t\t\t\t  AX25_COMMAND);\n\t\t\t\tax25_stop_t2timer(ax25);\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n// #ifdef CONFIG_AX25_DAMA_SLAVE\n\t\t\tcase AX25_PROTO_DAMA_SLAVE:\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tax25_calculate_t1(ax25);\n\t\t\tax25_start_t1timer(ax25);\n\t\t\tax25->state = AX25_STATE_2;\n\t\t\tsk->sk_state                = TCP_CLOSE;\n\t\t\tsk->sk_shutdown            |= SEND_SHUTDOWN;\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsk->sk_state     = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tax25_destroy_socket(ax25);\n\t}\n\tif (ax25_dev) {\n\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\tax25_dev_put(ax25_dev);\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n",
      "line_statements": [
        [
          1055,
          "\tif (ax25_dev) {\n"
        ],
        [
          1056,
          "\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n"
        ],
        [
          1057,
          "\t\tax25_dev_put(ax25_dev);\n"
        ],
        [
          1058,
          "\t}\n"
        ]
      ],
      "statements": [
        [
          1055,
          "if (ax25_dev)"
        ],
        [
          1056,
          "dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);"
        ],
        [
          1057,
          "ax25_dev_put(ax25_dev);"
        ],
        [
          1058,
          "\t}\n"
        ]
      ],
      "cve": "CVE-2022-1204"
    },
    {
      "commit_id": "6ff7b060535e87c2ae14dd8548512abfdda528fb",
      "filepath": "drivers/net/phy/mdio_bus.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "__mdiobus_register",
      "func_body": "int __mdiobus_register(struct mii_bus *bus, struct module *owner)\n{\n\tstruct mdio_device *mdiodev;\n\tint i, err;\n\tstruct gpio_desc *gpiod;\n\n\tif (NULL == bus || NULL == bus->name ||\n\t    NULL == bus->read || NULL == bus->write)\n\t\treturn -EINVAL;\n\n\tBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\n\t       bus->state != MDIOBUS_UNREGISTERED);\n\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\n\terr = device_register(&bus->dev);\n\tif (err) {\n\t\tpr_err(\"mii_bus %s failed to register\\n\", bus->id);\n\t\tput_device(&bus->dev);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&bus->mdio_lock);\n\n\t/* de-assert bus level PHY GPIO reset */\n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\",\n\t\t\tbus->id);\n\t\tdevice_del(&bus->dev);\n\t\treturn PTR_ERR(gpiod);\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\n\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\tudelay(bus->reset_delay_us);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t}\n\n\tif (bus->reset)\n\t\tbus->reset(bus);\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & (1 << i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\n\t\t\tphydev = mdiobus_scan(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {\n\t\t\t\terr = PTR_ERR(phydev);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\n\n\tbus->state = MDIOBUS_REGISTERED;\n\tpr_info(\"%s: probed\\n\", bus->name);\n\treturn 0;\n\nerror:\n\twhile (--i >= 0) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t/* Put PHYs in RESET to save power */\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n\treturn err;\n}\n",
      "line_statements": [
        [
          382,
          "\t\tput_device(&bus->dev);\n"
        ]
      ],
      "statements": [
        [
          382,
          "put_device(&bus->dev);"
        ]
      ],
      "cve": "CVE-2019-12819"
    },
    {
      "commit_id": "768d612f79822d30a1e7d132a4d4b05337ce42ec",
      "filepath": "fs/ext4/extents_status.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "ext4_es_insert_extent",
      "func_body": "void ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t   ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t   unsigned int status)\n{\n\tstruct extent_status newes;\n\text4_lblk_t end = lblk + len - 1;\n\tint err1 = 0;\n\tint err2 = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct extent_status *es1 = NULL;\n\tstruct extent_status *es2 = NULL;\n\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\n\tes_debug(\"add [%u/%u) %llu %x to extent status tree of inode %lu\\n\",\n\t\t lblk, len, pblk, status, inode->i_ino);\n\n\tif (!len)\n\t\treturn;\n\n\tBUG_ON(end < lblk);\n\n\tif ((status & EXTENT_STATUS_DELAYED) &&\n\t    (status & EXTENT_STATUS_WRITTEN)) {\n\t\text4_warning(inode->i_sb, \"Inserting extent [%u/%u] as \"\n\t\t\t\t\" delayed and written which can potentially \"\n\t\t\t\t\" cause data loss.\", lblk, len);\n\t\tWARN_ON(1);\n\t}\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = len;\n\text4_es_store_pblock_status(&newes, pblk, status);\n\ttrace_ext4_es_insert_extent(inode, &newes);\n\n\text4_es_insert_extent_check(inode, &newes);\n\nretry:\n\tif (err1 && !es1)\n\t\tes1 = __es_alloc_extent(true);\n\tif ((err1 || err2) && !es2)\n\t\tes2 = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\n\terr1 = __es_remove_extent(inode, lblk, end, NULL, es1);\n\tif (err1 != 0)\n\t\tgoto error;\n\n\terr2 = __es_insert_extent(inode, &newes, es2);\n\tif (err2 == -ENOMEM && !ext4_es_must_keep(&newes))\n\t\terr2 = 0;\n\tif (err2 != 0)\n\t\tgoto error;\n\n\tif (sbi->s_cluster_ratio > 1 && test_opt(inode->i_sb, DELALLOC) &&\n\t    (status & EXTENT_STATUS_WRITTEN ||\n\t     status & EXTENT_STATUS_UNWRITTEN))\n\t\t__revise_pending(inode, lblk, len);\n\n\t/* es is pre-allocated but not used, free it. */\n\tif (es1 && !es1->es_len)\n\t\t__es_free_extent(es1);\n\tif (es2 && !es2->es_len)\n\t\t__es_free_extent(es2);\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err1 || err2)\n\t\tgoto retry;\n\n\text4_es_print_tree(inode);\n\treturn;\n}\n",
      "line_statements": [
        [
          892,
          "\n"
        ],
        [
          893,
          "\t/* es is pre-allocated but not used, free it. */\n"
        ],
        [
          894,
          "\tif (es1 && !es1->es_len)\n"
        ],
        [
          895,
          "\t\t__es_free_extent(es1);\n"
        ],
        [
          896,
          "\tif (es2 && !es2->es_len)\n"
        ],
        [
          897,
          "\t\t__es_free_extent(es2);\n"
        ]
      ],
      "statements": [
        [
          892,
          "\n"
        ],
        [
          893,
          "/* es is pre-allocated but not used, free it. */"
        ],
        [
          894,
          "if (es1 && !es1->es_len)"
        ],
        [
          895,
          "__es_free_extent(es1);"
        ],
        [
          896,
          "if (es2 && !es2->es_len)"
        ],
        [
          897,
          "__es_free_extent(es2);"
        ]
      ],
      "cve": "CVE-2023-45898"
    },
    {
      "commit_id": "8f3c3c6cd044e3b5bf08dbfa3b3f04bb3f711bad",
      "filepath": "src/buffer.c",
      "project": "vim",
      "project_repo_path": "symbol_backend_projects/vim",
      "is_vulnerable": false,
      "func_name": "do_buffer_ext",
      "func_body": "do_buffer_ext(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tflags)\t\t// DOBUF_FORCEIT etc.\n{\n    buf_T\t*buf;\n    buf_T\t*bp;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n\n    switch (start)\n    {\n\tcase DOBUF_FIRST:   buf = firstbuf; break;\n\tcase DOBUF_LAST:    buf = lastbuf;  break;\n\tdefault:\t    buf = curbuf;   break;\n    }\n    if (start == DOBUF_MOD)\t    // find next modified buffer\n    {\n\twhile (count-- > 0)\n\t{\n\t    do\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    while (buf != curbuf && !bufIsChanged(buf));\n\t}\n\tif (!bufIsChanged(buf))\n\t{\n\t    emsg(_(e_no_modified_buffer_found));\n\t    return FAIL;\n\t}\n    }\n    else if (start == DOBUF_FIRST && count) // find specified buffer number\n    {\n\twhile (buf != NULL && buf->b_fnum != count)\n\t    buf = buf->b_next;\n    }\n    else\n    {\n\tbp = NULL;\n\twhile (count > 0 || (!unload && !buf->b_p_bl && bp != buf))\n\t{\n\t    // remember the buffer where we start, we come back there when all\n\t    // buffers are unlisted.\n\t    if (bp == NULL)\n\t\tbp = buf;\n\t    if (dir == FORWARD)\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    else\n\t    {\n\t\tbuf = buf->b_prev;\n\t\tif (buf == NULL)\n\t\t    buf = lastbuf;\n\t    }\n\t    // don't count unlisted buffers\n\t    if (unload || buf->b_p_bl)\n\t    {\n\t\t --count;\n\t\t bp = NULL;\t// use this buffer as new starting point\n\t    }\n\t    if (bp == buf)\n\t    {\n\t\t// back where we started, didn't find anything.\n\t\temsg(_(e_there_is_no_listed_buffer));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n\n    if (buf == NULL)\t    // could not find it\n    {\n\tif (start == DOBUF_FIRST)\n\t{\n\t    // don't warn when deleting\n\t    if (!unload)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\t}\n\telse if (dir == FORWARD)\n\t    emsg(_(e_cannot_go_beyond_last_buffer));\n\telse\n\t    emsg(_(e_cannot_go_before_first_buffer));\n\treturn FAIL;\n    }\n#ifdef FEAT_PROP_POPUP\n    if ((flags & DOBUF_NOPOPUP) && bt_popup(buf) && !bt_terminal(buf))\n\treturn OK;\n#endif\n    if ((action == DOBUF_GOTO || action == DOBUF_SPLIT)\n\t\t\t\t\t\t  && (buf->b_flags & BF_DUMMY))\n    {\n\t// disallow navigating to the dummy buffer\n\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\treturn FAIL;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * delete buffer \"buf\" from memory and/or the list\n     */\n    if (unload)\n    {\n\tint\tforward;\n\tbufref_T bufref;\n\n\tif (!can_unload_buffer(buf))\n\t    return FAIL;\n\n\tset_bufref(&bufref, buf);\n\n\t// When unloading or deleting a buffer that's already unloaded and\n\t// unlisted: fail silently.\n\tif (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE\n\t\t\t\t   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl)\n\t    return FAIL;\n\n\tif ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf))\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n# ifdef FEAT_TERMINAL\n\t\tif (term_job_running(buf->b_term))\n\t\t{\n\t\t    if (term_confirm_stop(buf) == FAIL)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse\n# endif\n\t\t{\n\t\t    dialog_changed(buf, FALSE);\n\t\t    if (!bufref_valid(&bufref))\n\t\t\t// Autocommand deleted buffer, oops!  It's not changed\n\t\t\t// now.\n\t\t\treturn FAIL;\n\t\t    // If it's still changed fail silently, the dialog already\n\t\t    // mentioned why it fails.\n\t\t    if (bufIsChanged(buf))\n\t\t\treturn FAIL;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\tno_write_message_buf(buf);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// When closing the current buffer stop Visual mode.\n\tif (buf == curbuf && VIsual_active)\n\t    end_visual_mode();\n\n\t// If deleting the last (listed) buffer, make it empty.\n\t// The last (listed) buffer cannot be unloaded.\n\tFOR_ALL_BUFFERS(bp)\n\t    if (bp->b_p_bl && bp != buf)\n\t\tbreak;\n\tif (bp == NULL && buf == curbuf)\n\t    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);\n\n\t// If the deleted buffer is the current one, close the current window\n\t// (unless it's the only window).  Repeat this so long as we end up in\n\t// a window with this buffer.\n\twhile (buf == curbuf\n\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n\t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n\t{\n\t    if (win_close(curwin, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\n\t// If the buffer to be deleted is not the current one, delete it here.\n\tif (buf != curbuf)\n\t{\n\t    close_windows(buf, FALSE);\n\t    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)\n\t\t    close_buffer(NULL, buf, action, FALSE, FALSE);\n\t    return OK;\n\t}\n\n\t/*\n\t * Deleting the current buffer: Need to find another buffer to go to.\n\t * There should be another, otherwise it would have been handled\n\t * above.  However, autocommands may have deleted all buffers.\n\t * First use au_new_curbuf.br_buf, if it is valid.\n\t * Then prefer the buffer we most recently visited.\n\t * Else try to find one that is loaded, after the current buffer,\n\t * then before the current buffer.\n\t * Finally use any buffer.\n\t */\n\tbuf = NULL;\t// selected buffer\n\tbp = NULL;\t// used when no loaded buffer found\n\tif (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf))\n\t    buf = au_new_curbuf.br_buf;\n\telse if (curwin->w_jumplistlen > 0)\n\t{\n\t    int     jumpidx;\n\n\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Skip current and unlisted bufs.  Also skip a quickfix\n\t\t    // buffer, it might be deleted soon.\n\t\t    if (buf == curbuf || !buf->b_p_bl || bt_quickfix(buf))\n\t\t\tbuf = NULL;\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t\t// advance to older entry in jump list\n\t\tif (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t\t    break;\n\t\tif (--jumpidx < 0)\n\t\t    jumpidx = curwin->w_jumplistlen - 1;\n\t\tif (jumpidx == forward)\t\t// List exhausted for sure\n\t\t    break;\n\t    }\n\t}\n\n\tif (buf == NULL)\t// No previous buffer, Try 2'nd approach\n\t{\n\t    forward = TRUE;\n\t    buf = curbuf->b_next;\n\t    for (;;)\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl\n\t\t\t    && !bt_quickfix(buf))\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf && !bt_quickfix(buf))\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n\t    if (bt_quickfix(buf))\n\t\tbuf = NULL;\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n\n    /*\n     * make \"buf\" the current buffer\n     */\n    if (action == DOBUF_SPLIT)\t    // split window first\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))\n\t    return OK;\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))\n\t    return OK;\n\tif (win_split(0, 0) == FAIL)\n\t    return FAIL;\n    }\n\n    // go to current buffer - nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    // Check if the current buffer may be abandoned.\n    if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n# ifdef FEAT_TERMINAL\n\t    if (term_job_running(curbuf->b_term))\n\t    {\n\t\tif (term_confirm_stop(curbuf) == FAIL)\n\t\t    return FAIL;\n\t\t// Manually kill the terminal here because this command will\n\t\t// hide it otherwise.\n\t\tfree_terminal(curbuf);\n\t    }\n\t    else\n# endif\n\t    {\n\t\tbufref_T bufref;\n\n\t\tset_bufref(&bufref, buf);\n\t\tdialog_changed(curbuf, FALSE);\n\t\tif (!bufref_valid(&bufref))\n\t\t    // Autocommand deleted buffer, oops!\n\t\t    return FAIL;\n\n\t\tif (bufIsChanged(curbuf))\n\t\t{\n\t\t    no_write_message();\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n    }\n\n    // Go to the other buffer.\n    set_curbuf(buf, action);\n\n    if (action == DOBUF_SPLIT)\n\tRESET_BINDING(curwin);\t// reset 'scrollbind' and 'cursorbind'\n\n#if defined(FEAT_EVAL)\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n\n    return OK;\n}",
      "line_statements": [
        [
          1354,
          "    if ((action == DOBUF_GOTO || action == DOBUF_SPLIT)"
        ],
        [
          1355,
          "\t\t\t\t\t\t  && (buf->b_flags & BF_DUMMY))"
        ],
        [
          1356,
          "    {"
        ],
        [
          1358,
          "\tsemsg(_(e_buffer_nr_does_not_exist), count);"
        ],
        [
          1359,
          "\treturn FAIL;"
        ],
        [
          1360,
          "    }"
        ]
      ],
      "statements": [
        [
          1354,
          "if ((action == DOBUF_GOTO || action == DOBUF_SPLIT)\n\t\t\t\t\t\t  && (buf->b_flags & BF_DUMMY))"
        ],
        [
          1356,
          "    {\n"
        ],
        [
          1358,
          "semsg(_(e_buffer_nr_does_not_exist), count);"
        ],
        [
          1359,
          "return FAIL;"
        ],
        [
          1360,
          "    }\n"
        ]
      ],
      "cve": "CVE-2022-3591"
    },
    {
      "commit_id": "2c02d41d71f90a5168391b6a5f2954112ba2307c",
      "filepath": "net/ipv4/tcp_ulp.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "__tcp_set_ulp",
      "func_body": "static int __tcp_set_ulp(struct sock *sk, const struct tcp_ulp_ops *ulp_ops)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tint err;\n\n\terr = -EEXIST;\n\tif (icsk->icsk_ulp_ops)\n\t\tgoto out_err;\n\n\tif (sk->sk_socket)\n\t\tclear_bit(SOCK_SUPPORT_ZC, &sk->sk_socket->flags);\n\n\terr = ulp_ops->init(sk);\n\tif (err)\n\t\tgoto out_err;\n\n\ticsk->icsk_ulp_ops = ulp_ops;\n\treturn 0;\nout_err:\n\tmodule_put(ulp_ops->owner);\n\treturn err;\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2023-0461"
    },
    {
      "commit_id": "ec66c41d84e574baf8009dbc0bd088d2bc5b2421",
      "filepath": "src/window.c",
      "project": "vim",
      "project_repo_path": "symbol_backend_projects/vim",
      "is_vulnerable": true,
      "func_name": "win_enter_ext",
      "func_body": "win_enter_ext(\n    win_T\t*wp,\n    int\t\tundo_sync,\n    int\t\tcurwin_invalid,\n    int\t\ttrigger_new_autocmds,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\tother_buffer = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t/* nothing to do */\n\treturn;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && trigger_leave_autocmds)\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return;\n#ifdef FEAT_EVAL\n\t/* autocmds may abort script processing */\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    /* sync undo before leaving the current buffer */\n    if (undo_sync && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    /* Might need to scroll the old window before switching, e.g., when the\n     * cursor was moved. */\n    update_topline();\n\n    /* may have to copy the buffer options when 'cpo' contains 'S' */\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t/* remember for CTRL-W p */\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t/* assume cursor position needs updating */\n\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t    shorten_fnames(TRUE);\n    }\n    else if (globaldir != NULL)\n    {\n\t/* Window doesn't have a local directory and we are not in the global\n\t * directory: Change to the global directory. */\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tshorten_fnames(TRUE);\n    }\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    if (trigger_new_autocmds)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n#ifdef FEAT_TITLE\n    maketitle();\n#endif\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(wp->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t/* causes status line redraw */\n\n    /* set window height to desired minimal value */\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_TEXT_PROP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    /* set window width to desired minimal value */\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    /* Change directories when the 'acd' option is set. */\n    DO_AUTOCHDIR;\n}",
      "line_statements": [
        [
          4658,
          "    if (bt_terminal(wp->w_buffer))"
        ]
      ],
      "statements": [
        [
          4658,
          "if (bt_terminal(wp->w_buffer))\n\t// terminal is likely in another mode"
        ]
      ],
      "cve": "CVE-2019-20079"
    },
    {
      "commit_id": "637486261528e8aa3da9f26a4487dc254f4b7abb",
      "filepath": "src/shared/bus-polkit.c",
      "project": "systemd",
      "project_repo_path": "symbol_backend_projects/systemd",
      "is_vulnerable": false,
      "func_name": "bus_verify_polkit_async",
      "func_body": "int bus_verify_polkit_async(\n                sd_bus_message *call,\n                int capability,\n                const char *action,\n                const char **details,\n                bool interactive,\n                uid_t good_user,\n                Hashmap **registry,\n                sd_bus_error *ret_error) {\n\n#if ENABLE_POLKIT\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *pk = NULL;\n        AsyncPolkitQuery *q;\n        int c;\n#endif\n        const char *sender;\n        int r;\n\n        assert(call);\n        assert(action);\n        assert(registry);\n\n        r = check_good_user(call, good_user);\n        if (r != 0)\n                return r;\n\n#if ENABLE_POLKIT\n        q = hashmap_get(*registry, call);\n        if (q) {\n                int authorized, challenge;\n\n                /* This is the second invocation of this function, and there's already a response from\n                 * polkit, let's process it */\n                assert(q->reply);\n\n                /* If the operation we want to authenticate changed between the first and the second time,\n                 * let's not use this authentication, it might be out of date as the object and context we\n                 * operate on might have changed. */\n                if (!streq(q->action, action) ||\n                    !strv_equal(q->details, (char**) details))\n                        return -ESTALE;\n\n                if (sd_bus_message_is_method_error(q->reply, NULL)) {\n                        const sd_bus_error *e;\n\n                        e = sd_bus_message_get_error(q->reply);\n\n                        /* Treat no PK available as access denied */\n                        if (sd_bus_error_has_name(e, SD_BUS_ERROR_SERVICE_UNKNOWN) ||\n                            sd_bus_error_has_name(e, SD_BUS_ERROR_NAME_HAS_NO_OWNER))\n                                return -EACCES;\n\n                        /* Copy error from polkit reply */\n                        sd_bus_error_copy(ret_error, e);\n                        return -sd_bus_error_get_errno(e);\n                }\n\n                r = sd_bus_message_enter_container(q->reply, 'r', \"bba{ss}\");\n                if (r >= 0)\n                        r = sd_bus_message_read(q->reply, \"bb\", &authorized, &challenge);\n                if (r < 0)\n                        return r;\n\n                if (authorized)\n                        return 1;\n\n                if (challenge)\n                        return sd_bus_error_set(ret_error, SD_BUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED, \"Interactive authentication required.\");\n\n                return -EACCES;\n        }\n#endif\n\n        r = sd_bus_query_sender_privilege(call, capability);\n        if (r < 0)\n                return r;\n        else if (r > 0)\n                return 1;\n\n        sender = sd_bus_message_get_sender(call);\n        if (!sender)\n                return -EBADMSG;\n\n#if ENABLE_POLKIT\n        c = sd_bus_message_get_allow_interactive_authorization(call);\n        if (c < 0)\n                return c;\n        if (c > 0)\n                interactive = true;\n\n        r = hashmap_ensure_allocated(registry, NULL);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_new_method_call(\n                        call->bus,\n                        &pk,\n                        \"org.freedesktop.PolicyKit1\",\n                        \"/org/freedesktop/PolicyKit1/Authority\",\n                        \"org.freedesktop.PolicyKit1.Authority\",\n                        \"CheckAuthorization\");\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_append(\n                        pk,\n                        \"(sa{sv})s\",\n                        \"system-bus-name\", 1, \"name\", \"s\", sender,\n                        action);\n        if (r < 0)\n                return r;\n\n        r = bus_message_append_strv_key_value(pk, details);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_append(pk, \"us\", interactive, NULL);\n        if (r < 0)\n                return r;\n\n        q = new(AsyncPolkitQuery, 1);\n        if (!q)\n                return -ENOMEM;\n\n        *q = (AsyncPolkitQuery) {\n                .request = sd_bus_message_ref(call),\n        };\n\n        q->action = strdup(action);\n        if (!q->action) {\n                async_polkit_query_free(q);\n                return -ENOMEM;\n        }\n\n        q->details = strv_copy((char**) details);\n        if (!q->details) {\n                async_polkit_query_free(q);\n                return -ENOMEM;\n        }\n\n        r = hashmap_put(*registry, call, q);\n        if (r < 0) {\n                async_polkit_query_free(q);\n                return r;\n        }\n\n        q->registry = *registry;\n\n        r = sd_bus_call_async(call->bus, &q->slot, pk, async_polkit_callback, q, 0);\n        if (r < 0) {\n                async_polkit_query_free(q);\n                return r;\n        }\n\n        return 0;\n#endif\n\n        return -EACCES;\n}",
      "line_statements": [
        [
          267,
          "        const char *sender;"
        ],
        [
          335,
          "#if ENABLE_POLKIT"
        ]
      ],
      "statements": [
        [
          267,
          "const char *sender;"
        ],
        [
          335,
          "#if ENABLE_POLKIT\n        c = sd_bus_message_get_allow_interactive_authorization(call);\n        if (c < 0)\n                return c;\n        if (c > 0)\n                interactive = true;\n\n        r = hashmap_ensure_allocated(registry, NULL);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_new_method_call(\n                        call->bus,\n                        &pk,\n                        \"org.freedesktop.PolicyKit1\",\n                        \"/org/freedesktop/PolicyKit1/Authority\",\n                        \"org.freedesktop.PolicyKit1.Authority\",\n                        \"CheckAuthorization\");\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_append(\n                        pk,\n                        \"(sa{sv})s\",\n                        \"system-bus-name\", 1, \"name\", \"s\", sender,\n                        action);\n        if (r < 0)\n                return r;\n\n        r = bus_message_append_strv_key_value(pk, details);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_append(pk, \"us\", interactive, NULL);\n        if (r < 0)\n                return r;\n\n        q = new(AsyncPolkitQuery, 1);\n        if (!q)\n                return -ENOMEM;\n\n        *q = (AsyncPolkitQuery) {\n                .request = sd_bus_message_ref(call),\n        };\n\n        q->action = strdup(action);\n        if (!q->action) {\n                async_polkit_query_free(q);\n                return -ENOMEM;\n        }\n\n        q->details = strv_copy((char**) details);\n        if (!q->details) {\n                async_polkit_query_free(q);\n                return -ENOMEM;\n        }\n\n        r = hashmap_put(*registry, call, q);\n        if (r < 0) {\n                async_polkit_query_free(q);\n                return r;\n        }\n\n        q->registry = *registry;\n\n        r = sd_bus_call_async(call->bus, &q->slot, pk, async_polkit_callback, q, 0);\n        if (r < 0) {\n                async_polkit_query_free(q);\n                return r;\n        }\n\n        return 0;\n#endif"
        ]
      ],
      "cve": "CVE-2020-1712"
    },
    {
      "commit_id": "c70f49dda4946d6db6aa55588f6a756b76bd84ea",
      "filepath": "src/isomedia/movie_fragments.c",
      "project": "gpac",
      "project_repo_path": "symbol_backend_projects/gpac",
      "is_vulnerable": false,
      "func_name": "UpdateRuns",
      "func_body": "u32 UpdateRuns(GF_ISOFile *movie, GF_TrackFragmentBox *traf)\n{\n\tu32 sampleCount, i, j, RunSize, RunDur, RunFlags, NeedFlags, UseCTS;\n\t/* enum:\n\t   0 - use values per sample in the trun box\n\t   1 - use default values from track fragment header\n\t   2 - use default values from track extends header */\n\tu32 UseDefaultSize, UseDefaultDur, UseDefaultFlag;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n\n\tsampleCount = 0;\n\n#ifndef USE_BASE_DATA_OFFSET\n\tif (movie->use_segments) {\n\t\ttraf->tfhd->flags = GF_ISOM_MOOF_BASE_OFFSET;\n\t} else\n#endif\n\t{\n\t\tif (movie->force_moof_base_offset) {\n\t\t\ttraf->tfhd->flags = GF_ISOM_MOOF_BASE_OFFSET;\n\t\t} else {\n\t\t\ttraf->tfhd->flags = GF_ISOM_TRAF_BASE_OFFSET;\n\t\t}\n\t}\n\n\t//empty runs\n\tif (traf->tfhd->EmptyDuration) {\n\t\twhile (gf_list_count(traf->TrackRuns)) {\n\t\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, 0);\n\t\t\tgf_list_rem(traf->TrackRuns, 0);\n\t\t\tgf_list_del_item(movie->moof->trun_list, trun);\n\t\t\tgf_isom_box_del_parent(&traf->child_boxes, (GF_Box *)trun);\n\t\t}\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_DUR_EMPTY;\n\t\tif (traf->tfhd->EmptyDuration != traf->trex->def_sample_duration) {\n\t\t\ttraf->tfhd->def_sample_duration = traf->tfhd->EmptyDuration;\n\t\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DUR;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tUseDefaultSize = 0;\n\tUseDefaultDur = 0;\n\tUseDefaultFlag = 0;\n\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tGF_TrunEntry *first_ent = NULL;\n\t\tRunSize = 0;\n\t\tRunDur = 0;\n\t\tRunFlags = 0;\n\t\tUseCTS = 0;\n\t\tNeedFlags = 0;\n\n\t\t//process all samples in run\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tent = &trun->samples[j];\n\t\t\tif (!j) {\n\t\t\t\tfirst_ent = ent;\n\t\t\t\tRunSize = ent->size;\n\t\t\t\tif (ent->nb_pack) RunSize /= ent->nb_pack;\n\t\t\t\tRunDur = ent->Duration;\n\t\t\t}\n\t\t\t//we may have one entry only ...\n\t\t\tif (j || (trun->nb_samples==1)) {\n\t\t\t\tu32 ssize = ent->size;\n\t\t\t\tif (ent->nb_pack) ssize /= ent->nb_pack;\n\n\t\t\t\t//flags are only after first entry\n\t\t\t\tif (j==1 || (trun->nb_samples==1) ) RunFlags = ent->flags;\n\n\t\t\t\tif (ssize != RunSize) RunSize = 0;\n\t\t\t\tif (RunDur && (ent->Duration != RunDur))\n\t\t\t\t\tRunDur = 0;\n\t\t\t\tif (j && (RunFlags != ent->flags)) NeedFlags = 1;\n\t\t\t}\n\t\t\tif (ent->CTS_Offset) UseCTS = 1;\n\t\t}\n\t\t//empty list\n\t\tif (!first_ent) {\n\t\t\ti--;\n\t\t\tgf_list_rem(traf->TrackRuns, i);\n\t\t\tgf_list_del_item(movie->moof->trun_list, trun);\n\t\t\tcontinue;\n\t\t}\n\t\ttrun->flags = 0;\n\n\t\t//size checking\n\t\t//constant size, check if this is from current fragment default or global default\n\t\tif (RunSize && (traf->trex->def_sample_size == RunSize) && !traf->trex->cannot_use_default) {\n\t\t\tif (!UseDefaultSize) UseDefaultSize = 2;\n\t\t\telse if (UseDefaultSize==1) RunSize = 0;\n\t\t} else if (RunSize && (traf->tfhd->def_sample_size == RunSize)) {\n\t\t\tif (!UseDefaultSize) UseDefaultSize = 1;\n\t\t\telse if (UseDefaultSize==2) RunSize = 0;\n\t\t}\n\t\t//we could check for single entry runs and set the default size in the tfhd but\n\t\t//that's no bit saving...\n\t\telse {\n\t\t\tRunSize=0;\n\t\t}\n\n\t\tif (!RunSize) trun->flags |= GF_ISOM_TRUN_SIZE;\n\n\t\t//duration checking\n\t\tif (RunDur && (traf->trex->def_sample_duration == RunDur) && !traf->trex->cannot_use_default) {\n\t\t\tif (!UseDefaultDur) UseDefaultDur = 2;\n\t\t\telse if (UseDefaultDur==1) RunDur = 0;\n\t\t} else if (RunDur && (traf->tfhd->def_sample_duration == RunDur)) {\n\t\t\tif (!UseDefaultDur) UseDefaultDur = 1;\n\t\t\telse if (UseDefaultDur==2) RunDur = 0;\n\t\t}\n\t\tif (!RunDur) trun->flags |= GF_ISOM_TRUN_DURATION;\n\n\t\t//flag checking\n\t\tif (!NeedFlags) {\n\t\t\t// all samples flags are the same after the 2nd entry\n\t\t\tif (RunFlags == traf->trex->def_sample_flags && !traf->trex->cannot_use_default) {\n\t\t\t\t/* this run can use trex flags */\n\t\t\t\tif (!UseDefaultFlag) {\n\t\t\t\t\t/* if all previous runs used explicit flags per sample, we can still use trex flags for this run */\n\t\t\t\t\tUseDefaultFlag = 2;\n\t\t\t\t} else if (UseDefaultFlag==1) {\n\t\t\t\t\t/* otherwise if one of the previous runs did use tfhd flags,\n\t\t\t\t\twe have no choice but to explicitly use flags per sample for this run */\n\t\t\t\t\tNeedFlags = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else if (RunFlags == traf->tfhd->def_sample_flags) {\n\t\t\t\t/* this run can use tfhd flags */\n\t\t\t\tif (!UseDefaultFlag) {\n\t\t\t\t\t/* if all previous runs used explicit flags per sample, we can still use tfhd flags for this run */\n\t\t\t\t\tUseDefaultFlag = 1;\n\t\t\t\t} else if(UseDefaultFlag==2) {\n\t\t\t\t\t/* otherwise if one of the previous runs did use trex flags,\n\t\t\t\t\twe have no choice but to explicitly use flags per sample for this run */\n\t\t\t\t\tNeedFlags = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* the flags for the 2nd and following entries are different from trex and tfhd default values\n\t\t\t\t   (possible case: 2 samples in trun, and first sample was used to set default flags) */\n\t\t\t\tNeedFlags = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tif (NeedFlags) {\n\t\t\t//one flags entry per sample only\n\t\t\ttrun->flags |= GF_ISOM_TRUN_FLAGS;\n\t\t} else {\n\t\t\t/* this run can use default flags for the 2nd and following entries,\n\t\t\t   we just need to check if the first entry flags need to be singled out*/\n\t\t\tif (first_ent->flags != RunFlags) {\n\t\t\t\ttrun->flags |= GF_ISOM_TRUN_FIRST_FLAG;\n\t\t\t\t//if not old arch write the flags\n\t\t\t\t//in old arch we write 0, which means all deps unknown and sync sample set\n\t\t\t\tif (!traf->no_sdtp_first_flags)\n\t\t\t\t\ttrun->first_sample_flags = first_ent->flags;\n\t\t\t}\n\t\t}\n\n\t\t//CTS flag\n\t\tif (UseCTS) trun->flags |= GF_ISOM_TRUN_CTS_OFFSET;\n\n\t\t//run data offset if the offset indicated is 0 (first sample in this MDAT) don't\n\t\t//indicate it\n\t\tif (trun->data_offset)\n\t\t\ttrun->flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\n\t\tsampleCount += trun->sample_count;\n\t}\n\n\t//after all runs in the traf are processed, update TRAF flags\n\tif (UseDefaultSize==1)\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_SIZE;\n\tif (UseDefaultDur==1)\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DUR;\n\tif (UseDefaultFlag==1)\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_FLAGS;\n\tif (traf->trex->cannot_use_default || (traf->tfhd->sample_desc_index != traf->trex->def_sample_desc_index))\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DESC;\n\n\n\treturn sampleCount;\n}",
      "line_statements": [
        [
          594,
          "\t\t\tgf_list_del_item(movie->moof->trun_list, trun);"
        ],
        [
          647,
          "\t\t\tgf_list_del_item(movie->moof->trun_list, trun);"
        ]
      ],
      "statements": [
        [
          594,
          "gf_list_del_item(movie->moof->trun_list, trun);"
        ],
        [
          647,
          "gf_list_del_item(movie->moof->trun_list, trun);"
        ]
      ],
      "cve": "CVE-2023-48011"
    },
    {
      "commit_id": "bdcb8aa434c6d36b5c215d02a9ef07551be25a37",
      "filepath": "fs/gfs2/super.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "gfs2_put_super",
      "func_body": "static void gfs2_put_super(struct super_block *sb)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_jdesc *jd;\n\n\t/* No more recovery requests */\n\tset_bit(SDF_NORECOVERY, &sdp->sd_flags);\n\tsmp_mb();\n\n\t/* Wait on outstanding recovery */\nrestart:\n\tspin_lock(&sdp->sd_jindex_spin);\n\tlist_for_each_entry(jd, &sdp->sd_jindex_list, jd_list) {\n\t\tif (!test_bit(JDF_RECOVERY, &jd->jd_flags))\n\t\t\tcontinue;\n\t\tspin_unlock(&sdp->sd_jindex_spin);\n\t\twait_on_bit(&jd->jd_flags, JDF_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&sdp->sd_jindex_spin);\n\n\tif (!sb_rdonly(sb)) {\n\t\tgfs2_make_fs_ro(sdp);\n\t}\n\tif (gfs2_withdrawn(sdp)) {\n\t\tgfs2_destroy_threads(sdp);\n\t\tgfs2_quota_cleanup(sdp);\n\t}\n\tWARN_ON(gfs2_withdrawing(sdp));\n\n\t/*  At this point, we're through modifying the disk  */\n\n\t/*  Release stuff  */\n\n\tgfs2_freeze_unlock(&sdp->sd_freeze_gh);\n\n\tiput(sdp->sd_jindex);\n\tiput(sdp->sd_statfs_inode);\n\tiput(sdp->sd_rindex);\n\tiput(sdp->sd_quota_inode);\n\n\tgfs2_glock_put(sdp->sd_rename_gl);\n\tgfs2_glock_put(sdp->sd_freeze_gl);\n\n\tif (!sdp->sd_args.ar_spectator) {\n\t\tif (gfs2_holder_initialized(&sdp->sd_journal_gh))\n\t\t\tgfs2_glock_dq_uninit(&sdp->sd_journal_gh);\n\t\tif (gfs2_holder_initialized(&sdp->sd_jinode_gh))\n\t\t\tgfs2_glock_dq_uninit(&sdp->sd_jinode_gh);\n\t\tbrelse(sdp->sd_sc_bh);\n\t\tgfs2_glock_dq_uninit(&sdp->sd_sc_gh);\n\t\tgfs2_glock_dq_uninit(&sdp->sd_qc_gh);\n\t\tfree_local_statfs_inodes(sdp);\n\t\tiput(sdp->sd_qc_inode);\n\t}\n\n\tgfs2_glock_dq_uninit(&sdp->sd_live_gh);\n\tgfs2_clear_rgrpd(sdp);\n\tgfs2_jindex_free(sdp);\n\t/*  Take apart glock structures and buffer lists  */\n\tgfs2_gl_hash_clear(sdp);\n\ttruncate_inode_pages_final(&sdp->sd_aspace);\n\tgfs2_delete_debugfs_file(sdp);\n\t/*  Unmount the locking protocol  */\n\tgfs2_lm_unmount(sdp);\n\n\t/*  At this point, we're through participating in the lockspace  */\n\tgfs2_sys_fs_del(sdp);\n\tfree_sbd(sdp);\n}\n",
      "line_statements": [
        [
          605,
          "\tif (!sb_rdonly(sb)) {\n"
        ],
        [
          607,
          "\t}\n"
        ],
        [
          608,
          "\tif (gfs2_withdrawn(sdp)) {\n"
        ],
        [
          609,
          "\t\tgfs2_destroy_threads(sdp);\n"
        ]
      ],
      "statements": [
        [
          605,
          "if (!sb_rdonly(sb))"
        ],
        [
          607,
          "\t}\n"
        ],
        [
          608,
          "if (gfs2_withdrawn(sdp))"
        ],
        [
          609,
          "gfs2_destroy_threads(sdp);"
        ]
      ],
      "cve": "CVE-2023-52760"
    },
    {
      "commit_id": "07db5e247ab5858439b14dd7cc1fe538b9efcf32",
      "filepath": "fs/hfsplus/super.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "hfsplus_put_super",
      "func_body": "static void hfsplus_put_super(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\n\thfs_dbg(SUPER, \"hfsplus_put_super\\n\");\n\n\tcancel_delayed_work_sync(&sbi->sync_work);\n\n\tif (!sb_rdonly(sb) && sbi->s_vhdr) {\n\t\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\n\t\tvhdr->modify_date = hfsp_now2mt();\n\t\tvhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_UNMNT);\n\t\tvhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_INCNSTNT);\n\n\t\thfsplus_sync_fs(sb, 1);\n\t}\n\n\tiput(sbi->alloc_file);\n\tiput(sbi->hidden_dir);\n\thfs_btree_close(sbi->attr_tree);\n\thfs_btree_close(sbi->cat_tree);\n\thfs_btree_close(sbi->ext_tree);\n\tkfree(sbi->s_vhdr_buf);\n\tkfree(sbi->s_backup_vhdr_buf);\n\tunload_nls(sbi->nls);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n}\n",
      "line_statements": [
        [
          298,
          "\tiput(sbi->alloc_file);\n"
        ],
        [
          299,
          "\tiput(sbi->hidden_dir);\n"
        ]
      ],
      "statements": [
        [
          298,
          "iput(sbi->alloc_file);"
        ],
        [
          299,
          "iput(sbi->hidden_dir);"
        ]
      ],
      "cve": "CVE-2023-2985"
    },
    {
      "commit_id": "56897b217a1d0a91c9920cb418d6b3fe922f590a",
      "filepath": "drivers/bluetooth/hci_ldisc.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "hci_uart_set_proto",
      "func_body": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\n\thu->proto = p;\n\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\treturn 0;\n}\n",
      "line_statements": [
        [
          705,
          "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n"
        ]
      ],
      "statements": [
        [
          705,
          "set_bit(HCI_UART_PROTO_READY, &hu->flags);"
        ]
      ],
      "cve": "CVE-2019-15917"
    },
    {
      "commit_id": "c9fbd7bbc23dbdd73364be4d045e5d3612cf6e82",
      "filepath": "fs/xfs/xfs_super.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "xfs_fs_fill_super",
      "func_body": "STATIC int\nxfs_fs_fill_super(\n\tstruct super_block\t*sb,\n\tvoid\t\t\t*data,\n\tint\t\t\tsilent)\n{\n\tstruct inode\t\t*root;\n\tstruct xfs_mount\t*mp = NULL;\n\tint\t\t\tflags = 0, error = -ENOMEM;\n\n\t/*\n\t * allocate mp and do all low-level struct initializations before we\n\t * attach it to the super\n\t */\n\tmp = xfs_mount_alloc(sb);\n\tif (!mp)\n\t\tgoto out;\n\tsb->s_fs_info = mp;\n\n\terror = xfs_parseargs(mp, (char *)data);\n\tif (error)\n\t\tgoto out_free_fsname;\n\n\tsb_min_blocksize(sb, BBSIZE);\n\tsb->s_xattr = xfs_xattr_handlers;\n\tsb->s_export_op = &xfs_export_operations;\n// #ifdef CONFIG_XFS_QUOTA\n\tsb->s_qcop = &xfs_quotactl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tsb->s_op = &xfs_super_operations;\n\n\t/*\n\t * Delay mount work if the debug hook is set. This is debug\n\t * instrumention to coordinate simulation of xfs mount failures with\n\t * VFS superblock operations\n\t */\n\tif (xfs_globals.mount_delay) {\n\t\txfs_notice(mp, \"Delaying mount for %d seconds.\",\n\t\t\txfs_globals.mount_delay);\n\t\tmsleep(xfs_globals.mount_delay * 1000);\n\t}\n\n\tif (silent)\n\t\tflags |= XFS_MFSI_QUIET;\n\n\terror = xfs_open_devices(mp);\n\tif (error)\n\t\tgoto out_free_fsname;\n\n\terror = xfs_init_mount_workqueues(mp);\n\tif (error)\n\t\tgoto out_close_devices;\n\n\terror = xfs_init_percpu_counters(mp);\n\tif (error)\n\t\tgoto out_destroy_workqueues;\n\n\t/* Allocate stats memory before we do operations that might use it */\n\tmp->m_stats.xs_stats = alloc_percpu(struct xfsstats);\n\tif (!mp->m_stats.xs_stats) {\n\t\terror = -ENOMEM;\n\t\tgoto out_destroy_counters;\n\t}\n\n\terror = xfs_readsb(mp, flags);\n\tif (error)\n\t\tgoto out_free_stats;\n\n\terror = xfs_finish_flags(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\terror = xfs_setup_devices(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\terror = xfs_filestream_mount(mp);\n\tif (error)\n\t\tgoto out_free_sb;\n\n\t/*\n\t * we must configure the block size in the superblock before we run the\n\t * full mount process as the mount process can lookup and cache inodes.\n\t */\n\tsb->s_magic = XFS_SB_MAGIC;\n\tsb->s_blocksize = mp->m_sb.sb_blocksize;\n\tsb->s_blocksize_bits = ffs(sb->s_blocksize) - 1;\n\tsb->s_maxbytes = xfs_max_file_offset(sb->s_blocksize_bits);\n\tsb->s_max_links = XFS_MAXLINK;\n\tsb->s_time_gran = 1;\n\tset_posix_acl_flag(sb);\n\n\t/* version 5 superblocks support inode version counters. */\n\tif (XFS_SB_VERSION_NUM(&mp->m_sb) == XFS_SB_VERSION_5)\n\t\tsb->s_flags |= SB_I_VERSION;\n\n\tif (mp->m_flags & XFS_MOUNT_DAX) {\n\t\txfs_warn(mp,\n\t\t\"DAX enabled. Warning: EXPERIMENTAL, use at your own risk\");\n\n\t\terror = bdev_dax_supported(sb, sb->s_blocksize);\n\t\tif (error) {\n\t\t\txfs_alert(mp,\n\t\t\t\"DAX unsupported by block device. Turning off DAX.\");\n\t\t\tmp->m_flags &= ~XFS_MOUNT_DAX;\n\t\t}\n\t\tif (xfs_sb_version_hasreflink(&mp->m_sb)) {\n\t\t\txfs_alert(mp,\n\t\t\"DAX and reflink cannot be used together!\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_filestream_unmount;\n\t\t}\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_DISCARD) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\n\t\tif (!blk_queue_discard(q)) {\n\t\t\txfs_warn(mp, \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t\t\"the device does not support discard\");\n\t\t\tmp->m_flags &= ~XFS_MOUNT_DISCARD;\n\t\t}\n\t}\n\n\tif (xfs_sb_version_hasreflink(&mp->m_sb) && mp->m_sb.sb_rblocks) {\n\t\txfs_alert(mp,\n\t\"reflink not compatible with realtime device!\");\n\t\terror = -EINVAL;\n\t\tgoto out_filestream_unmount;\n\t}\n\n\tif (xfs_sb_version_hasrmapbt(&mp->m_sb) && mp->m_sb.sb_rblocks) {\n\t\txfs_alert(mp,\n\t\"reverse mapping btree not compatible with realtime device!\");\n\t\terror = -EINVAL;\n\t\tgoto out_filestream_unmount;\n\t}\n\n\terror = xfs_mountfs(mp);\n\tif (error)\n\t\tgoto out_filestream_unmount;\n\n\troot = igrab(VFS_I(mp->m_rootip));\n\tif (!root) {\n\t\terror = -ENOENT;\n\t\tgoto out_unmount;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terror = -ENOMEM;\n\t\tgoto out_unmount;\n\t}\n\n\treturn 0;\n\n out_filestream_unmount:\n\txfs_filestream_unmount(mp);\n out_free_sb:\n\txfs_freesb(mp);\n out_free_stats:\n\tfree_percpu(mp->m_stats.xs_stats);\n out_destroy_counters:\n\txfs_destroy_percpu_counters(mp);\n out_destroy_workqueues:\n\txfs_destroy_mount_workqueues(mp);\n out_close_devices:\n\txfs_close_devices(mp);\n out_free_fsname:\n\txfs_free_fsname(mp);\n\tkfree(mp);\n out:\n\treturn error;\n\n out_unmount:\n\txfs_filestream_unmount(mp);\n\txfs_unmountfs(mp);\n\tgoto out_free_sb;\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2018-20976"
    },
    {
      "commit_id": "1e38da300e1e395a15048b0af1e5305bd91402f6",
      "filepath": "fs/timerfd.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "SYSCALL_DEFINE2",
      "func_body": "SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)\n{\n\tint ufd;\n\tstruct timerfd_ctx *ctx;\n\n\t/* Check the TFD_* constants for consistency.  */\n\tBUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK);\n\n\tif ((flags & ~TFD_CREATE_FLAGS) ||\n\t    (clockid != CLOCK_MONOTONIC &&\n\t     clockid != CLOCK_REALTIME &&\n\t     clockid != CLOCK_REALTIME_ALARM &&\n\t     clockid != CLOCK_BOOTTIME &&\n\t     clockid != CLOCK_BOOTTIME_ALARM))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM) &&\n\t    (clockid == CLOCK_REALTIME_ALARM ||\n\t     clockid == CLOCK_BOOTTIME_ALARM))\n\t\treturn -EPERM;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&ctx->wqh);\n\tspin_lock_init(&ctx->cancel_lock);\n\tctx->clockid = clockid;\n\n\tif (isalarm(ctx))\n\t\talarm_init(&ctx->t.alarm,\n\t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?\n\t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,\n\t\t\t   timerfd_alarmproc);\n\telse\n\t\thrtimer_init(&ctx->t.tmr, clockid, HRTIMER_MODE_ABS);\n\n\tctx->moffs = ktime_mono_to_real(0);\n\n\tufd = anon_inode_getfd(\"[timerfd]\", &timerfd_fops, ctx,\n\t\t\t       O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS));\n\tif (ufd < 0)\n\t\tkfree(ctx);\n\n\treturn ufd;\n}",
      "line_statements": [
        [
          413,
          "\tspin_lock_init(&ctx->cancel_lock);"
        ]
      ],
      "statements": [
        [
          413,
          "spin_lock_init(&ctx->cancel_lock);"
        ]
      ],
      "cve": "CVE-2017-10661"
    },
    {
      "commit_id": "54648cf1ec2d7f4b6a71767799c45676a138ca24",
      "filepath": "block/blk-core.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "blk_init_allocated_queue",
      "func_body": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t/*\n\t * This also sets hw/phys segments, boundary and size\n\t */\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n\t\tq->exit_rq_fn(q, q->fq->flush_rq);\nout_free_flush_queue:\n\tblk_free_flush_queue(q->fq);\n\tq->fq = NULL;\n\treturn -ENOMEM;\n}\n",
      "line_statements": [
        [
          1187,
          "\tq->fq = NULL;\n"
        ]
      ],
      "statements": [
        [
          1187,
          "q->fq = NULL;"
        ]
      ],
      "cve": "CVE-2018-20856"
    },
    {
      "commit_id": "e2b706c691905fe78468c361aaabc719d0a496f1",
      "filepath": "net/ipv4/igmp.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "igmp_start_timer",
      "func_body": "static void igmp_start_timer(struct ip_mc_list *im, int max_delay)\n{\n\tint tv = get_random_u32_below(max_delay);\n\n\tim->tm_running = 1;\n\tif (!mod_timer(&im->timer, jiffies+tv+2))\n\t\trefcount_inc(&im->refcnt);\n}\n",
      "line_statements": [
        [
          219,
          "\tif (!mod_timer(&im->timer, jiffies+tv+2))\n"
        ],
        [
          220,
          "\t\trefcount_inc(&im->refcnt);\n"
        ]
      ],
      "statements": [
        [
          219,
          "if (!mod_timer(&im->timer, jiffies+tv+2))"
        ],
        [
          220,
          "refcount_inc(&im->refcnt);"
        ]
      ],
      "cve": "CVE-2023-6932"
    },
    {
      "commit_id": "d1e8ac62c6d978d4662f69116e30230d43033c92",
      "filepath": "libr/bin/format/mach0/mach0.c",
      "project": "radare2",
      "project_repo_path": "symbol_backend_projects/radare2",
      "is_vulnerable": false,
      "func_name": "MACH0_( get_relocs)",
      "func_body": "struct reloc_t* MACH0_(get_relocs)(struct MACH0_(obj_t)* bin) {\n\tstruct reloc_t *relocs;\n\tint i = 0, len;\n\tulebr ur = {NULL};\n\tint wordsize = MACH0_(get_bits)(bin) / 8;\n\tif (bin->dyld_info) {\n\t\tut8 *opcodes,*end, type = 0, rel_type = 0;\n\t\tint lib_ord, seg_idx = -1, sym_ord = -1;\n\t\tsize_t j, count, skip, bind_size, lazy_size;\n\t\tst64 addend = 0;\n\t\tut64 segmentAddress = 0LL;\n\t\tut64 addr = 0LL;\n\t\tut8 done = 0;\n\n#define CASE(T) case (T / 8): rel_type = R_BIN_RELOC_ ## T; break\n\t\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return NULL;\n\t\t}\n#undef CASE\n\t\tbind_size = bin->dyld_info->bind_size;\n\t\tlazy_size = bin->dyld_info->lazy_bind_size;\n\n\t\tif (!bind_size || !lazy_size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((bind_size + lazy_size)<1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->lazy_bind_off > bin->size || \\\n\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\t// NOTE(eddyb) it's a waste of memory, but we don't know the actual number of relocs.\n\t\tif (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t)))) {\n\t\t\treturn NULL;\n\t\t}\n\t\topcodes = calloc (1, bind_size + lazy_size + 1);\n\t\tif (!opcodes) {\n\t\t\tfree (relocs);\n\t\t\treturn NULL;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size);\n\t\ti = r_buf_read_at (bin->b, bin->dyld_info->lazy_bind_off, opcodes + bind_size, lazy_size);\n\t\tif (len < 1 || i < 1) {\n\t\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\",\n\t\t\t(ut64)(size_t)bin->dyld_info->bind_off);\n\t\t\tfree (opcodes);\n\t\t\trelocs[i].last = 1;\n\t\t\treturn relocs;\n\t\t}\n\t\ti = 0;\n\t\t// that +2 is a minimum required for uleb128, this may be wrong,\n\t\t// the correct fix would be to make ULEB() must use rutil's\n\t\t// implementation that already checks for buffer boundaries\n\t\tfor (ur.p = opcodes, end = opcodes + bind_size + lazy_size ; (ur.p+2 < end) && !done; ) {\n\t\t\tut8 imm = *ur.p & BIND_IMMEDIATE_MASK, op = *ur.p & BIND_OPCODE_MASK;\n\t\t\t++ur.p;\n\t\t\tswitch (op) {\n#define ULEB() read_uleb128 (&ur,end)\n#define SLEB() read_sleb128 (&ur,end)\n\t\t\tcase BIND_OPCODE_DONE:\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\t\t\tlib_ord = imm;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\t\tlib_ord = ULEB();\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\t\t\tlib_ord = imm? (st8)(BIND_OPCODE_MASK | imm) : 0;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: {\n\t\t\t\tchar *sym_name = (char*)ur.p;\n\t\t\t\t//ut8 sym_flags = imm;\n\t\t\t\twhile (*ur.p++ && ur.p<end) {\n\t\t\t\t\t/* empty loop */\n\t\t\t\t}\n\t\t\t\tsym_ord = -1;\n\t\t\t\tif (bin->symtab && bin->dysymtab.nundefsym < 0xffff)\n\t\t\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n\t\t\t\t\tint stridx = 0;\n\t\t\t\t\tint iundefsym = bin->dysymtab.iundefsym;\n\t\t\t\t\tif (iundefsym>=0 && iundefsym < bin->nsymtab) {\n\t\t\t\t\t\tint sidx = iundefsym +j;\n\t\t\t\t\t\tif (sidx<0 || sidx>= bin->nsymtab)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tstridx = bin->symtab[sidx].n_strx;\n\t\t\t\t\t\tif (stridx < 0 || stridx >= bin->symstrlen)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp ((char *)bin->symstr + stridx, sym_name)) {\n\t\t\t\t\t\tsym_ord = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\t\ttype = imm;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\t\taddend = SLEB();\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\t\tseg_idx = imm;\n\t\t\t\tif (seg_idx < 0 || seg_idx >= bin->nsegs) {\n\t\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\t\taddr = 0LL;\n\t\t\t\t\treturn 0; // early exit to avoid future mayhem\n\t\t\t\t} else {\n\t\t\t\t\taddr = bin->segs[seg_idx].vmaddr + ULEB();\n\t\t\t\t\tsegmentAddress = bin->segs[seg_idx].vmaddr \\\n\t\t\t\t\t\t\t+ bin->segs[seg_idx].vmsize;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\t\taddr += ULEB();\n\t\t\t\tbreak;\n#define DO_BIND() do {\\\nif (sym_ord < 0 || seg_idx < 0 ) break;\\\nif (i >= (bind_size + lazy_size)) break;\\\nrelocs[i].addr = addr;\\\nrelocs[i].offset = addr - bin->segs[seg_idx].vmaddr + bin->segs[seg_idx].fileoff;\\\nif (type == BIND_TYPE_TEXT_PCREL32)\\\n\trelocs[i].addend = addend - (bin->baddr + addr);\\\nelse relocs[i].addend = addend;\\\n/* library ordinal ??? */ \\\nrelocs[i].ord = lib_ord;\\\nrelocs[i].ord = sym_ord;\\\nrelocs[i].type = rel_type;\\\nrelocs[i++].last = 0;\\\n} while (0)\n\t\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\tbprintf (\"Error: Malformed DO bind opcode\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tDO_BIND();\n\t\t\t\taddr += wordsize;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\tbprintf (\"Error: Malformed ADDR ULEB bind opcode\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tDO_BIND();\n\t\t\t\taddr += ULEB() + wordsize;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\tbprintf (\"Error: Malformed IMM SCALED bind opcode\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tDO_BIND();\n\t\t\t\taddr += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\t\tcount = ULEB();\n\t\t\t\tskip = ULEB();\n\t\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed ULEB TIMES bind opcode\\n\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND();\n\t\t\t\t\taddr += skip + wordsize;\n\t\t\t\t}\n\t\t\t\tbreak;\n#undef DO_BIND\n#undef ULEB\n#undef SLEB\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *ur.p);\n\t\t\t\tfree (opcodes);\n\t\t\t\trelocs[i].last = 1;\n\t\t\t\treturn relocs;\n\t\t\t}\n\t\t}\n\t\tfree (opcodes);\n\t} else {\n\t\tint j;\n\t\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t)))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n\t\t\tif (parse_import_ptr (bin, &relocs[i], bin->dysymtab.iundefsym + j)) {\n\t\t\t\trelocs[i].ord = j;\n\t\t\t\trelocs[i++].last = 0;\n\t\t\t}\n\t\t}\n\t}\nbeach:\n\trelocs[i].last = 1;\n\n\treturn relocs;\n}",
      "line_statements": [
        [
          1751,
          "\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {"
        ],
        [
          1753,
          "\t\t}"
        ],
        [
          1755,
          "\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size) {"
        ],
        [
          1757,
          "\t\t}"
        ],
        [
          1758,
          "\t\tif (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size) {"
        ],
        [
          1760,
          "\t\t}"
        ],
        [
          1762,
          "\t\tif (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t)))) {"
        ],
        [
          1764,
          "\t\t}"
        ],
        [
          1912,
          "\t\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {"
        ],
        [
          1914,
          "\t\t}"
        ],
        [
          1915,
          "\t\tif (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t)))) {"
        ],
        [
          1917,
          "\t\t}"
        ],
        [
          1919,
          "\t\t\tif (parse_import_ptr (bin, &relocs[i], bin->dysymtab.iundefsym + j)) {"
        ]
      ],
      "statements": [
        [
          1751,
          "if (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size)"
        ],
        [
          1753,
          "\t\t}\n"
        ],
        [
          1754,
          "if (bin->dyld_info->lazy_bind_off > bin->size || \\\n\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size)"
        ],
        [
          1757,
          "\t\t}\n"
        ],
        [
          1758,
          "if (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size)"
        ],
        [
          1760,
          "\t\t}\n"
        ],
        [
          1762,
          "if (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t))))"
        ],
        [
          1764,
          "\t\t}\n"
        ],
        [
          1912,
          "if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)"
        ],
        [
          1914,
          "\t\t}\n"
        ],
        [
          1915,
          "if (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t))))"
        ],
        [
          1917,
          "\t\t}\n"
        ],
        [
          1919,
          "if (parse_import_ptr (bin, &relocs[i], bin->dysymtab.iundefsym + j))"
        ]
      ],
      "cve": "CVE-2017-7946"
    },
    {
      "commit_id": "75333d48f92256a0dec91dbf07835e804fc411c0",
      "filepath": "fs/nfsd/nfs4proc.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "nfsd4_do_async_copy",
      "func_body": "static int nfsd4_do_async_copy(void *data)\n{\n\tstruct nfsd4_copy *copy = (struct nfsd4_copy *)data;\n\t__be32 nfserr;\n\n\tif (nfsd4_ssc_is_inter(copy)) {\n\t\tstruct file *filp;\n\n\t\tfilp = nfs42_ssc_open(copy->ss_mnt, &copy->c_fh,\n\t\t\t\t      &copy->stateid);\n\t\tif (IS_ERR(filp)) {\n\t\t\tswitch (PTR_ERR(filp)) {\n\t\t\tcase -EBADF:\n\t\t\t\tnfserr = nfserr_wrong_type;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnfserr = nfserr_offload_denied;\n\t\t\t}\n\t\t\tnfsd4_interssc_disconnect(copy->ss_mnt);\n\t\t\tgoto do_callback;\n\t\t}\n\t\tnfserr = nfsd4_do_copy(copy, filp, copy->nf_dst->nf_file,\n\t\t\t\t       false);\n\t\tnfsd4_cleanup_inter_ssc(copy->ss_mnt, filp, copy->nf_dst);\n\t} else {\n\t\tnfserr = nfsd4_do_copy(copy, copy->nf_src->nf_file,\n\t\t\t\t       copy->nf_dst->nf_file, false);\n\t\tnfsd4_cleanup_intra_ssc(copy->nf_src, copy->nf_dst);\n\t}\n\ndo_callback:\n\tnfsd4_send_cb_offload(copy, nfserr);\n\tcleanup_async_copy(copy);\n\treturn 0;\n}\n",
      "line_statements": [
        [
          1773,
          "\t\t\tnfsd4_interssc_disconnect(copy->ss_mnt);\n"
        ]
      ],
      "statements": [
        [
          1773,
          "nfsd4_interssc_disconnect(copy->ss_mnt);"
        ]
      ],
      "cve": "CVE-2022-4379"
    },
    {
      "commit_id": "b51b21fc63c9805862322551387d9036f2b63433",
      "filepath": "mrbgems/mruby-io/src/io.c",
      "project": "mruby",
      "project_repo_path": "symbol_backend_projects/mruby",
      "is_vulnerable": true,
      "func_name": "mrb_io_initialize_copy",
      "func_body": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n\n  mrb_get_args(mrb, \"o\", &orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n\n  DATA_TYPE(copy) = &mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n\n  return copy;\n}",
      "line_statements": [
        [
          570,
          "  fptr_orig = io_get_open_fptr(mrb, orig);"
        ]
      ],
      "statements": [
        [
          570,
          "fptr_orig = io_get_open_fptr(mrb, orig);"
        ]
      ],
      "cve": "CVE-2018-10199"
    },
    {
      "commit_id": "0323bce598eea038714f941ce2b22541c46d488f",
      "filepath": "net/sched/cls_fw.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "fw_set_parms",
      "func_body": "static int fw_set_parms(struct net *net, struct tcf_proto *tp,\n\t\t\tstruct fw_filter *f, struct nlattr **tb,\n\t\t\tstruct nlattr **tca, unsigned long base, u32 flags,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct fw_head *head = rtnl_dereference(tp->root);\n\tu32 mask;\n\tint err;\n\n\terr = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &f->exts, flags,\n\t\t\t\textack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_FW_CLASSID]) {\n\t\tf->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);\n\t\ttcf_bind_filter(tp, &f->res, base);\n\t}\n\n\tif (tb[TCA_FW_INDEV]) {\n\t\tint ret;\n\t\tret = tcf_change_indev(net, tb[TCA_FW_INDEV], extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tf->ifindex = ret;\n\t}\n\n\terr = -EINVAL;\n\tif (tb[TCA_FW_MASK]) {\n\t\tmask = nla_get_u32(tb[TCA_FW_MASK]);\n\t\tif (mask != head->mask)\n\t\t\treturn err;\n\t} else if (head->mask != 0xFFFFFFFF)\n\t\treturn err;\n\n\treturn 0;\n}\n",
      "line_statements": [
        [
          215,
          "\tif (tb[TCA_FW_CLASSID]) {\n"
        ],
        [
          216,
          "\t\tf->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);\n"
        ],
        [
          217,
          "\t\ttcf_bind_filter(tp, &f->res, base);\n"
        ],
        [
          218,
          "\t}\n"
        ],
        [
          219,
          "\n"
        ]
      ],
      "statements": [
        [
          215,
          "if (tb[TCA_FW_CLASSID])"
        ],
        [
          216,
          "f->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);"
        ],
        [
          217,
          "tcf_bind_filter(tp, &f->res, base);"
        ],
        [
          218,
          "\t}\n"
        ],
        [
          219,
          "\n"
        ]
      ],
      "cve": "CVE-2023-3776"
    }
  ],
  "CWE-787": [
    {
      "commit_id": "a868bacb46e3c900530bed47a1c6f85b0fbe701c",
      "filepath": "input.c",
      "project": "tmux",
      "project_repo_path": "symbol_backend_projects/tmux",
      "is_vulnerable": true,
      "func_name": "input_csi_dispatch_sgr_colon",
      "func_body": "input_csi_dispatch_sgr_colon(struct input_ctx *ictx, u_int i)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tchar\t\t\t*s = ictx->param_list[i].str, *copy, *ptr, *out;\n\tint\t\t\t p[8];\n\tu_int\t\t\t n;\n\tconst char\t\t*errstr;\n\n\tfor (n = 0; n < nitems(p); n++)\n\t\tp[n] = -1;\n\tn = 0;\n\n\tptr = copy = xstrdup(s);\n\twhile ((out = strsep(&ptr, \":\")) != NULL) {\n\t\tif (*out != '\\0') {\n\t\t\tp[n++] = strtonum(out, 0, INT_MAX, &errstr);\n\t\t\tif (errstr != NULL || n == nitems(p)) {\n\t\t\t\tfree(copy);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else\n\t\t\tn++;\n\t\tlog_debug(\"%s: %u = %d\", __func__, n - 1, p[n - 1]);\n\t}\n\tfree(copy);\n\n\tif (n == 0)\n\t\treturn;\n\tif (p[0] == 4) {\n\t\tif (n != 2)\n\t\t\treturn;\n\t\tswitch (p[1]) {\n\t\tcase 0:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_4;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_5;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tif (n < 2 || (p[0] != 38 && p[0] != 48 && p[0] != 58))\n\t\treturn;\n\tswitch (p[1]) {\n\tcase 2:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tif (n == 5)\n\t\t\ti = 2;\n\t\telse\n\t\t\ti = 3;\n\t\tif (n < i + 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_rgb_do(ictx, p[0], p[i], p[i + 1],\n\t\t    p[i + 2]);\n\t\tbreak;\n\tcase 5:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_256_do(ictx, p[0], p[2]);\n\t\tbreak;\n\t}\n}",
      "line_statements": [
        [
          1979,
          "\t\t} else"
        ]
      ],
      "statements": [
        [
          1979,
          "else"
        ]
      ],
      "cve": "CVE-2020-27347"
    },
    {
      "commit_id": "71c2ab509a8628dbbad4bc7b3f98a64aa90d3297",
      "filepath": "src/jv.c",
      "project": "jq",
      "project_repo_path": "symbol_backend_projects/jq",
      "is_vulnerable": true,
      "func_name": "jvp_literal_number_literal",
      "func_body": "static const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n\n  if (decNumberIsInfinite(pdec)) {\n    // We cannot preserve the literal data of numbers outside the limited\n    // range of exponent. Since `decNumberToString` returns \"Infinity\"\n    // (or \"-Infinity\"), and to reduce stack allocations as possible, we\n    // normalize infinities in the callers instead of printing the maximum\n    // (or minimum) double here.\n    return NULL;\n  }\n\n  if (plit->literal_data == NULL) {\n    int len = jvp_dec_number_ptr(n)->digits + 14;\n    plit->literal_data = jv_mem_alloc(len);\n\n    // Preserve the actual precision as we have parsed it\n    // don't do decNumberTrim(pdec);\n\n    decNumberToString(pdec, plit->literal_data);\n  }\n\n  return plit->literal_data;\n}",
      "line_statements": [
        [
          638,
          "    int len = jvp_dec_number_ptr(n)->digits + 14;"
        ]
      ],
      "statements": [
        [
          638,
          "int len = jvp_dec_number_ptr(n)->digits + 14;"
        ]
      ],
      "cve": "CVE-2023-50246"
    },
    {
      "commit_id": "5186ddcf9e35a7aa0ff0539489a930434a1325f4",
      "filepath": "jpgfile.c",
      "project": "jhead",
      "project_repo_path": "symbol_backend_projects/jhead",
      "is_vulnerable": true,
      "func_name": "ReadJpegSections",
      "func_body": "int ReadJpegSections (FILE * infile, ReadMode_t ReadMode)\r\n{\r\n    int a;\r\n    int HaveCom = FALSE;\r\n\r\n    a = fgetc(infile);\r\n\r\n    if (a != 0xff || fgetc(infile) != M_SOI){\r\n        return FALSE;\r\n    }\r\n\r\n    ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300;\r\n    ImageInfo.JfifHeader.ResolutionUnits = 1;\r\n\r\n    for(;;){\r\n        int itemlen;\r\n        int prev;\r\n        int marker = 0;\r\n        int ll,lh, got;\r\n        uchar * Data;\r\n\r\n        CheckSectionsAllocated();\r\n\r\n        prev = 0;\r\n        for (a=0;;a++){\r\n            marker = fgetc(infile);\r\n            if (marker != 0xff && prev == 0xff) break;\r\n            if (marker == EOF){\r\n                ErrFatal(\"Unexpected end of file\");\r\n            }\r\n            prev = marker;\r\n        }\r\n\r\n        if (a > 10){\r\n            ErrNonfatal(\"Extraneous %d padding bytes before section %02X\",a-1,marker);\r\n        }\r\n\r\n        Sections[SectionsRead].Type = marker;\r\n  \r\n        // Read the length of the section.\r\n        lh = fgetc(infile);\r\n        ll = fgetc(infile);\r\n        if (lh == EOF || ll == EOF){\r\n            ErrFatal(\"Unexpected end of file\");\r\n        }\r\n\r\n        itemlen = (lh << 8) | ll;\r\n\r\n        if (itemlen < 2){\r\n            ErrFatal(\"invalid marker\");\r\n        }\r\n\r\n        Sections[SectionsRead].Size = itemlen;\r\n\r\n        Data = (uchar *)malloc(itemlen);\r\n        if (Data == NULL){\r\n            ErrFatal(\"Could not allocate memory\");\r\n        }\r\n        Sections[SectionsRead].Data = Data;\r\n\r\n        // Store first two pre-read bytes.\r\n        Data[0] = (uchar)lh;\r\n        Data[1] = (uchar)ll;\r\n\r\n        got = fread(Data+2, 1, itemlen-2, infile); // Read the whole section.\r\n        if (got != itemlen-2){\r\n            ErrFatal(\"Premature end of file?\");\r\n        }\r\n        SectionsRead += 1;\r\n\r\n        switch(marker){\r\n\r\n            case M_SOS:   // stop before hitting compressed data \r\n                // If reading entire image is requested, read the rest of the data.\r\n                if (ReadMode & READ_IMAGE){\r\n                    int cp, ep, size;\r\n                    // Determine how much file is left.\r\n                    cp = ftell(infile);\r\n                    fseek(infile, 0, SEEK_END);\r\n                    ep = ftell(infile);\r\n                    fseek(infile, cp, SEEK_SET);\r\n\r\n                    size = ep-cp;\r\n                    Data = (uchar *)malloc(size);\r\n                    if (Data == NULL){\r\n                        ErrFatal(\"could not allocate data for entire image\");\r\n                    }\r\n\r\n                    got = fread(Data, 1, size, infile);\r\n                    if (got != size){\r\n                        ErrFatal(\"could not read the rest of the image\");\r\n                    }\r\n\r\n                    CheckSectionsAllocated();\r\n                    Sections[SectionsRead].Data = Data;\r\n                    Sections[SectionsRead].Size = size;\r\n                    Sections[SectionsRead].Type = PSEUDO_IMAGE_MARKER;\r\n                    SectionsRead ++;\r\n                    HaveAll = 1;\r\n                }\r\n                return TRUE;\r\n\r\n            case M_DQT:\r\n                // Use for jpeg quality guessing\r\n                process_DQT(Data, itemlen);\r\n                break;\r\n\r\n            case M_DHT:   \r\n                // Use for jpeg quality guessing\r\n                process_DHT(Data, itemlen);\r\n                break;\r\n\r\n\r\n            case M_EOI:   // in case it's a tables-only JPEG stream\r\n                fprintf(stderr,\"No image in jpeg!\\n\");\r\n                return FALSE;\r\n\r\n            case M_COM: // Comment section\r\n                if (HaveCom || ((ReadMode & READ_METADATA) == 0)){\r\n                    // Discard this section.\r\n                    free(Sections[--SectionsRead].Data);\r\n                }else{\r\n                    process_COM(Data, itemlen);\r\n                    HaveCom = TRUE;\r\n                }\r\n                break;\r\n\r\n            case M_JFIF:\r\n                // Regular jpegs always have this tag, exif images have the exif\r\n                // marker instead, althogh ACDsee will write images with both markers.\r\n                // this program will re-create this marker on absence of exif marker.\r\n                // hence no need to keep the copy from the file.\r\n                if (itemlen < 16){\r\n                    fprintf(stderr,\"Jfif header too short\\n\");\r\n                    goto ignore;\r\n                }\r\n                if (memcmp(Data+2, \"JFIF\\0\",5)){\r\n                    fprintf(stderr,\"Header missing JFIF marker\\n\");\r\n                }\r\n\r\n                ImageInfo.JfifHeader.Present = TRUE;\r\n                ImageInfo.JfifHeader.ResolutionUnits = Data[9];\r\n                ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11];\r\n                ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13];\r\n                if (ShowTags){\r\n                    printf(\"JFIF SOI marker: Units: %d \",ImageInfo.JfifHeader.ResolutionUnits);\r\n                    switch(ImageInfo.JfifHeader.ResolutionUnits){\r\n                        case 0: printf(\"(aspect ratio)\"); break;\r\n                        case 1: printf(\"(dots per inch)\"); break;\r\n                        case 2: printf(\"(dots per cm)\"); break;\r\n                        default: printf(\"(unknown)\"); break;\r\n                    }\r\n                    printf(\"  X-density=%d Y-density=%d\\n\",ImageInfo.JfifHeader.XDensity, ImageInfo.JfifHeader.YDensity);\r\n\r\n                    if (Data[14] || Data[15]){\r\n                        fprintf(stderr,\"Ignoring jfif header thumbnail\\n\");\r\n                    }\r\n                }\r\n\r\n                ignore:\r\n\r\n                free(Sections[--SectionsRead].Data);\r\n                break;\r\n\r\n            case M_EXIF:\r\n                // There can be different section using the same marker.\r\n                if (ReadMode & READ_METADATA){\r\n                    if (memcmp(Data+2, \"Exif\", 4) == 0){\r\n                        process_EXIF(Data, itemlen);\r\n                        break;\r\n                    }else if (memcmp(Data+2, \"http:\", 5) == 0){\r\n                        Sections[SectionsRead-1].Type = M_XMP; // Change tag for internal purposes.\r\n                        if (ShowTags){\r\n                            printf(\"Image contains XMP section, %d bytes long\\n\", itemlen);\r\n                            if (ShowTags){\r\n                                ShowXmp(Sections[SectionsRead-1]);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                // Oterwise, discard this section.\r\n                free(Sections[--SectionsRead].Data);\r\n                break;\r\n\r\n            case M_IPTC:\r\n                if (ReadMode & READ_METADATA){\r\n                    if (ShowTags){\r\n                        printf(\"Image contains IPTC section, %d bytes long\\n\", itemlen);\r\n                    }\r\n                    // Note: We just store the IPTC section.  Its relatively straightforward\r\n                    // and we don't act on any part of it, so just display it at parse time.\r\n                }else{\r\n                    free(Sections[--SectionsRead].Data);\r\n                }\r\n                break;\r\n           \r\n            case M_SOF0: \r\n            case M_SOF1: \r\n            case M_SOF2: \r\n            case M_SOF3: \r\n            case M_SOF5: \r\n            case M_SOF6: \r\n            case M_SOF7: \r\n            case M_SOF9: \r\n            case M_SOF10:\r\n            case M_SOF11:\r\n            case M_SOF13:\r\n            case M_SOF14:\r\n            case M_SOF15:\r\n                if (itemlen < 8){\r\n                    fprintf(stderr,\"Section too short\\n\");\r\n                    break;\r\n                }\r\n                process_SOFn(Data, marker);\r\n                break;\r\n            default:\r\n                // Skip any other sections.\r\n                if (ShowTags){\r\n                    printf(\"Jpeg section marker 0x%02x size %d\\n\",marker, itemlen);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return TRUE;\r\n}\r",
      "line_statements": [
        [
          172,
          "        Data = (uchar *)malloc(itemlen);"
        ]
      ],
      "statements": [
        [
          172,
          "Data = (uchar *)malloc(itemlen);"
        ]
      ],
      "cve": "CVE-2020-26208"
    },
    {
      "commit_id": "bc3aaf4223fdb70d52d470dae65c5a7923ea2a49",
      "filepath": "src/libraw_datastream.cpp",
      "project": "LibRaw",
      "project_repo_path": "symbol_backend_projects/LibRaw",
      "is_vulnerable": false,
      "func_name": "LibRaw_file_datastream::gets",
      "func_body": "char *LibRaw_file_datastream::gets(char *str, int sz)\n{\n  if(sz<1) return NULL;\n  LR_STREAM_CHK();\n  std::istream is(f.get());\n  is.getline(str, sz);\n  if (is.fail())\n    return 0;\n  return str;\n}",
      "line_statements": [
        [
          290,
          "  if(sz<1) return NULL;"
        ]
      ],
      "statements": [
        [
          290,
          "if(sz<1)"
        ]
      ],
      "cve": "CVE-2021-32142"
    },
    {
      "commit_id": "1273cdc706eeedf8346d4b9faa5b33435056061d",
      "filepath": "src/media_tools/av_parsers.c",
      "project": "gpac",
      "project_repo_path": "symbol_backend_projects/gpac",
      "is_vulnerable": false,
      "func_name": "hevc_parse_vps_extension",
      "func_body": "static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)\n{\n\tu8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;\n\tu32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc = 0;\n\tu8 dimension_id_len[16], dim_bit_offset[16];\n\tu8 /*avc_base_layer_flag, */NumLayerSets, /*default_one_target_output_layer_flag, */rep_format_idx_present_flag, ols_ids_to_ls_idx;\n\tu8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];\n\tu8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS + 1];\n\tu8 ols_highest_output_layer_id[MAX_LHVC_LAYERS + 1];\n\n\tu32 k, d, r, p, iNuhLId, jNuhLId;\n\tu8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];\n\tu8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 num_ref_layers[64];\n\t//\tu8 tree_partition_layer_id[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\t//\tu8 id_ref_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 id_direct_ref_layers[64][MAX_LHVC_LAYERS];\n\tu8 layer_id_in_list_flag[64];\n\tBool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\n\tvps->vps_extension_found = 1;\n\tif ((vps->max_layers > 1) && vps->base_layer_internal_flag)\n\t\thevc_profile_tier_level(bs, 0, vps->max_sub_layers - 1, &vps->ext_ptl[0], 0);\n\n\tsplitting_flag = gf_bs_read_int_log(bs, 1, \"splitting_flag\");\n\tnum_scalability_types = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tvps->scalability_mask[i] = gf_bs_read_int_log_idx(bs, 1, \"scalability_mask\", i);\n\t\tnum_scalability_types += vps->scalability_mask[i];\n\t}\n\tif (num_scalability_types >= 16) {\n\t\tnum_scalability_types = 16;\n\t}\n\tdimension_id_len[0] = 0;\n\tfor (i = 0; i < (num_scalability_types - splitting_flag); i++) {\n\t\tdimension_id_len[i] = 1 + gf_bs_read_int_log_idx(bs, 3, \"dimension_id_len_minus1\", i);\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < num_scalability_types; i++) {\n\t\t\tdim_bit_offset[i] = 0;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tdim_bit_offset[i] += dimension_id_len[j];\n\t\t}\n\t\tdimension_id_len[num_scalability_types - 1] = 1 + (5 - dim_bit_offset[num_scalability_types - 1]);\n\t\tdim_bit_offset[num_scalability_types] = 6;\n\t}\n\n\tvps_nuh_layer_id_present_flag = gf_bs_read_int_log(bs, 1, \"vps_nuh_layer_id_present_flag\");\n\tvps->layer_id_in_nuh[0] = 0;\n\tvps->layer_id_in_vps[0] = 0;\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tif (vps_nuh_layer_id_present_flag) {\n\t\t\tvps->layer_id_in_nuh[i] = gf_bs_read_int_log_idx(bs, 6, \"layer_id_in_nuh\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->layer_id_in_nuh[i] = i;\n\t\t}\n\t\tvps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;\n\n\t\tif (!splitting_flag) {\n\t\t\tfor (j = 0; j < num_scalability_types; j++) {\n\t\t\t\tvps->dimension_id[i][j] = gf_bs_read_int_log_idx2(bs, dimension_id_len[j], \"dimension_id\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < vps->max_layers; i++)\n\t\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\t\tvps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j + 1]) - 1)) >> dim_bit_offset[j]);\n\t}\n\telse {\n\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\tvps->dimension_id[0][j] = 0;\n\t}\n\n\tview_id_len = gf_bs_read_int_log(bs, 4, \"view_id_len\");\n\tif (view_id_len > 0) {\n\t\tfor (i = 0; i < lhvc_get_num_views(vps); i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, view_id_len, \"view_id_val\", i);\n\t\t}\n\t}\n\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tvps->direct_dependency_flag[i][j] = gf_bs_read_int_log_idx(bs, 1, \"direct_dependency_flag\", i);\n\t\t}\n\t}\n\n\t//we do the test on MAX_LHVC_LAYERS and break in the loop to avoid a wrong GCC 4.8 warning on array bounds\n\tfor (i = 0; i < MAX_LHVC_LAYERS; i++) {\n\t\tif (i >= vps->max_layers) break;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tdependency_flag[i][j] = vps->direct_dependency_flag[i][j];\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t\tif (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])\n\t\t\t\t\tdependency_flag[i][j] = 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\td = r = p = 0;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tjNuhLId = vps->layer_id_in_nuh[j];\n\t\t\tif (vps->direct_dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_direct_ref_layers[iNuhLId][d] = jNuhLId;\n\t\t\t\td++;\n\t\t\t}\n\t\t\tif (dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_ref_layers[iNuhLId][r] = jNuhLId;\n\t\t\t\tr++;\n\t\t\t}\n\n\t\t\tif (dependency_flag[j][i])\n\t\t\t\tid_pred_layers[iNuhLId][p++] = jNuhLId;\n\t\t}\n\t\tnum_direct_ref_layers[iNuhLId] = d;\n\t\t//\t\tnum_ref_layers[iNuhLId] = r;\n\t\tnum_pred_layers[iNuhLId] = p;\n\t}\n\n\tmemset(layer_id_in_list_flag, 0, 64 * sizeof(u8));\n\tk = 0; //num_indepentdent_layers\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\tif (!num_direct_ref_layers[iNuhLId]) {\n\t\t\tu32 h = 1;\n\t\t\t//tree_partition_layer_id[k][0] = iNuhLId;\n\t\t\tfor (j = 0; j < num_pred_layers[iNuhLId]; j++) {\n\t\t\t\tu32 predLId = id_pred_layers[iNuhLId][j];\n\t\t\t\tif (!layer_id_in_list_flag[predLId]) {\n\t\t\t\t\t//tree_partition_layer_id[k][h++] = predLId;\n\t\t\t\t\tlayer_id_in_list_flag[predLId] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_layers_in_tree_partition[k++] = h;\n\t\t}\n\t}\n\tnum_indepentdent_layers = k;\n\n\tnum_add_layer_set = 0;\n\tif (num_indepentdent_layers > 1)\n\t\tnum_add_layer_set = gf_bs_read_ue_log(bs, \"num_add_layer_set\");\n\n\tfor (i = 0; i < num_add_layer_set; i++)\n\t\tfor (j = 1; j < num_indepentdent_layers; j++) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))\n\t\t\t\tnb_bits++;\n\t\t\tgf_bs_read_int_log_idx2(bs, nb_bits, \"highest_layer_idx_plus1\", i, j);\n\t\t}\n\n\n\tif (gf_bs_read_int_log(bs, 1, \"vps_sub_layers_max_minus1_present_flag\")) {\n\t\tfor (i = 0; i < vps->max_layers; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, 3, \"sub_layers_vps_max_minus1\", i);\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \"max_tid_ref_present_flag\")) {\n\t\tfor (i = 0; i < (vps->max_layers - 1); i++) {\n\t\t\tfor (j = i + 1; j < vps->max_layers; j++) {\n\t\t\t\tif (vps->direct_dependency_flag[j][i])\n\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"default_ref_layers_active_flag\");\n\n\tvps->num_profile_tier_level = 1 + gf_bs_read_ue_log(bs, \"num_profile_tier_level\");\n\tif (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of PTLs in VPS %d\\n\", vps->num_profile_tier_level));\n\t\tvps->num_profile_tier_level = 1;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {\n\t\tBool vps_profile_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_profile_present_flag\", i);\n\t\thevc_profile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers - 1, &vps->ext_ptl[i - 1], i-1);\n\t}\n\n\tNumLayerSets = vps->num_layer_sets + num_add_layer_set;\n\tnum_add_olss = 0;\n\n\tif (NumLayerSets > 1) {\n\t\tnum_add_olss = gf_bs_read_ue_log(bs, \"num_add_olss\");\n\t\tdefault_output_layer_idc = gf_bs_read_int_log(bs, 2, \"default_output_layer_idc\");\n\t\tdefault_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;\n\t}\n\tvps->num_output_layer_sets = num_add_olss + NumLayerSets;\n\n\tif (vps->num_output_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of output layer sets in VPS %d, max %d supported\\n\", vps->num_output_layer_sets, MAX_LHVC_LAYERS));\n\t\tvps->num_output_layer_sets = 1;\n\t\treturn GF_FALSE;\n\t}\n\n\tlayer_set_idx_for_ols_minus1[0] = 1;\n\tvps->output_layer_flag[0][0] = 1;\n\n\tfor (i = 0; i < vps->num_output_layer_sets; i++) {\n\t\tif ((NumLayerSets > 2) && (i >= NumLayerSets)) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (NumLayerSets - 1))\n\t\t\t\tnb_bits++;\n\t\t\tlayer_set_idx_for_ols_minus1[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"layer_set_idx_for_ols_minus1\", i);\n\t\t}\n\t\telse\n\t\t\tlayer_set_idx_for_ols_minus1[i] = 0;\n\t\tols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;\n\n\t\tif ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\t\tvps->output_layer_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"output_layer_flag\", i, j);\n\t\t}\n\n\t\tif ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\t\tif ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_TRUE;\n\t\t\t\telse\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tu32 curLayerID;\n\t\t\t\tvps->necessary_layers_flag[i][j] = GF_TRUE;\n\t\t\t\tcurLayerID = vps->LayerSetLayerIdList[i][j];\n\t\t\t\tfor (k = 0; k < j; k++) {\n\t\t\t\t\tu32 refLayerId = vps->LayerSetLayerIdList[i][k];\n\t\t\t\t\tif (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])\n\t\t\t\t\t\tvps->necessary_layers_flag[i][k] = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_necessary_layers[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (vps->necessary_layers_flag[i][j])\n\t\t\t\tvps->num_necessary_layers[i] += 1;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tif (vps->base_layer_internal_flag) {\n\t\t\t\tif (vps->max_layers > 1)\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 1;\n\t\t\t\telse\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tnb_bits = 1;\n\t\twhile ((u32)(1 << nb_bits) < vps->num_profile_tier_level)\n\t\t\tnb_bits++;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\tif (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)\n\t\t\t\tvps->profile_tier_level_idx[i][j] = gf_bs_read_int_log_idx2(bs, nb_bits, \"profile_tier_level_idx\", i, j);\n\t\t\telse\n\t\t\t\tvps->profile_tier_level_idx[i][j] = 0;\n\n\n\t\tnb_output_layers_in_output_layer_set[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tnb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];\n\t\t\t}\n\t\t}\n\t\tif (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)\n\t\t\tvps->alt_output_layer_flag[i] = gf_bs_read_int_log_idx(bs, 1, \"alt_output_layer_flag\", i);\n\t}\n\n\tvps->num_rep_formats = 1 + gf_bs_read_ue_log(bs, \"num_rep_formats_minus1\");\n\tif (vps->num_rep_formats > 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of rep formats in VPS %d\\n\", vps->num_rep_formats));\n\t\tvps->num_rep_formats = 0;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = 0; i < vps->num_rep_formats; i++) {\n\t\tlhvc_parse_rep_format(&vps->rep_formats[i], bs, i);\n\t}\n\tif (vps->num_rep_formats > 1)\n\t\trep_format_idx_present_flag = gf_bs_read_int_log(bs, 1, \"rep_format_idx_present_flag\");\n\telse\n\t\trep_format_idx_present_flag = 0;\n\n\tvps->rep_format_idx[0] = 0;\n\tnb_bits = 1;\n\twhile ((u32)(1 << nb_bits) < vps->num_rep_formats)\n\t\tnb_bits++;\n\tfor (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {\n\t\tif (rep_format_idx_present_flag) {\n\t\t\tvps->rep_format_idx[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"rep_format_idx\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;\n\t\t}\n\t}\n\t//TODO - we don't use the rest ...\n\n\treturn GF_TRUE;\n}",
      "line_statements": [
        [
          7478,
          "\tif (vps->num_output_layer_sets > MAX_LHVC_LAYERS) {"
        ],
        [
          7479,
          "\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of output layer sets in VPS %d, max %d supported\\n\", vps->num_output_layer_sets, MAX_LHVC_LAYERS));"
        ],
        [
          7480,
          "\t\tvps->num_output_layer_sets = 1;"
        ],
        [
          7481,
          "\t\treturn GF_FALSE;"
        ],
        [
          7482,
          "\t}"
        ]
      ],
      "statements": [
        [
          7478,
          "if (vps->num_output_layer_sets > MAX_LHVC_LAYERS)"
        ],
        [
          7479,
          "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of output layer sets in VPS %d, max %d supported\\n\", vps->num_output_layer_sets, MAX_LHVC_LAYERS));"
        ],
        [
          7480,
          "vps->num_output_layer_sets = 1;"
        ],
        [
          7481,
          "return GF_FALSE;"
        ],
        [
          7482,
          "\t}\n"
        ]
      ],
      "cve": "CVE-2021-33362"
    },
    {
      "commit_id": "71fe87878c9cbc3db429f5e5c70f28e4b3d96e3b",
      "filepath": "htmldoc/image.cxx",
      "project": "htmldoc",
      "project_repo_path": "symbol_backend_projects/htmldoc",
      "is_vulnerable": true,
      "func_name": "image_load_gif",
      "func_body": "image_load_gif(image_t *img,\t/* I - Image pointer */\n               FILE    *fp,\t/* I - File to load from */\n               int     gray,\t/* I - 0 = color, 1 = grayscale */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  uchar\t\tbuf[1024];\t/* Input buffer */\n  gif_cmap_t\tcmap;\t\t/* Colormap */\n  int\t\tncolors,\t/* Bits per pixel */\n\t\ttransparent;\t/* Transparent color index */\n\n\n /*\n  * Read the header; we already know it is a GIF file...\n  */\n\n  fread(buf, 13, 1, fp);\n\n  img->width  = (buf[7] << 8) | buf[6];\n  img->height = (buf[9] << 8) | buf[8];\n  ncolors     = 2 << (buf[10] & 0x07);\n\n  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)\n    return (-1);\n\n  // If we are writing an encrypted PDF file, bump the use count so we create\n  // an image object (Acrobat 6 bug workaround)\n  if (Encryption)\n    img->use ++;\n\n  if (buf[10] & GIF_COLORMAP)\n    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n      return (-1);\n\n  transparent = -1;\n\n  while (1)\n  {\n    switch (getc(fp))\n    {\n      case ';' :\t/* End of image */\n          return (-1);\t\t/* Early end of file */\n\n      case '!' :\t/* Extension record */\n          buf[0] = (uchar)getc(fp);\n          if (buf[0] == 0xf9)\t/* Graphic Control Extension */\n          {\n            gif_get_block(fp, buf);\n            if (buf[0] & 1)\t/* Get transparent color index */\n              transparent = buf[3];\n          }\n\n          while (gif_get_block(fp, buf) != 0);\n          break;\n\n      case ',' :\t/* Image data */\n          fread(buf, 9, 1, fp);\n\n          if (buf[8] & GIF_COLORMAP)\n          {\n            ncolors = 2 << (buf[8] & 0x07);\n\n\t    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n\t      return (-1);\n\t  }\n\n          if (transparent >= 0)\n          {\n           /*\n            * Map transparent color to background color...\n            */\n\n            if (BodyColor[0])\n\t    {\n\t      float rgb[3]; /* RGB color */\n\n\n\t      get_color((uchar *)BodyColor, rgb);\n\n\t      cmap[transparent][0] = (uchar)(rgb[0] * 255.0f + 0.5f);\n\t      cmap[transparent][1] = (uchar)(rgb[1] * 255.0f + 0.5f);\n\t      cmap[transparent][2] = (uchar)(rgb[2] * 255.0f + 0.5f);\n\t    }\n\t    else\n\t    {\n\t      cmap[transparent][0] = 255;\n              cmap[transparent][1] = 255;\n              cmap[transparent][2] = 255;\n\t    }\n\n           /*\n\t    * Allocate a mask image...\n\t    */\n\n            image_need_mask(img);\n\t  }\n\n          img->width  = (buf[5] << 8) | buf[4];\n          img->height = (buf[7] << 8) | buf[6];\n          img->depth  = gray ? 1 : 3;\n\n\t  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)\n\t    return (-1);\n\n\t  if (!load_data)\n\t    return (0);\n\n          img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n          if (img->pixels == NULL)\n            return (-1);\n\n\t  return (gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE, transparent));\n    }\n  }\n}",
      "line_statements": [
        [
          1346,
          "          img->width  = (buf[5] << 8) | buf[4];"
        ],
        [
          1347,
          "          img->height = (buf[7] << 8) | buf[6];"
        ],
        [
          1348,
          "          img->depth  = gray ? 1 : 3;"
        ],
        [
          1349,
          ""
        ],
        [
          1350,
          "\t  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)"
        ],
        [
          1351,
          "\t    return (-1);"
        ],
        [
          1352,
          ""
        ]
      ],
      "statements": [
        [
          1304,
          "case ',' :\t/* Image data */\n          fread(buf, 9, 1, fp);\n\n          if (buf[8] & GIF_COLORMAP)\n          {\n            ncolors = 2 << (buf[8] & 0x07);\n\n\t    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n\t      return (-1);\n\t  }\n\n          if (transparent >= 0)\n          {\n           /*\n            * Map transparent color to background color...\n            */\n\n            if (BodyColor[0])\n\t    {\n\t      float rgb[3]; /* RGB color */\n\n\n\t      get_color((uchar *)BodyColor, rgb);\n\n\t      cmap[transparent][0] = (uchar)(rgb[0] * 255.0f + 0.5f);\n\t      cmap[transparent][1] = (uchar)(rgb[1] * 255.0f + 0.5f);\n\t      cmap[transparent][2] = (uchar)(rgb[2] * 255.0f + 0.5f);\n\t    }\n\t    else\n\t    {\n\t      cmap[transparent][0] = 255;\n              cmap[transparent][1] = 255;\n              cmap[transparent][2] = 255;\n\t    }\n\n           /*\n\t    * Allocate a mask image...\n\t    */\n\n            image_need_mask(img);\n\t  }\n\n          img->width  = (buf[5] << 8) | buf[4];\n          img->height = (buf[7] << 8) | buf[6];\n          img->depth  = gray ? 1 : 3;\n\n\t  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)\n\t    return (-1);\n\n\t  if (!load_data)\n\t    return (0);\n\n          img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n          if (img->pixels == NULL)\n            return (-1);\n\n\t  return (gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE, transparent));"
        ],
        [
          1346,
          "img->width  = (buf[5] << 8) | buf[4];"
        ],
        [
          1347,
          "img->height = (buf[7] << 8) | buf[6];"
        ],
        [
          1348,
          "img->depth  = gray ? 1 : 3;"
        ],
        [
          1350,
          "if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)"
        ],
        [
          1351,
          "return (-1);"
        ]
      ],
      "cve": "CVE-2022-0137"
    },
    {
      "commit_id": "ca72d88378b2f2444d3ec145dd442d449d3fefbc",
      "filepath": "arch/powerpc/mm/mmu_context_book3s64.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "hash__init_new_context",
      "func_body": "static int hash__init_new_context(struct mm_struct *mm)\n{\n\tint index;\n\n\t/*\n\t * The old code would re-promote on fork, we don't do that when using\n\t * slices as it could cause problem promoting slices that have been\n\t * forced down to 4K.\n\t *\n\t * For book3s we have MMU_NO_CONTEXT set to be ~0. Hence check\n\t * explicitly against context.id == 0. This ensures that we properly\n\t * initialize context slice details for newly allocated mm's (which will\n\t * have id == 0) and don't alter context slice inherited via fork (which\n\t * will have id != 0).\n\t *\n\t * We should not be calling init_new_context() on init_mm. Hence a\n\t * check against 0 is OK.\n\t */\n\tif (mm->context.id == 0)\n\t\tslice_init_new_context_exec(mm);\n\n\tindex = realloc_context_ids(&mm->context);\n\tif (index < 0)\n\t\treturn index;\n\n\tsubpage_prot_init_new_context(mm);\n\n\tpkey_mm_init(mm);\n\treturn index;\n}\n",
      "line_statements": [
        [
          117,
          "\tindex = realloc_context_ids(&mm->context);\n"
        ],
        [
          118,
          "\tif (index < 0)\n"
        ],
        [
          119,
          "\t\treturn index;\n"
        ],
        [
          120,
          "\n"
        ]
      ],
      "statements": [
        [
          117,
          "index = realloc_context_ids(&mm->context);"
        ],
        [
          118,
          "if (index < 0)"
        ],
        [
          119,
          "return index;"
        ],
        [
          120,
          "\n"
        ]
      ],
      "cve": "CVE-2019-12817"
    },
    {
      "commit_id": "66abf0887c89c29a484d9e65e70882794e9e3a1b",
      "filepath": "src/media_tools/av_parsers.c",
      "project": "gpac",
      "project_repo_path": "symbol_backend_projects/gpac",
      "is_vulnerable": false,
      "func_name": "hevc_parse_vps_extension",
      "func_body": "static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)\n{\n\tu8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;\n\tu32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc = 0;\n\tu8 dimension_id_len[16], dim_bit_offset[16];\n\tu8 /*avc_base_layer_flag, */NumLayerSets, /*default_one_target_output_layer_flag, */rep_format_idx_present_flag, ols_ids_to_ls_idx;\n\tu8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];\n\tu8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS + 1];\n\tu8 ols_highest_output_layer_id[MAX_LHVC_LAYERS + 1];\n\n\tu32 k, d, r, p, iNuhLId, jNuhLId;\n\tu8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];\n\tu8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 num_ref_layers[64];\n\t//\tu8 tree_partition_layer_id[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\t//\tu8 id_ref_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 id_direct_ref_layers[64][MAX_LHVC_LAYERS];\n\tu8 layer_id_in_list_flag[64];\n\tBool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\n\tvps->vps_extension_found = 1;\n\tif ((vps->max_layers > 1) && vps->base_layer_internal_flag)\n\t\thevc_profile_tier_level(bs, 0, vps->max_sub_layers - 1, &vps->ext_ptl[0], 0);\n\n\tsplitting_flag = gf_bs_read_int_log(bs, 1, \"splitting_flag\");\n\tnum_scalability_types = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tvps->scalability_mask[i] = gf_bs_read_int_log_idx(bs, 1, \"scalability_mask\", i);\n\t\tnum_scalability_types += vps->scalability_mask[i];\n\t}\n\tif (num_scalability_types >= 16) {\n\t\tnum_scalability_types = 16;\n\t}\n\tdimension_id_len[0] = 0;\n\tif (num_scalability_types) {\n\t\tfor (i = 0; i < (num_scalability_types - splitting_flag); i++) {\n\t\t\tdimension_id_len[i] = 1 + gf_bs_read_int_log_idx(bs, 3, \"dimension_id_len_minus1\", i);\n\t\t}\n\n\t\tif (splitting_flag) {\n\t\t\tu32 num_bits=0;\n\t\t\tfor (i = 0; i < num_scalability_types-1; i++) {\n\t\t\t\tdim_bit_offset[i] = 0;\n\t\t\t\tnum_bits+=dimension_id_len[i];\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tdim_bit_offset[i] += dimension_id_len[j];\n\t\t\t}\n\t\t\tif (num_bits>=6) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Too many its defined for dimension IDs (%d vs 5 max)\\n\", num_bits));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdimension_id_len[num_scalability_types - 1] = 6 - num_bits; //1 + (5 - dim_bit_offset[num_scalability_types - 1]);\n\t\t\tdim_bit_offset[num_scalability_types - 1] = 6;\n\t\t}\n\t}\n\n\tvps_nuh_layer_id_present_flag = gf_bs_read_int_log(bs, 1, \"vps_nuh_layer_id_present_flag\");\n\tvps->layer_id_in_nuh[0] = 0;\n\tvps->layer_id_in_vps[0] = 0;\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tif (vps_nuh_layer_id_present_flag) {\n\t\t\tvps->layer_id_in_nuh[i] = gf_bs_read_int_log_idx(bs, 6, \"layer_id_in_nuh\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->layer_id_in_nuh[i] = i;\n\t\t}\n\t\tif (vps->layer_id_in_nuh[i] > MAX_LHVC_LAYERS) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] %d layers in VPS ext but only %d supported in GPAC\\n\", vps->layer_id_in_nuh[i], MAX_LHVC_LAYERS));\n\t\t\tvps->layer_id_in_nuh[i] = 0;\n\t\t\treturn -1;\n\t\t}\n\t\tvps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;\n\n\t\tif (!splitting_flag) {\n\t\t\tfor (j = 0; j < num_scalability_types; j++) {\n\t\t\t\tvps->dimension_id[i][j] = gf_bs_read_int_log_idx2(bs, dimension_id_len[j], \"dimension_id\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < vps->max_layers; i++)\n\t\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\t\tvps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j + 1]) - 1)) >> dim_bit_offset[j]);\n\t}\n\telse {\n\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\tvps->dimension_id[0][j] = 0;\n\t}\n\n\tview_id_len = gf_bs_read_int_log(bs, 4, \"view_id_len\");\n\tif (view_id_len > 0) {\n\t\tfor (i = 0; i < lhvc_get_num_views(vps); i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, view_id_len, \"view_id_val\", i);\n\t\t}\n\t}\n\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tvps->direct_dependency_flag[i][j] = gf_bs_read_int_log_idx(bs, 1, \"direct_dependency_flag\", i);\n\t\t}\n\t}\n\n\t//we do the test on MAX_LHVC_LAYERS and break in the loop to avoid a wrong GCC 4.8 warning on array bounds\n\tfor (i = 0; i < MAX_LHVC_LAYERS; i++) {\n\t\tif (i >= vps->max_layers) break;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tdependency_flag[i][j] = vps->direct_dependency_flag[i][j];\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t\tif (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])\n\t\t\t\t\tdependency_flag[i][j] = 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\td = r = p = 0;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tjNuhLId = vps->layer_id_in_nuh[j];\n\t\t\tif (vps->direct_dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_direct_ref_layers[iNuhLId][d] = jNuhLId;\n\t\t\t\td++;\n\t\t\t}\n\t\t\tif (dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_ref_layers[iNuhLId][r] = jNuhLId;\n\t\t\t\tr++;\n\t\t\t}\n\n\t\t\tif (dependency_flag[j][i])\n\t\t\t\tid_pred_layers[iNuhLId][p++] = jNuhLId;\n\t\t}\n\t\tnum_direct_ref_layers[iNuhLId] = d;\n\t\t//\t\tnum_ref_layers[iNuhLId] = r;\n\t\tnum_pred_layers[iNuhLId] = p;\n\t}\n\n\tmemset(layer_id_in_list_flag, 0, 64 * sizeof(u8));\n\tk = 0; //num_indepentdent_layers\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\tif (!num_direct_ref_layers[iNuhLId]) {\n\t\t\tu32 h = 1;\n\t\t\t//tree_partition_layer_id[k][0] = iNuhLId;\n\t\t\tfor (j = 0; j < num_pred_layers[iNuhLId]; j++) {\n\t\t\t\tu32 predLId = id_pred_layers[iNuhLId][j];\n\t\t\t\tif (!layer_id_in_list_flag[predLId]) {\n\t\t\t\t\t//tree_partition_layer_id[k][h++] = predLId;\n\t\t\t\t\tlayer_id_in_list_flag[predLId] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_layers_in_tree_partition[k++] = h;\n\t\t}\n\t}\n\tnum_indepentdent_layers = k;\n\n\tnum_add_layer_set = 0;\n\tif (num_indepentdent_layers > 1)\n\t\tnum_add_layer_set = gf_bs_read_ue_log(bs, \"num_add_layer_set\");\n\n\tfor (i = 0; i < num_add_layer_set; i++)\n\t\tfor (j = 1; j < num_indepentdent_layers; j++) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))\n\t\t\t\tnb_bits++;\n\t\t\tgf_bs_read_int_log_idx2(bs, nb_bits, \"highest_layer_idx_plus1\", i, j);\n\t\t}\n\n\n\tif (gf_bs_read_int_log(bs, 1, \"vps_sub_layers_max_minus1_present_flag\")) {\n\t\tfor (i = 0; i < vps->max_layers; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, 3, \"sub_layers_vps_max_minus1\", i);\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \"max_tid_ref_present_flag\")) {\n\t\tfor (i = 0; i < (vps->max_layers - 1); i++) {\n\t\t\tfor (j = i + 1; j < vps->max_layers; j++) {\n\t\t\t\tif (vps->direct_dependency_flag[j][i])\n\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"default_ref_layers_active_flag\");\n\n\tvps->num_profile_tier_level = 1 + gf_bs_read_ue_log(bs, \"num_profile_tier_level\");\n\tif (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of PTLs in VPS %d\\n\", vps->num_profile_tier_level));\n\t\tvps->num_profile_tier_level = 1;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {\n\t\tBool vps_profile_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_profile_present_flag\", i);\n\t\thevc_profile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers - 1, &vps->ext_ptl[i - 1], i-1);\n\t}\n\n\tNumLayerSets = vps->num_layer_sets + num_add_layer_set;\n\tnum_add_olss = 0;\n\n\tif (NumLayerSets > 1) {\n\t\tnum_add_olss = gf_bs_read_ue_log(bs, \"num_add_olss\");\n\t\tdefault_output_layer_idc = gf_bs_read_int_log(bs, 2, \"default_output_layer_idc\");\n\t\tdefault_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;\n\t}\n\tvps->num_output_layer_sets = num_add_olss + NumLayerSets;\n\n\tif (vps->num_output_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of output layer sets in VPS %d, max %d supported\\n\", vps->num_output_layer_sets, MAX_LHVC_LAYERS));\n\t\tvps->num_output_layer_sets = 1;\n\t\treturn GF_FALSE;\n\t}\n\n\tlayer_set_idx_for_ols_minus1[0] = 1;\n\tvps->output_layer_flag[0][0] = 1;\n\n\tfor (i = 0; i < vps->num_output_layer_sets; i++) {\n\t\tif ((NumLayerSets > 2) && (i >= NumLayerSets)) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (NumLayerSets - 1))\n\t\t\t\tnb_bits++;\n\t\t\tlayer_set_idx_for_ols_minus1[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"layer_set_idx_for_ols_minus1\", i);\n\t\t}\n\t\telse\n\t\t\tlayer_set_idx_for_ols_minus1[i] = 0;\n\t\tols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;\n\n\t\tif ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\t\tvps->output_layer_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"output_layer_flag\", i, j);\n\t\t}\n\n\t\tif ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\t\tif ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_TRUE;\n\t\t\t\telse\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tu32 curLayerID;\n\t\t\t\tvps->necessary_layers_flag[i][j] = GF_TRUE;\n\t\t\t\tcurLayerID = vps->LayerSetLayerIdList[i][j];\n\t\t\t\tfor (k = 0; k < j; k++) {\n\t\t\t\t\tu32 refLayerId = vps->LayerSetLayerIdList[i][k];\n\t\t\t\t\tif (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])\n\t\t\t\t\t\tvps->necessary_layers_flag[i][k] = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_necessary_layers[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (vps->necessary_layers_flag[i][j])\n\t\t\t\tvps->num_necessary_layers[i] += 1;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tif (vps->base_layer_internal_flag) {\n\t\t\t\tif (vps->max_layers > 1)\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 1;\n\t\t\t\telse\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tnb_bits = 1;\n\t\twhile ((u32)(1 << nb_bits) < vps->num_profile_tier_level)\n\t\t\tnb_bits++;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\tif (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)\n\t\t\t\tvps->profile_tier_level_idx[i][j] = gf_bs_read_int_log_idx2(bs, nb_bits, \"profile_tier_level_idx\", i, j);\n\t\t\telse\n\t\t\t\tvps->profile_tier_level_idx[i][j] = 0;\n\n\n\t\tnb_output_layers_in_output_layer_set[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tnb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];\n\t\t\t}\n\t\t}\n\t\tif (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)\n\t\t\tvps->alt_output_layer_flag[i] = gf_bs_read_int_log_idx(bs, 1, \"alt_output_layer_flag\", i);\n\t}\n\n\tvps->num_rep_formats = 1 + gf_bs_read_ue_log(bs, \"num_rep_formats_minus1\");\n\tif (vps->num_rep_formats > 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of rep formats in VPS %d\\n\", vps->num_rep_formats));\n\t\tvps->num_rep_formats = 0;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = 0; i < vps->num_rep_formats; i++) {\n\t\tlhvc_parse_rep_format(&vps->rep_formats[i], bs, i);\n\t}\n\tif (vps->num_rep_formats > 1)\n\t\trep_format_idx_present_flag = gf_bs_read_int_log(bs, 1, \"rep_format_idx_present_flag\");\n\telse\n\t\trep_format_idx_present_flag = 0;\n\n\tvps->rep_format_idx[0] = 0;\n\tnb_bits = 1;\n\twhile ((u32)(1 << nb_bits) < vps->num_rep_formats)\n\t\tnb_bits++;\n\tfor (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {\n\t\tif (rep_format_idx_present_flag) {\n\t\t\tvps->rep_format_idx[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"rep_format_idx\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;\n\t\t}\n\t}\n\t//TODO - we don't use the rest ...\n\n\treturn GF_TRUE;\n}",
      "line_statements": [
        [
          7729,
          "\t\t\tu32 num_bits=0;"
        ],
        [
          7730,
          "\t\t\tfor (i = 0; i < num_scalability_types-1; i++) {"
        ],
        [
          7732,
          "\t\t\t\tnum_bits+=dimension_id_len[i];"
        ],
        [
          7736,
          "\t\t\tif (num_bits>=6) {"
        ],
        [
          7737,
          "\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Too many its defined for dimension IDs (%d vs 5 max)\\n\", num_bits));"
        ],
        [
          7738,
          "\t\t\t\treturn -1;"
        ],
        [
          7739,
          "\t\t\t}"
        ],
        [
          7740,
          "\t\t\tdimension_id_len[num_scalability_types - 1] = 6 - num_bits; //1 + (5 - dim_bit_offset[num_scalability_types - 1]);"
        ],
        [
          7741,
          "\t\t\tdim_bit_offset[num_scalability_types - 1] = 6;"
        ]
      ],
      "statements": [
        [
          7729,
          "u32 num_bits=0;"
        ],
        [
          7730,
          "for (i = 0; i < num_scalability_types-1; i++) {"
        ],
        [
          7732,
          "num_bits+=dimension_id_len[i];"
        ],
        [
          7736,
          "if (num_bits>=6)"
        ],
        [
          7737,
          "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Too many its defined for dimension IDs (%d vs 5 max)\\n\", num_bits));"
        ],
        [
          7738,
          "return -1;"
        ],
        [
          7739,
          "\t\t\t}\n"
        ],
        [
          7740,
          "\t\t\tdimension_id_len[num_scalability_types - 1] = 6 - num_bits; //1 + (5 - dim_bit_offset[num_scalability_types - 1]);\n"
        ],
        [
          7741,
          "dim_bit_offset[num_scalability_types - 1] = 6;"
        ]
      ],
      "cve": "CVE-2023-48014"
    },
    {
      "commit_id": "89c6efa61f5709327ecfa24bff18e57a4e80c7fa",
      "filepath": "drivers/i2c/i2c-core-smbus.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "i2c_smbus_xfer_emulated",
      "func_body": "static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,\n\t\t\t\t   unsigned short flags,\n\t\t\t\t   char read_write, u8 command, int size,\n\t\t\t\t   union i2c_smbus_data *data)\n{\n\t/* So we need to generate a series of msgs. In the case of writing, we\n\t  need to use only one message; when reading, we need two. We initialize\n\t  most things with sane defaults, to keep the code below somewhat\n\t  simpler. */\n\tunsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];\n\tunsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];\n\tint num = read_write == I2C_SMBUS_READ ? 2 : 1;\n\tint i;\n\tu8 partial_pec = 0;\n\tint status;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = addr,\n\t\t\t.flags = flags,\n\t\t\t.len = 1,\n\t\t\t.buf = msgbuf0,\n\t\t}, {\n\t\t\t.addr = addr,\n\t\t\t.flags = flags | I2C_M_RD,\n\t\t\t.len = 0,\n\t\t\t.buf = msgbuf1,\n\t\t},\n\t};\n\n\tmsgbuf0[0] = command;\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tmsg[0].len = 0;\n\t\t/* Special case: The read/write field is used as data */\n\t\tmsg[0].flags = flags | (read_write == I2C_SMBUS_READ ?\n\t\t\t\t\tI2C_M_RD : 0);\n\t\tnum = 1;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\t/* Special case: only a read! */\n\t\t\tmsg[0].flags = I2C_M_RD | flags;\n\t\t\tnum = 1;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_READ)\n\t\t\tmsg[1].len = 1;\n\t\telse {\n\t\t\tmsg[0].len = 2;\n\t\t\tmsgbuf0[1] = data->byte;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_READ)\n\t\t\tmsg[1].len = 2;\n\t\telse {\n\t\t\tmsg[0].len = 3;\n\t\t\tmsgbuf0[1] = data->word & 0xff;\n\t\t\tmsgbuf0[2] = data->word >> 8;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tnum = 2; /* Special case */\n\t\tread_write = I2C_SMBUS_READ;\n\t\tmsg[0].len = 3;\n\t\tmsg[1].len = 2;\n\t\tmsgbuf0[1] = data->word & 0xff;\n\t\tmsgbuf0[2] = data->word >> 8;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tmsg[1].flags |= I2C_M_RECV_LEN;\n\t\t\tmsg[1].len = 1; /* block length will be added by\n\t\t\t\t\t   the underlying bus driver */\n\t\t} else {\n\t\t\tmsg[0].len = data->block[0] + 2;\n\t\t\tif (msg[0].len > I2C_SMBUS_BLOCK_MAX + 2) {\n\t\t\t\tdev_err(&adapter->dev,\n\t\t\t\t\t\"Invalid block write size %d\\n\",\n\t\t\t\t\tdata->block[0]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tfor (i = 1; i < msg[0].len; i++)\n\t\t\t\tmsgbuf0[i] = data->block[i-1];\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tnum = 2; /* Another special case */\n\t\tread_write = I2C_SMBUS_READ;\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX) {\n\t\t\tdev_err(&adapter->dev,\n\t\t\t\t\"Invalid block write size %d\\n\",\n\t\t\t\tdata->block[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmsg[0].len = data->block[0] + 2;\n\t\tfor (i = 1; i < msg[0].len; i++)\n\t\t\tmsgbuf0[i] = data->block[i-1];\n\t\tmsg[1].flags |= I2C_M_RECV_LEN;\n\t\tmsg[1].len = 1; /* block length will be added by\n\t\t\t\t   the underlying bus driver */\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tmsg[1].len = data->block[0];\n\t\t} else {\n\t\t\tmsg[0].len = data->block[0] + 1;\n\t\t\tif (msg[0].len > I2C_SMBUS_BLOCK_MAX + 1) {\n\t\t\t\tdev_err(&adapter->dev,\n\t\t\t\t\t\"Invalid block write size %d\\n\",\n\t\t\t\t\tdata->block[0]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tfor (i = 1; i <= data->block[0]; i++)\n\t\t\t\tmsgbuf0[i] = data->block[i];\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&adapter->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\ti = ((flags & I2C_CLIENT_PEC) && size != I2C_SMBUS_QUICK\n\t\t\t\t      && size != I2C_SMBUS_I2C_BLOCK_DATA);\n\tif (i) {\n\t\t/* Compute PEC if first message is a write */\n\t\tif (!(msg[0].flags & I2C_M_RD)) {\n\t\t\tif (num == 1) /* Write only */\n\t\t\t\ti2c_smbus_add_pec(&msg[0]);\n\t\t\telse /* Write followed by read */\n\t\t\t\tpartial_pec = i2c_smbus_msg_pec(0, &msg[0]);\n\t\t}\n\t\t/* Ask for PEC if last message is a read */\n\t\tif (msg[num-1].flags & I2C_M_RD)\n\t\t\tmsg[num-1].len++;\n\t}\n\n\tstatus = i2c_transfer(adapter, msg, num);\n\tif (status < 0)\n\t\treturn status;\n\n\t/* Check PEC if last message is a read */\n\tif (i && (msg[num-1].flags & I2C_M_RD)) {\n\t\tstatus = i2c_smbus_check_pec(partial_pec, &msg[num-1]);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tif (read_write == I2C_SMBUS_READ)\n\t\tswitch (size) {\n\t\tcase I2C_SMBUS_BYTE:\n\t\t\tdata->byte = msgbuf0[0];\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_BYTE_DATA:\n\t\t\tdata->byte = msgbuf1[0];\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_WORD_DATA:\n\t\tcase I2C_SMBUS_PROC_CALL:\n\t\t\tdata->word = msgbuf1[0] | (msgbuf1[1] << 8);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t\tfor (i = 0; i < data->block[0]; i++)\n\t\t\t\tdata->block[i+1] = msgbuf1[i];\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\t\tfor (i = 0; i < msgbuf1[0] + 1; i++)\n\t\t\t\tdata->block[i] = msgbuf1[i];\n\t\t\tbreak;\n\t\t}\n\treturn 0;\n}\n",
      "line_statements": [
        [
          404,
          "\t\t\tif (msg[0].len > I2C_SMBUS_BLOCK_MAX + 1) {\n"
        ],
        [
          405,
          "\t\t\t\tdev_err(&adapter->dev,\n"
        ],
        [
          406,
          "\t\t\t\t\t\"Invalid block write size %d\\n\",\n"
        ],
        [
          407,
          "\t\t\t\t\tdata->block[0]);\n"
        ],
        [
          408,
          "\t\t\t\treturn -EINVAL;\n"
        ],
        [
          409,
          "\t\t\t}\n"
        ]
      ],
      "statements": [
        [
          404,
          "if (msg[0].len > I2C_SMBUS_BLOCK_MAX + 1)"
        ],
        [
          405,
          "dev_err(&adapter->dev,\n\t\t\t\t\t\"Invalid block write size %d\\n\",\n\t\t\t\t\tdata->block[0]);"
        ],
        [
          408,
          "return -EINVAL;"
        ],
        [
          409,
          "\t\t\t}\n"
        ]
      ],
      "cve": "CVE-2017-18551"
    },
    {
      "commit_id": "902bc9190331343b2017211debcec8d2ab87e17a",
      "filepath": "src/dec/vp8l_dec.c",
      "project": "libwebp",
      "project_repo_path": "symbol_backend_projects/libwebp",
      "is_vulnerable": false,
      "func_name": "ReadHuffmanCodeLengths",
      "func_body": "static int ReadHuffmanCodeLengths(\n    VP8LDecoder* const dec, const int* const code_length_code_lengths,\n    int num_symbols, int* const code_lengths) {\n  int ok = 0;\n  VP8LBitReader* const br = &dec->br_;\n  int symbol;\n  int max_symbol;\n  int prev_code_len = DEFAULT_CODE_LENGTH;\n  HuffmanTables tables;\n\n  if (!VP8LHuffmanTablesAllocate(1 << LENGTHS_TABLE_BITS, &tables) ||\n      !VP8LBuildHuffmanTable(&tables, LENGTHS_TABLE_BITS,\n                             code_length_code_lengths, NUM_CODE_LENGTH_CODES)) {\n    goto End;\n  }\n\n  if (VP8LReadBits(br, 1)) {    // use length\n    const int length_nbits = 2 + 2 * VP8LReadBits(br, 3);\n    max_symbol = 2 + VP8LReadBits(br, length_nbits);\n    if (max_symbol > num_symbols) {\n      goto End;\n    }\n  } else {\n    max_symbol = num_symbols;\n  }\n\n  symbol = 0;\n  while (symbol < num_symbols) {\n    const HuffmanCode* p;\n    int code_len;\n    if (max_symbol-- == 0) break;\n    VP8LFillBitWindow(br);\n    p = &tables.curr_segment->start[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];\n    VP8LSetBitPos(br, br->bit_pos_ + p->bits);\n    code_len = p->value;\n    if (code_len < kCodeLengthLiterals) {\n      code_lengths[symbol++] = code_len;\n      if (code_len != 0) prev_code_len = code_len;\n    } else {\n      const int use_prev = (code_len == kCodeLengthRepeatCode);\n      const int slot = code_len - kCodeLengthLiterals;\n      const int extra_bits = kCodeLengthExtraBits[slot];\n      const int repeat_offset = kCodeLengthRepeatOffsets[slot];\n      int repeat = VP8LReadBits(br, extra_bits) + repeat_offset;\n      if (symbol + repeat > num_symbols) {\n        goto End;\n      } else {\n        const int length = use_prev ? prev_code_len : 0;\n        while (repeat-- > 0) code_lengths[symbol++] = length;\n      }\n    }\n  }\n  ok = 1;\n\n End:\n  VP8LHuffmanTablesDeallocate(&tables);\n  if (!ok) return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  return ok;\n}",
      "line_statements": [
        [
          265,
          "  HuffmanTables tables;"
        ],
        [
          267,
          "  if (!VP8LHuffmanTablesAllocate(1 << LENGTHS_TABLE_BITS, &tables) ||"
        ],
        [
          268,
          "      !VP8LBuildHuffmanTable(&tables, LENGTHS_TABLE_BITS,"
        ],
        [
          269,
          "                             code_length_code_lengths, NUM_CODE_LENGTH_CODES)) {"
        ],
        [
          289,
          "    p = &tables.curr_segment->start[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];"
        ],
        [
          312,
          "  VP8LHuffmanTablesDeallocate(&tables);"
        ]
      ],
      "statements": [
        [
          265,
          "HuffmanTables tables;"
        ],
        [
          267,
          "if (!VP8LHuffmanTablesAllocate(1 << LENGTHS_TABLE_BITS, &tables) ||\n      !VP8LBuildHuffmanTable(&tables, LENGTHS_TABLE_BITS,\n                             code_length_code_lengths, NUM_CODE_LENGTH_CODES))"
        ],
        [
          289,
          "p = &tables.curr_segment->start[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];"
        ],
        [
          312,
          "VP8LHuffmanTablesDeallocate(&tables);"
        ]
      ],
      "cve": "CVE-2023-4863"
    },
    {
      "commit_id": "df8559e7bdbc6065276e786217eeee70f28fce66",
      "filepath": "jscompile.c",
      "project": "mujs",
      "project_repo_path": "symbol_backend_projects/mujs",
      "is_vulnerable": false,
      "func_name": "labeljumps",
      "func_body": "static void labeljumps(JF, js_Ast *stm, int baddr, int caddr)\n{\n\tjs_JumpList *jump = stm->jumps;\n\twhile (jump) {\n\t\tjs_JumpList *next = jump->next;\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjs_free(J, jump);\n\t\tjump = next;\n\t}\n\tstm->jumps = NULL;\n}",
      "line_statements": [
        [
          797,
          "static void labeljumps(JF, js_Ast *stm, int baddr, int caddr)"
        ],
        [
          799,
          "\tjs_JumpList *jump = stm->jumps;"
        ],
        [
          801,
          "\t\tjs_JumpList *next = jump->next;"
        ],
        [
          806,
          "\t\tjs_free(J, jump);"
        ],
        [
          807,
          "\t\tjump = next;"
        ],
        [
          809,
          "\tstm->jumps = NULL;"
        ]
      ],
      "statements": [
        [
          797,
          "static void labeljumps(JF, js_Ast *stm, int baddr, int caddr)"
        ],
        [
          799,
          "js_JumpList *jump = stm->jumps;"
        ],
        [
          801,
          "js_JumpList *next = jump->next;"
        ],
        [
          806,
          "js_free(J, jump);"
        ],
        [
          807,
          "jump = next;"
        ],
        [
          809,
          "stm->jumps = NULL;"
        ]
      ],
      "cve": "CVE-2021-45005"
    },
    {
      "commit_id": "ff70494dd389ba570dbdbf36f217c28d4381c6b5",
      "filepath": "src/airodump-ng.c",
      "project": "aircrack-ng",
      "project_repo_path": "symbol_backend_projects/aircrack-ng",
      "is_vulnerable": false,
      "func_name": "gps_tracker",
      "func_body": "void gps_tracker( void )\n{\n\tssize_t unused;\n    int gpsd_sock;\n    char line[256], *temp;\n    struct sockaddr_in gpsd_addr;\n    int ret, is_json, pos;\n    fd_set read_fd;\n    struct timeval timeout;\n\n    /* attempt to connect to localhost, port 2947 */\n\n    pos = 0;\n    gpsd_sock = socket( AF_INET, SOCK_STREAM, 0 );\n\n    if( gpsd_sock < 0 ) {\n        return;\n    }\n\n    gpsd_addr.sin_family      = AF_INET;\n    gpsd_addr.sin_port        = htons( 2947 );\n    gpsd_addr.sin_addr.s_addr = inet_addr( \"127.0.0.1\" );\n\n    if( connect( gpsd_sock, (struct sockaddr *) &gpsd_addr,\n                 sizeof( gpsd_addr ) ) < 0 ) {\n        return;\n    }\n\n    // Check if it's GPSd < 2.92 or the new one\n    // 2.92+ immediately send stuff\n    // < 2.92 requires to send PVTAD command\n    FD_ZERO(&read_fd);\n    FD_SET(gpsd_sock, &read_fd);\n    timeout.tv_sec = 1;\n    timeout.tv_usec = 0;\n    is_json = select(gpsd_sock + 1, &read_fd, NULL, NULL, &timeout);\n    if (is_json) {\n    \t/*\n\t\t\t{\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n\t\t\t?WATCH={\"json\":true};\n\t\t\t{\"class\":\"DEVICES\",\"devices\":[]}\n    \t */\n\n\n    \t// Get the crap and ignore it: {\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n    \tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n    \t\treturn;\n\n    \tis_json = (line[0] == '{');\n    \tif (is_json) {\n\t\t\t// Send ?WATCH={\"json\":true};\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tstrcpy(line, \"?WATCH={\\\"json\\\":true};\\n\");\n\t\t\tif( send( gpsd_sock, line, 22, 0 ) != 22 )\n\t\t\t\treturn;\n\n\t\t\t// Check that we have devices\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\t// Stop processing if there is no device\n\t\t\tif (strncmp(line, \"{\\\"class\\\":\\\"DEVICES\\\",\\\"devices\\\":[]}\", 32) == 0) {\n\t\t\t\tclose(gpsd_sock);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpos = strlen(line);\n\t\t\t}\n    \t}\n    }\n\n    /* loop reading the GPS coordinates */\n\n    while( G.do_exit == 0 )\n    {\n        usleep( 500000 );\n        memset( G.gps_loc, 0, sizeof( float ) * 5 );\n\n        /* read position, speed, heading, altitude */\n        if (is_json) {\n        \t// Format definition: http://catb.org/gpsd/gpsd_json.html\n\n        \tif (pos == sizeof( line )) {\n        \t\tmemset(line, 0, sizeof(line));\n        \t\tpos = 0;\n        \t}\n\n        \t// New version, JSON\n        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - pos - 1, 0 ) <= 0 )\n        \t\treturn;\n\n        \t// search for TPV class: {\"class\":\"TPV\"\n        \ttemp = strstr(line, \"{\\\"class\\\":\\\"TPV\\\"\");\n        \tif (temp == NULL) {\n        \t\tcontinue;\n        \t}\n\n        \t// Make sure the data we have is complete\n        \tif (strchr(temp, '}') == NULL) {\n        \t\t// Move the data at the beginning of the buffer;\n        \t\tpos = strlen(temp);\n        \t\tif (temp != line) {\n        \t\t\tmemmove(line, temp, pos);\n        \t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n        \t\t}\n        \t}\n\n\t\t\t// Example line: {\"class\":\"TPV\",\"tag\":\"MID2\",\"device\":\"/dev/ttyUSB0\",\"time\":1350957517.000,\"ept\":0.005,\"lat\":46.878936576,\"lon\":-115.832602964,\"alt\":1968.382,\"track\":0.0000,\"speed\":0.000,\"climb\":0.000,\"mode\":3}\n\n        \t// Latitude\n        \ttemp = strstr(temp, \"\\\"lat\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[0]);\n\n\t\t\t// Longitude\n\t\t\ttemp = strstr(temp, \"\\\"lon\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[1]);\n\n\t\t\t// Altitude\n\t\t\ttemp = strstr(temp, \"\\\"alt\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[4]);\n\n\t\t\t// Speed\n\t\t\ttemp = strstr(temp, \"\\\"speed\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[2]);\n\n\t\t\t// No more heading\n\n\t\t\t// Get the next TPV class\n\t\t\ttemp = strstr(temp, \"{\\\"class\\\":\\\"TPV\\\"\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\t\tpos = 0;\n\t\t\t} else {\n\t\t\t\tpos = strlen(temp);\n\t\t\t\tmemmove(line, temp, pos);\n\t\t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n\t\t\t}\n\n        } else {\n        \tmemset( line, 0, sizeof( line ) );\n\n\t\t\tsnprintf( line,  sizeof( line ) - 1, \"PVTAD\\r\\n\" );\n\t\t\tif( send( gpsd_sock, line, 7, 0 ) != 7 )\n\t\t\t\treturn;\n\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\tif( memcmp( line, \"GPSD,P=\", 7 ) != 0 )\n\t\t\t\tcontinue;\n\n\t\t\t/* make sure the coordinates are present */\n\n\t\t\tif( line[7] == '?' )\n\t\t\t\tcontinue;\n\n\t\t\tret = sscanf( line + 7, \"%f %f\", &G.gps_loc[0], &G.gps_loc[1] );\n\n\t\t\tif( ( temp = strstr( line, \"V=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[2] ); /* speed */\n\n\t\t\tif( ( temp = strstr( line, \"T=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[3] ); /* heading */\n\n\t\t\tif( ( temp = strstr( line, \"A=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[4] ); /* altitude */\n        }\n\n        if (G.record_data)\n\t\t\tfputs( line, G.f_gps );\n\n\t\tG.save_gps = 1;\n\n        if (G.do_exit == 0)\n\t\t{\n\t\t\tunused = write( G.gc_pipe[1], G.gps_loc, sizeof( float ) * 5 );\n\t\t\tkill( getppid(), SIGUSR2 );\n\t\t}\n    }\n}",
      "line_statements": [
        [
          4500,
          "        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - pos - 1, 0 ) <= 0 )"
        ]
      ],
      "statements": [
        [
          4500,
          "if( recv( gpsd_sock, line + pos, sizeof( line ) - pos - 1, 0 ) <= 0 )"
        ]
      ],
      "cve": "CVE-2014-8321"
    },
    {
      "commit_id": "535a786f124b739e3c857529cecc29e4eeb79778",
      "filepath": "src/podofo/main/PdfXRefStreamParserObject.cpp",
      "project": "podofo",
      "project_repo_path": "symbol_backend_projects/podofo",
      "is_vulnerable": true,
      "func_name": "PdfXRefStreamParserObject::ReadXRefTable",
      "func_body": "void PdfXRefStreamParserObject::ReadXRefTable()\n{\n    int64_t size = this->GetDictionary().FindKeyAs<int64_t>(PdfName::KeySize, 0);\n    auto& arrObj = this->GetDictionary().MustFindKey(\"W\");\n\n    // The pdf reference states that W is always an array with 3 entries\n    // all of them have to be integers\n    const PdfArray* arr;\n    if (!arrObj.TryGetArray(arr) || arr->size() != 3)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n\n    int64_t wArray[W_ARRAY_SIZE] = { 0, 0, 0 };\n    int64_t num;\n    for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n    {\n\n        if (!(*arr)[i].TryGetNumber(num))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n\n        wArray[i] = num;\n    }\n\n    vector<int64_t> indices;\n    getIndices(indices, static_cast<int64_t>(size));\n\n    parseStream(wArray, indices);\n}",
      "line_statements": [
        [
          70,
          "        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");"
        ],
        [
          78,
          "            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");"
        ]
      ],
      "statements": [
        [
          70,
          "PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");"
        ],
        [
          78,
          "PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");"
        ]
      ],
      "cve": "CVE-2023-2241"
    },
    {
      "commit_id": "1b422459f07353adce2878806d5247d9e91fb397",
      "filepath": "pdf.c",
      "project": "pdfresurrect",
      "project_repo_path": "symbol_backend_projects/pdfresurrect",
      "is_vulnerable": true,
      "func_name": "pdf_get_version",
      "func_body": "void pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header, *c;\n\n    header = get_header(fp);\n\n    /* Locate version string start and make sure we dont go past header */\n    if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n\n    free(header);\n}",
      "line_statements": [
        [
          196,
          "    char *header, *c;"
        ],
        [
          197,
          ""
        ],
        [
          198,
          "    header = get_header(fp);"
        ],
        [
          202,
          "        (c + strlen(\"%PDF-M.m\") + 2))"
        ]
      ],
      "statements": [
        [
          196,
          "char *header, *c;"
        ],
        [
          197,
          "\n"
        ],
        [
          198,
          "header = get_header(fp);"
        ],
        [
          201,
          "if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))"
        ]
      ],
      "cve": "CVE-2020-20740"
    },
    {
      "commit_id": "cb4636f7c0af2e97a4eef7a3cdcbd85a71247bfe",
      "filepath": "core/utils.c",
      "project": "uwsgi",
      "project_repo_path": "symbol_backend_projects/uwsgi",
      "is_vulnerable": false,
      "func_name": "uwsgi_expand_path",
      "func_body": "char *uwsgi_expand_path(char *dir, int dir_len, char *ptr) {\n\tif (dir_len > PATH_MAX)\n\t{\n\t\tuwsgi_log(\"invalid path size: %d (max %d)\\n\", dir_len, PATH_MAX);\n\t\treturn NULL;\n\t}\n\tchar *src = uwsgi_concat2n(dir, dir_len, \"\", 0);\n\tchar *dst = ptr;\n\tif (!dst)\n\t\tdst = uwsgi_malloc(PATH_MAX + 1);\n\tif (!realpath(src, dst)) {\n\t\tuwsgi_error_realpath(src);\n\t\tif (!ptr)\n\t\t\tfree(dst);\n\t\tfree(src);\n\t\treturn NULL;\n\t}\n\tfree(src);\n\treturn dst;\n}",
      "line_statements": [
        [
          3677,
          "\tif (dir_len > PATH_MAX)"
        ],
        [
          3678,
          "\t{"
        ],
        [
          3679,
          "\t\tuwsgi_log(\"invalid path size: %d (max %d)\\n\", dir_len, PATH_MAX);"
        ],
        [
          3680,
          "\t\treturn NULL;"
        ],
        [
          3681,
          "\t}"
        ],
        [
          3682,
          "\tchar *src = uwsgi_concat2n(dir, dir_len, \"\", 0);"
        ],
        [
          3690,
          "\t\tfree(src);"
        ],
        [
          3693,
          "\tfree(src);"
        ]
      ],
      "statements": [
        [
          3677,
          "if (dir_len > PATH_MAX)"
        ],
        [
          3678,
          "\t{\n"
        ],
        [
          3679,
          "uwsgi_log(\"invalid path size: %d (max %d)\\n\", dir_len, PATH_MAX);"
        ],
        [
          3680,
          "return NULL;"
        ],
        [
          3681,
          "\t}\n"
        ],
        [
          3682,
          "char *src = uwsgi_concat2n(dir, dir_len, \"\", 0);"
        ],
        [
          3690,
          "free(src);"
        ],
        [
          3693,
          "free(src);"
        ]
      ],
      "cve": "CVE-2018-6758"
    },
    {
      "commit_id": "e2b3b35eb9896f26c98b9a2c047d9111638059a2",
      "filepath": "drivers/vhost/net.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "handle_rx",
      "func_body": "static void handle_rx(struct vhost_net *net)\n{\n\tstruct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];\n\tstruct vhost_virtqueue *vq = &nvq->vq;\n\tunsigned uninitialized_var(in), log;\n\tstruct vhost_log *vq_log;\n\tstruct msghdr msg = {\n\t\t.msg_name = NULL,\n\t\t.msg_namelen = 0,\n\t\t.msg_control = NULL, /* FIXME: get and handle RX aux data. */\n\t\t.msg_controllen = 0,\n\t\t.msg_flags = MSG_DONTWAIT,\n\t};\n\tstruct virtio_net_hdr hdr = {\n\t\t.flags = 0,\n\t\t.gso_type = VIRTIO_NET_HDR_GSO_NONE\n\t};\n\tsize_t total_len = 0;\n\tint err, mergeable;\n\ts16 headcount, nheads = 0;\n\tsize_t vhost_hlen, sock_hlen;\n\tsize_t vhost_len, sock_len;\n\tstruct socket *sock;\n\tstruct iov_iter fixup;\n\t__virtio16 num_buffers;\n\n\tmutex_lock(&vq->mutex);\n\tsock = vq->private_data;\n\tif (!sock)\n\t\tgoto out;\n\n\tif (!vq_iotlb_prefetch(vq))\n\t\tgoto out;\n\n\tvhost_disable_notify(&net->dev, vq);\n\tvhost_net_disable_vq(net, vq);\n\n\tvhost_hlen = nvq->vhost_hlen;\n\tsock_hlen = nvq->sock_hlen;\n\n\tvq_log = unlikely(vhost_has_feature(vq, VHOST_F_LOG_ALL)) ?\n\t\tvq->log : NULL;\n\tmergeable = vhost_has_feature(vq, VIRTIO_NET_F_MRG_RXBUF);\n\n\twhile ((sock_len = vhost_net_rx_peek_head_len(net, sock->sk))) {\n\t\tsock_len += sock_hlen;\n\t\tvhost_len = sock_len + vhost_hlen;\n\t\theadcount = get_rx_bufs(vq, vq->heads + nheads, vhost_len,\n\t\t\t\t\t&in, vq_log, &log,\n\t\t\t\t\tlikely(mergeable) ? UIO_MAXIOV : 1);\n\t\t/* On error, stop handling until the next kick. */\n\t\tif (unlikely(headcount < 0))\n\t\t\tgoto out;\n\t\t/* OK, now we need to know about added descriptors. */\n\t\tif (!headcount) {\n\t\t\tif (unlikely(vhost_enable_notify(&net->dev, vq))) {\n\t\t\t\t/* They have slipped one in as we were\n\t\t\t\t * doing that: check again. */\n\t\t\t\tvhost_disable_notify(&net->dev, vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Nothing new?  Wait for eventfd to tell us\n\t\t\t * they refilled. */\n\t\t\tgoto out;\n\t\t}\n\t\tif (nvq->rx_ring)\n\t\t\tmsg.msg_control = vhost_net_buf_consume(&nvq->rxq);\n\t\t/* On overrun, truncate and discard */\n\t\tif (unlikely(headcount > UIO_MAXIOV)) {\n\t\t\tiov_iter_init(&msg.msg_iter, READ, vq->iov, 1, 1);\n\t\t\terr = sock->ops->recvmsg(sock, &msg,\n\t\t\t\t\t\t 1, MSG_DONTWAIT | MSG_TRUNC);\n\t\t\tpr_debug(\"Discarded rx packet: len %zd\\n\", sock_len);\n\t\t\tcontinue;\n\t\t}\n\t\t/* We don't need to be notified again. */\n\t\tiov_iter_init(&msg.msg_iter, READ, vq->iov, in, vhost_len);\n\t\tfixup = msg.msg_iter;\n\t\tif (unlikely((vhost_hlen))) {\n\t\t\t/* We will supply the header ourselves\n\t\t\t * TODO: support TSO.\n\t\t\t */\n\t\t\tiov_iter_advance(&msg.msg_iter, vhost_hlen);\n\t\t}\n\t\terr = sock->ops->recvmsg(sock, &msg,\n\t\t\t\t\t sock_len, MSG_DONTWAIT | MSG_TRUNC);\n\t\t/* Userspace might have consumed the packet meanwhile:\n\t\t * it's not supposed to do this usually, but might be hard\n\t\t * to prevent. Discard data we got (if any) and keep going. */\n\t\tif (unlikely(err != sock_len)) {\n\t\t\tpr_debug(\"Discarded rx packet: \"\n\t\t\t\t \" len %d, expected %zd\\n\", err, sock_len);\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Supply virtio_net_hdr if VHOST_NET_F_VIRTIO_NET_HDR */\n\t\tif (unlikely(vhost_hlen)) {\n\t\t\tif (copy_to_iter(&hdr, sizeof(hdr),\n\t\t\t\t\t &fixup) != sizeof(hdr)) {\n\t\t\t\tvq_err(vq, \"Unable to write vnet_hdr \"\n\t\t\t\t       \"at addr %p\\n\", vq->iov->iov_base);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Header came from socket; we'll need to patch\n\t\t\t * ->num_buffers over if VIRTIO_NET_F_MRG_RXBUF\n\t\t\t */\n\t\t\tiov_iter_advance(&fixup, sizeof(hdr));\n\t\t}\n\t\t/* TODO: Should check and handle checksum. */\n\n\t\tnum_buffers = cpu_to_vhost16(vq, headcount);\n\t\tif (likely(mergeable) &&\n\t\t    copy_to_iter(&num_buffers, sizeof num_buffers,\n\t\t\t\t &fixup) != sizeof num_buffers) {\n\t\t\tvq_err(vq, \"Failed num_buffers write\");\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tgoto out;\n\t\t}\n\t\tnheads += headcount;\n\t\tif (nheads > VHOST_RX_BATCH) {\n\t\t\tvhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\n\t\t\t\t\t\t    nheads);\n\t\t\tnheads = 0;\n\t\t}\n\t\tif (unlikely(vq_log))\n\t\t\tvhost_log_write(vq, vq_log, log, vhost_len);\n\t\ttotal_len += vhost_len;\n\t\tif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\n\t\t\tvhost_poll_queue(&vq->poll);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tvhost_net_enable_vq(net, vq);\nout:\n\tif (nheads)\n\t\tvhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\n\t\t\t\t\t    nheads);\n\tmutex_unlock(&vq->mutex);\n}\n",
      "line_statements": [
        [
          759,
          "\ts16 headcount, nheads = 0;\n"
        ],
        [
          787,
          "\t\theadcount = get_rx_bufs(vq, vq->heads + nheads, vhost_len,\n"
        ],
        [
          859,
          "\t\tnheads += headcount;\n"
        ],
        [
          860,
          "\t\tif (nheads > VHOST_RX_BATCH) {\n"
        ],
        [
          861,
          "\t\t\tvhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\n"
        ],
        [
          862,
          "\t\t\t\t\t\t    nheads);\n"
        ],
        [
          863,
          "\t\t\tnheads = 0;\n"
        ],
        [
          864,
          "\t\t}\n"
        ],
        [
          875,
          "\tif (nheads)\n"
        ],
        [
          876,
          "\t\tvhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\n"
        ],
        [
          877,
          "\t\t\t\t\t    nheads);\n"
        ]
      ],
      "statements": [
        [
          759,
          "s16 headcount, nheads = 0;"
        ],
        [
          787,
          "headcount = get_rx_bufs(vq, vq->heads + nheads, vhost_len,\n\t\t\t\t\t&in, vq_log, &log,\n\t\t\t\t\tlikely(mergeable) ? UIO_MAXIOV : 1);"
        ],
        [
          859,
          "nheads += headcount;"
        ],
        [
          860,
          "if (nheads > VHOST_RX_BATCH)"
        ],
        [
          861,
          "vhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\n\t\t\t\t\t\t    nheads);"
        ],
        [
          863,
          "nheads = 0;"
        ],
        [
          864,
          "\t\t}\n"
        ],
        [
          875,
          "if (nheads)"
        ],
        [
          876,
          "vhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\n\t\t\t\t\t    nheads);"
        ]
      ],
      "cve": "CVE-2018-16880"
    },
    {
      "commit_id": "be1684930f5262a622d40ce7a6f1423530d87f89",
      "filepath": "drivers/gpu/drm/amd/amdgpu/amdgpu_ring.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "amdgpu_ring_init",
      "func_body": "int amdgpu_ring_init(struct amdgpu_device *adev, struct amdgpu_ring *ring,\n\t\t     unsigned int max_dw, struct amdgpu_irq_src *irq_src,\n\t\t     unsigned int irq_type, unsigned int hw_prio,\n\t\t     atomic_t *sched_score)\n{\n\tint r;\n\tint sched_hw_submission = amdgpu_sched_hw_submission;\n\tu32 *num_sched;\n\tu32 hw_ip;\n\tunsigned int max_ibs_dw;\n\n\t/* Set the hw submission limit higher for KIQ because\n\t * it's used for a number of gfx/compute tasks by both\n\t * KFD and KGD which may have outstanding fences and\n\t * it doesn't really use the gpu scheduler anyway;\n\t * KIQ tasks get submitted directly to the ring.\n\t */\n\tif (ring->funcs->type == AMDGPU_RING_TYPE_KIQ)\n\t\tsched_hw_submission = max(sched_hw_submission, 256);\n\telse if (ring == &adev->sdma.instance[0].page)\n\t\tsched_hw_submission = 256;\n\n\tif (ring->adev == NULL) {\n\t\tif (adev->num_rings >= AMDGPU_MAX_RINGS)\n\t\t\treturn -EINVAL;\n\n\t\tring->adev = adev;\n\t\tring->num_hw_submission = sched_hw_submission;\n\t\tring->sched_score = sched_score;\n\t\tring->vmid_wait = dma_fence_get_stub();\n\n\t\tif (!ring->is_mes_queue) {\n\t\t\tring->idx = adev->num_rings++;\n\t\t\tadev->rings[ring->idx] = ring;\n\t\t}\n\n\t\tr = amdgpu_fence_driver_init_ring(ring);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (ring->is_mes_queue) {\n\t\tring->rptr_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_RPTR_OFFS);\n\t\tring->wptr_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_WPTR_OFFS);\n\t\tring->fence_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_FENCE_OFFS);\n\t\tring->trail_fence_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_TRAIL_FENCE_OFFS);\n\t\tring->cond_exe_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_COND_EXE_OFFS);\n\t} else {\n\t\tr = amdgpu_device_wb_get(adev, &ring->rptr_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring rptr_offs wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = amdgpu_device_wb_get(adev, &ring->wptr_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring wptr_offs wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = amdgpu_device_wb_get(adev, &ring->fence_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring fence_offs wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = amdgpu_device_wb_get(adev, &ring->trail_fence_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring trail_fence_offs wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = amdgpu_device_wb_get(adev, &ring->cond_exe_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring cond_exec_polling wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tring->fence_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->fence_offs);\n\tring->fence_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->fence_offs);\n\n\tring->rptr_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->rptr_offs);\n\tring->rptr_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->rptr_offs);\n\n\tring->wptr_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->wptr_offs);\n\tring->wptr_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->wptr_offs);\n\n\tring->trail_fence_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->trail_fence_offs);\n\tring->trail_fence_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->trail_fence_offs);\n\n\tring->cond_exe_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->cond_exe_offs);\n\tring->cond_exe_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->cond_exe_offs);\n\n\t/* always set cond_exec_polling to CONTINUE */\n\t*ring->cond_exe_cpu_addr = 1;\n\n\tr = amdgpu_fence_driver_start_ring(ring, irq_src, irq_type);\n\tif (r) {\n\t\tdev_err(adev->dev, \"failed initializing fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tmax_ibs_dw = ring->funcs->emit_frame_size +\n\t\t     amdgpu_ring_max_ibs(ring->funcs->type) * ring->funcs->emit_ib_size;\n\tmax_ibs_dw = (max_ibs_dw + ring->funcs->align_mask) & ~ring->funcs->align_mask;\n\n\tif (WARN_ON(max_ibs_dw > max_dw))\n\t\tmax_dw = max_ibs_dw;\n\n\tring->ring_size = roundup_pow_of_two(max_dw * 4 * sched_hw_submission);\n\n\tring->buf_mask = (ring->ring_size / 4) - 1;\n\tring->ptr_mask = ring->funcs->support_64bit_ptrs ?\n\t\t0xffffffffffffffff : ring->buf_mask;\n\n\t/* Allocate ring buffer */\n\tif (ring->is_mes_queue) {\n\t\tint offset = 0;\n\n\t\tBUG_ON(ring->ring_size > PAGE_SIZE*4);\n\n\t\toffset = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\t\t AMDGPU_MES_CTX_RING_OFFS);\n\t\tring->gpu_addr = amdgpu_mes_ctx_get_offs_gpu_addr(ring, offset);\n\t\tring->ring = amdgpu_mes_ctx_get_offs_cpu_addr(ring, offset);\n\t\tamdgpu_ring_clear_ring(ring);\n\n\t} else if (ring->ring_obj == NULL) {\n\t\tr = amdgpu_bo_create_kernel(adev, ring->ring_size + ring->funcs->extra_dw, PAGE_SIZE,\n\t\t\t\t\t    AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t\t    &ring->ring_obj,\n\t\t\t\t\t    &ring->gpu_addr,\n\t\t\t\t\t    (void **)&ring->ring);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring create failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t\tamdgpu_ring_clear_ring(ring);\n\t}\n\n\tring->max_dw = max_dw;\n\tring->hw_prio = hw_prio;\n\n\tif (!ring->no_scheduler && ring->funcs->type < AMDGPU_HW_IP_NUM) {\n\t\thw_ip = ring->funcs->type;\n\t\tnum_sched = &adev->gpu_sched[hw_ip][hw_prio].num_scheds;\n\t\tadev->gpu_sched[hw_ip][hw_prio].sched[(*num_sched)++] =\n\t\t\t&ring->sched;\n\t}\n\n\treturn 0;\n}\n",
      "line_statements": [
        [
          355,
          "\tif (!ring->no_scheduler && ring->funcs->type < AMDGPU_HW_IP_NUM) {\n"
        ]
      ],
      "statements": [
        [
          355,
          "if (!ring->no_scheduler && ring->funcs->type < AMDGPU_HW_IP_NUM)"
        ]
      ],
      "cve": "CVE-2024-46725"
    },
    {
      "commit_id": "ba1dbd78e5f1ed67c1b8d37ac89d90e5e330b628",
      "filepath": "lib/smtp.c",
      "project": "curl",
      "project_repo_path": "symbol_backend_projects/curl",
      "is_vulnerable": false,
      "func_name": "Curl_smtp_escape_eob",
      "func_body": "CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)\n{\n  /* When sending a SMTP payload we must detect CRLF. sequences making sure\n     they are sent as CRLF.. instead, as a . on the beginning of a line will\n     be deleted by the server when not part of an EOB terminator and a\n     genuine CRLF.CRLF which isn't escaped will wrongly be detected as end of\n     data by the server\n  */\n  ssize_t i;\n  ssize_t si;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *scratch = data->state.scratch;\n  char *newscratch = NULL;\n  char *oldscratch = NULL;\n  size_t eob_sent;\n\n  /* Do we need to allocate a scratch buffer? */\n  if(!scratch || data->set.crlf) {\n    oldscratch = scratch;\n\n    scratch = newscratch = malloc(2 * UPLOAD_BUFSIZE);\n    if(!newscratch) {\n      failf(data, \"Failed to alloc scratch buffer!\");\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  DEBUGASSERT(UPLOAD_BUFSIZE >= nread);\n\n  /* Have we already sent part of the EOB? */\n  eob_sent = smtp->eob;\n\n  /* This loop can be improved by some kind of Boyer-Moore style of\n     approach but that is saved for later... */\n  for(i = 0, si = 0; i < nread; i++) {\n    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {\n      smtp->eob++;\n\n      /* Is the EOB potentially the terminating CRLF? */\n      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)\n        smtp->trailing_crlf = TRUE;\n      else\n        smtp->trailing_crlf = FALSE;\n    }\n    else if(smtp->eob) {\n      /* A previous substring matched so output that first */\n      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n      si += smtp->eob - eob_sent;\n\n      /* Then compare the first byte */\n      if(SMTP_EOB[0] == data->req.upload_fromhere[i])\n        smtp->eob = 1;\n      else\n        smtp->eob = 0;\n\n      eob_sent = 0;\n\n      /* Reset the trailing CRLF flag as there was more data */\n      smtp->trailing_crlf = FALSE;\n    }\n\n    /* Do we have a match for CRLF. as per RFC-5321, sect. 4.5.2 */\n    if(SMTP_EOB_FIND_LEN == smtp->eob) {\n      /* Copy the replacement data to the target buffer */\n      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],\n             SMTP_EOB_REPL_LEN - eob_sent);\n      si += SMTP_EOB_REPL_LEN - eob_sent;\n      smtp->eob = 0;\n      eob_sent = 0;\n    }\n    else if(!smtp->eob)\n      scratch[si++] = data->req.upload_fromhere[i];\n  }\n\n  if(smtp->eob - eob_sent) {\n    /* A substring matched before processing ended so output that now */\n    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n    si += smtp->eob - eob_sent;\n  }\n\n  /* Only use the new buffer if we replaced something */\n  if(si != nread) {\n    /* Upload from the new (replaced) buffer instead */\n    data->req.upload_fromhere = scratch;\n\n    /* Save the buffer so it can be freed later */\n    data->state.scratch = scratch;\n\n    /* Free the old scratch buffer */\n    free(oldscratch);\n\n    /* Set the new amount too */\n    data->req.upload_present = si;\n  }\n  else\n    free(newscratch);\n\n  return CURLE_OK;\n}",
      "line_statements": [
        [
          1566,
          "    scratch = newscratch = malloc(2 * UPLOAD_BUFSIZE);"
        ],
        [
          1573,
          "  DEBUGASSERT(UPLOAD_BUFSIZE >= nread);"
        ]
      ],
      "statements": [
        [
          1566,
          "scratch = newscratch = malloc(2 * UPLOAD_BUFSIZE);"
        ],
        [
          1573,
          "DEBUGASSERT(UPLOAD_BUFSIZE >= nread);"
        ]
      ],
      "cve": "CVE-2018-0500"
    },
    {
      "commit_id": "c37e9e013469521d9adb932d17a1795c139b36db",
      "filepath": "fs/ext4/inode.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "__ext4_get_inode_loc",
      "func_body": "static int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (!ext4_valid_inum(sb, inode->i_ino))\n\t\treturn -EFSCORRUPTED;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}\n",
      "line_statements": [
        [
          4509,
          "\tif (!ext4_valid_inum(sb, inode->i_ino))\n"
        ]
      ],
      "statements": [
        [
          4509,
          "if (!ext4_valid_inum(sb, inode->i_ino))"
        ]
      ],
      "cve": "CVE-2018-10882"
    },
    {
      "commit_id": "459ae818fc8dae717549810150de4d191ce158f1",
      "filepath": "tsk/fs/yaffs.cpp",
      "project": "sleuthkit",
      "project_repo_path": "symbol_backend_projects/sleuthkit",
      "is_vulnerable": false,
      "func_name": "yaffsfs_istat",
      "func_body": "    yaffsfs_istat(TSK_FS_INFO *fs, TSK_FS_ISTAT_FLAG_ENUM flags, FILE * hFile, TSK_INUM_T inum,\n    TSK_DADDR_T numblock, int32_t sec_skew)\n{\n    TSK_FS_META *fs_meta;\n    TSK_FS_FILE *fs_file;\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n    char ls[12];\n    YAFFSFS_PRINT_ADDR print;\n    char timeBuf[128];\n    YaffsCacheObject * obj = NULL;\n    YaffsCacheVersion * version = NULL;\n    YaffsHeader * header = NULL;\n\n    yaffscache_version_find_by_inode(yfs, inum, &version, &obj);\n\n    if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) {\n        return 1;\n    }\n    fs_meta = fs_file->meta;\n\n    tsk_fprintf(hFile, \"inode: %\" PRIuINUM \"\\n\", inum);\n    tsk_fprintf(hFile, \"%sAllocated\\n\",\n        (fs_meta->flags & TSK_FS_META_FLAG_ALLOC) ? \"\" : \"Not \");\n\n    if (fs_meta->link)\n        tsk_fprintf(hFile, \"symbolic link to: %s\\n\", fs_meta->link);\n\n    tsk_fprintf(hFile, \"uid / gid: %\" PRIuUID \" / %\" PRIuGID \"\\n\",\n        fs_meta->uid, fs_meta->gid);\n\n    tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls));\n    tsk_fprintf(hFile, \"mode: %s\\n\", ls);\n\n    tsk_fprintf(hFile, \"size: %\" PRIdOFF \"\\n\", fs_meta->size);\n    tsk_fprintf(hFile, \"num of links: %d\\n\", fs_meta->nlink);\n\n    if(version != NULL){\n        yaffsfs_read_header(yfs, &header, version->ycv_header_chunk->ycc_offset);\n        if(header != NULL){\n            tsk_fprintf(hFile, \"Name: %s\\n\", header->name);\n        }\n    }\n\n    if (sec_skew != 0) {\n        tsk_fprintf(hFile, \"\\nAdjusted Inode Times:\\n\");\n        fs_meta->mtime -= sec_skew;\n        fs_meta->atime -= sec_skew;\n        fs_meta->ctime -= sec_skew;\n\n        tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n        tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n        tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n        fs_meta->mtime += sec_skew;\n        fs_meta->atime += sec_skew;\n        fs_meta->ctime += sec_skew;\n\n        tsk_fprintf(hFile, \"\\nOriginal Inode Times:\\n\");\n    }\n    else {\n        tsk_fprintf(hFile, \"\\nInode Times:\\n\");\n    }\n\n    tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n    tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n    tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n    if(version != NULL){\n        tsk_fprintf(hFile, \"\\nHeader Chunk:\\n\");\n        tsk_fprintf(hFile, \"%\" PRIuDADDR \"\\n\", (version->ycv_header_chunk->ycc_offset / (yfs->page_size + yfs->spare_size)));\n    }\n\n    if (numblock > 0) {\n        TSK_OFF_T lower_size = numblock * fs->block_size;\n        fs_meta->size = (lower_size < fs_meta->size)?(lower_size):(fs_meta->size);\n    }\n    tsk_fprintf(hFile, \"\\nData Chunks:\\n\");\n\n\n    if (flags & TSK_FS_ISTAT_RUNLIST){\n        const TSK_FS_ATTR *fs_attr_default =\n            tsk_fs_file_attr_get_type(fs_file,\n                TSK_FS_ATTR_TYPE_DEFAULT, 0, 0);\n        if (fs_attr_default && (fs_attr_default->flags & TSK_FS_ATTR_NONRES)) {\n            if (tsk_fs_attr_print(fs_attr_default, hFile)) {\n                tsk_fprintf(hFile, \"\\nError creating run lists  \");\n                tsk_error_print(hFile);\n                tsk_error_reset();\n            }\n        }\n    }\n    else {\n        print.idx = 0;\n        print.hFile = hFile;\n\n        if (tsk_fs_file_walk(fs_file, TSK_FS_FILE_WALK_FLAG_AONLY,\n            (TSK_FS_FILE_WALK_CB)print_addr_act, (void *)&print)) {\n            tsk_fprintf(hFile, \"\\nError reading file:  \");\n            tsk_error_print(hFile);\n            tsk_error_reset();\n        }\n        else if (print.idx != 0) {\n            tsk_fprintf(hFile, \"\\n\");\n        }\n    }\n\n    tsk_fs_file_close(fs_file);\n\n    return 0;\n}",
      "line_statements": [
        [
          2442,
          "    char timeBuf[128];"
        ]
      ],
      "statements": [
        [
          2442,
          "char timeBuf[128];"
        ]
      ],
      "cve": "CVE-2020-10232"
    },
    {
      "commit_id": "77425c862ad20cd270d42c54f3d63e1eb4e02195",
      "filepath": "BLSCrypto.cpp",
      "project": "sgxwallet",
      "project_repo_path": "symbol_backend_projects/sgxwallet",
      "is_vulnerable": false,
      "func_name": "carray2Hex",
      "func_body": "void carray2Hex(const unsigned char *d, uint64_t _len, char *_hexArray,\n                uint64_t _hexArrayLen) {\n\n    CHECK_STATE(d);\n    CHECK_STATE(_hexArray);\n\n    char hexval[16] = {'0', '1', '2', '3', '4', '5', '6', '7',\n                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n    CHECK_STATE(_hexArrayLen > 2 * _len);\n\n    for (uint64_t j = 0; j < _len; j++) {\n        _hexArray[j * 2] = hexval[((d[j] >> 4) & 0xF)];\n        _hexArray[j * 2 + 1] = hexval[(d[j]) & 0x0F];\n    }\n\n    _hexArray[_len * 2] = 0;\n}",
      "line_statements": [
        [
          89,
          "    for (uint64_t j = 0; j < _len; j++) {"
        ]
      ],
      "statements": [
        [
          89,
          "for (uint64_t j = 0; j < _len; j++) {"
        ]
      ],
      "cve": "CVE-2021-36218"
    },
    {
      "commit_id": "1f860f52bd8d58737ad883072203391096b30b51",
      "filepath": "coders/tiff.c",
      "project": "ImageMagick6",
      "project_repo_path": "symbol_backend_projects/ImageMagick6",
      "is_vulnerable": false,
      "func_name": "ReadTIFFImage",
      "func_body": "static Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define MaxPixelChannels  32\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity = (float *) NULL,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status = 0;\n\n  MagickBooleanType\n    more_frames;\n\n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    number_pixels;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag = 0,\n    bits_per_sample = 0,\n    endian = 0,\n    extra_samples = 0,\n    interlace = 0,\n    max_sample_value = 0,\n    min_sample_value = 0,\n    orientation = 0,\n    pages = 0,\n    photometric = 0,\n    *sample_info = NULL,\n    sample_format = 0,\n    samples_per_pixel = 0,\n    units = 0,\n    value = 0;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      if (exception->severity == UndefinedException)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        }\n    }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\");\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\");\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) &&\n        (compress_tag != COMPRESSION_OJPEG) &&\n        (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetEXIFProperties(tiff,image);\n    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetGPSProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n          image->x_resolution-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n          image->y_resolution-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\",\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap = (uint16 *) NULL,\n          *green_colormap = (uint16 *) NULL,\n          *red_colormap = (uint16 *) NULL;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\");\n                }\n          }\n      }\n    if (image->matte != MagickFalse)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        (void) FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV) ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n          pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n            else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n            if (image->matte != MagickFalse)\n              {\n                quantum_type=RGBAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n              }\n            if (image->colorspace == CMYKColorspace)\n              {\n                quantum_type=CMYKQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n                if (image->matte != MagickFalse)\n                  {\n                    quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n                  }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>\n              3));\n            if (status == MagickFalse)\n              ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          IndexPacket\n            *indexes;\n\n          PixelPacket\n            *magick_restrict q;\n\n          ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));\n            q++;\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=(samples_per_pixel+1)*TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            PixelPacket\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > (ssize_t) image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n         if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=4*MagickMax(rows*TIFFTileRowSize(tiff),TIFFTileSize(tiff));\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,\n                0,i);\n              if (tiff_status == -1)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                PixelPacket\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (PixelPacket *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo *) NULL;\n\n        uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n#if defined(TIFF_VERSION_BIG)\n        number_pixels+=image->columns*sizeof(uint64);\n#else\n        number_pixels+=image->columns*sizeof(uint32);\n#endif\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        if (tiff_status == -1)\n          {\n            generic_info=RelinquishVirtualMemory(generic_info);\n            break;\n          }\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            x;\n\n          PixelPacket\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n            if (image->matte == MagickFalse)\n              SetPixelOpacity(q,OpaqueOpacity);\n            else\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (tiff_status == -1)\n      {\n        status=MagickFalse;\n        break;\n      }\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  TIFFReadPhotoshopLayers(image_info,image,exception);\n  return(GetFirstImageInList(image));\n}",
      "line_statements": [
        [
          1897,
          "        extent=4*MagickMax(rows*TIFFTileRowSize(tiff),TIFFTileSize(tiff));"
        ]
      ],
      "statements": [
        [
          1897,
          "extent=4*MagickMax(rows*TIFFTileRowSize(tiff),TIFFTileSize(tiff));"
        ]
      ],
      "cve": "CVE-2022-1115"
    },
    {
      "commit_id": "760322a71ac9033e122ef1f4b1c62813021e5938",
      "filepath": "tensorflow/core/ir/importexport/functiondef_import.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "mlir::tfg::ImportGenericFunction",
      "func_body": "Status ImportGenericFunction(\n    GraphFuncOp func_op, const FunctionDef& func,\n    llvm::StringMap<llvm::StringMap<SmallVector<Value, 1>>>& values_map,\n    OpBuilder& builder) {\n  const OpDef& signature = func.signature();\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n\n  NamedAttrList attrs;\n  DictionaryAttr func_attrs = builder.getDictionaryAttr({});\n  if (signature.name().empty())\n    return InvalidArgument(\"generic function without a name\");\n  attrs.append(\"sym_name\", builder.getStringAttr(signature.name()));\n  attrs.append(\"generic\", builder.getUnitAttr());\n  if (!signature.description().empty())\n    attrs.append(\"description\", builder.getStringAttr(signature.description()));\n  if (signature.is_stateful())\n    attrs.append(\"is_stateful\", builder.getUnitAttr());\n  if (signature.control_output_size()) {\n    SmallVector<Attribute> control_outputs;\n    for (const std::string& output : signature.control_output())\n      control_outputs.push_back(builder.getStringAttr(output));\n    attrs.append(\"control_output\", builder.getArrayAttr(control_outputs));\n  }\n  {\n    NamedAttrList attr_defs;\n    for (const OpDef_AttrDef& attr : signature.attr()) {\n      NamedAttrList attr_def;\n      if (attr.name().empty())\n        return InvalidArgument(\"Missing name for function attribute\");\n      if (!attr.type().empty())\n        attr_def.append(builder.getNamedAttr(\n            \"function_type\", builder.getStringAttr(attr.type())));\n      if (attr.has_default_value()) {\n        TF_ASSIGN_OR_RETURN(Attribute attr, ConvertAttributeValue(\n                                                attr.default_value(), builder));\n        attr_def.append(builder.getNamedAttr(\"default_value\", attr));\n      }\n      if (!attr.description().empty())\n        attr_def.append(builder.getNamedAttr(\n            \"description\", builder.getStringAttr(attr.description())));\n      if (attr.has_minimum() || attr.minimum())\n        attr_def.append(builder.getNamedAttr(\n            \"minimum\", builder.getI32IntegerAttr(attr.minimum())));\n      if (attr.has_allowed_values()) {\n        TF_ASSIGN_OR_RETURN(\n            Attribute attr,\n            ConvertAttributeValue(attr.allowed_values(), builder));\n        attr_def.append(builder.getNamedAttr(\"allowed_values\", attr));\n      }\n      attr_defs.append(builder.getNamedAttr(\n          attr.name(), attr_def.getDictionary(builder.getContext())));\n    }\n    if (!attr_defs.empty()) {\n      func_attrs = attr_defs.getDictionary(builder.getContext());\n      attrs.append(\"tfg.func_attrs\", func_attrs);\n    }\n  }\n\n  // The resource_arg_unique_id is a list of `pair<int, int>`, we import it\n  // as two arrays of integer right now.\n  if (func.resource_arg_unique_id_size()) {\n    SmallVector<int32_t> resource_arg_unique_ids_keys;\n    SmallVector<int32_t> resource_arg_unique_ids_values;\n    for (const auto& unique_id : func.resource_arg_unique_id()) {\n      resource_arg_unique_ids_keys.push_back(unique_id.first);\n      resource_arg_unique_ids_values.push_back(unique_id.second);\n    }\n    attrs.append(\"resource_arg_unique_ids_keys\",\n                 builder.getI32TensorAttr(resource_arg_unique_ids_keys));\n    attrs.append(\"resource_arg_unique_ids_values\",\n                 builder.getI32TensorAttr(resource_arg_unique_ids_values));\n  }\n\n  // Import the function attributes with a `tf.` prefix to match the current\n  // infrastructure expectations.\n  for (const auto& namedAttr : func.attr()) {\n    if (namedAttr.first.empty())\n      return InvalidArgument(\"Invalid function attribute name\");\n    const std::string& name = \"tf.\" + namedAttr.first;\n    const AttrValue& tf_attr = namedAttr.second;\n    TF_ASSIGN_OR_RETURN(Attribute attr,\n                        ConvertAttributeValue(tf_attr, builder));\n    attrs.append(name, attr);\n  }\n  SmallString<8> arg_or_res_attr_name;\n  SmallString<8> sub_arg_attr_name;\n  // Iterate of the input in the signature. Each input will correspond to\n  // potentially multiple arguments because of how the OpDef allows repeated\n  // arguments controlled by `number_attr` for example.\n  // We populate the `arg_names` vector with the name of each input at each\n  // position, and `arg_types` with the matching type.\n  int arg_num = 0;\n  SmallVector<StringRef> arg_names;\n  SmallVector<Type> arg_types;\n  SmallVector<Attribute> args_attrs;\n  SmallVector<Attribute> res_attrs;\n  for (const auto& enumerated_input : llvm::enumerate(signature.input_arg())) {\n    const OpDef::ArgDef& input = enumerated_input.value();\n    TF_ASSIGN_OR_RETURN(NamedAttrList input_attrs,\n                        ConvertArgDefAttributes(input, builder));\n    auto it = func.arg_attr().find(enumerated_input.index());\n    if (it != func.arg_attr().end()) {\n      NamedAttrList arg_attr;\n      for (const auto& named_attr : it->second.attr()) {\n        TF_ASSIGN_OR_RETURN(Attribute attr,\n                            ConvertAttributeValue(named_attr.second, builder));\n        arg_attr.append(named_attr.first, attr);\n      }\n      input_attrs.append(\"tfg.arg_attrs\",\n                         arg_attr.getDictionary(builder.getContext()));\n    }\n    arg_names.push_back(builder.getStringAttr(input.name()).getValue());\n    arg_types.push_back(OpaqueTensorType::get(context));\n    args_attrs.push_back(input_attrs.getDictionary(context));\n    args_attrs.push_back(NamedAttrList{}.getDictionary(context));\n    arg_num++;\n  }\n  attrs.push_back(builder.getNamedAttr(func_op.getArgAttrsAttrName(),\n                                       builder.getArrayAttr(args_attrs)));\n\n  // Process the results attributes now.\n  int res_num = 0;\n  for (const OpDef::ArgDef& output : signature.output_arg()) {\n    TF_ASSIGN_OR_RETURN(NamedAttrList output_attrs,\n                        ConvertArgDefAttributes(output, builder));\n    res_attrs.push_back(output_attrs.getDictionary(context));\n    ++res_num;\n  }\n  // Process the control output metadata and store them as attributes.\n  for (const std::string& output : signature.control_output()) {\n    NamedAttrList output_attrs;\n    output_attrs.append(\"tfg.name\", builder.getStringAttr(output));\n    res_attrs.push_back(output_attrs.getDictionary(context));\n    ++res_num;\n  }\n  attrs.push_back(builder.getNamedAttr(func_op.getResAttrsAttrName(),\n                                       builder.getArrayAttr(res_attrs)));\n\n  values_map.clear();\n  Block* body = new Block();\n  func_op.getBody().push_back(body);\n  Type control_ty = ControlType::get(context);\n  // Create the block arguments and populate the `values_map` with the matching\n  // input names.\n  for (auto type_and_name : llvm::zip(arg_types, arg_names)) {\n    Value arg = body->addArgument(std::get<0>(type_and_name), unknown_loc);\n    llvm::StringMap<SmallVector<Value, 1>>& values =\n        values_map[std::get<1>(type_and_name)];\n    Value ctl = body->addArgument(control_ty, unknown_loc);\n    values[\"\"].push_back(arg);\n    values[\"^\"].push_back(ctl);\n  }\n\n  // Pre-populate the nodes_map with the needed slots for the return.\n  OpBuilder body_builder = OpBuilder::atBlockEnd(body);\n  // We use placeholders during the import to create \"fake\" operations to break\n  // cycles: we need operands to feed to the users.\n  OperationName mlir_placeholder(\"tfg.__mlir_placeholder\", context);\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  ValueMapManager value_manager(values_map, body_builder, mlir_placeholder,\n                                placeholder_ty, control_ty, unknown_loc);\n\n  // Import the function body here, after this we have a function with all\n  // the nodes, and the nodes_map contains the mapping from node_name to actual\n  // MLIR Operations.\n  TF_RETURN_WITH_CONTEXT_IF_ERROR(\n      ImportNodes(value_manager, func.node_def(), body_builder),\n      \" when importing function \", func.signature().name());\n\n  // After the body, the final part is to setup the return. It comes in two\n  // parts: the `ret` field from the FunctionDef for the regular output and the\n  // `control_ret` field for the control output.\n  //\n  // Because `ret` and `control_ret` aren't ordered, there is an indirection to\n  // the FunctionDef signature to retrieve the position of each `ret` and\n  // `control_ret` entry by name. We compute this mapping from the name of an\n  // output to the position in the result array first.\n  res_num = 0;\n  llvm::StringMap<int> output_name_to_position;\n  for (const OpDef::ArgDef& output : signature.output_arg()) {\n    if (output_name_to_position.count(output.name()))\n      return InvalidArgument(\"Duplicated output_arg entry\", output.name());\n    output_name_to_position[output.name()] = res_num;\n    ++res_num;\n  }\n  res_num = 0;\n  llvm::StringMap<int> control_output_to_position;\n  for (const std::string& output : signature.control_output()) {\n    if (control_output_to_position.count(output))\n      return InvalidArgument(\"Duplicated control_output entry\", output);\n    control_output_to_position[output] = res_num;\n    ++res_num;\n  }\n\n  // We pre-allocate the array of operands and populate it using the\n  // `output_name_to_position` and `control_output_to_position` populated\n  // previously.\n  SmallVector<Value> ret_vals(func.ret_size() + func.control_ret_size(),\n                              Value());\n  for (const auto& ret_val : func.ret()) {\n    auto position = output_name_to_position.find(ret_val.first);\n    if (position == output_name_to_position.end()) {\n      return InvalidArgument(\n          \"Can't import function, returned value references unknown output \"\n          \"argument \",\n          ret_val.first);\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty result name\");\n    }\n    TF_ASSIGN_OR_RETURN(\n        ret_vals[position->second],\n        value_manager.GetValueOrCreatePlaceholder(ret_val.second));\n  }\n  for (const auto& ret_val : func.control_ret()) {\n    auto position = control_output_to_position.find(ret_val.first);\n    if (position == control_output_to_position.end()) {\n      return InvalidArgument(\n          \"Can't import function, returned value references unknown output \"\n          \"argument \",\n          ret_val.first);\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty control result name\");\n    }\n    TF_ASSIGN_OR_RETURN(Value result, value_manager.GetValueOrCreatePlaceholder(\n                                          (Twine(\"^\") + ret_val.second).str()));\n    if (!result.getType().isa<ControlType>())\n      return InvalidArgument(\"failed to map returned value \", ret_val.second,\n                             \", isn't a control output\");\n    ret_vals[func.ret_size() + position->second] = result;\n  }\n  // Check that all the of the return operands have been populated.\n  for (auto& indexed_val : llvm::enumerate(ret_vals)) {\n    if (indexed_val.value()) continue;\n    return InvalidArgument(\n        \"Failed to import function, missing output for position \",\n        indexed_val.index());\n  }\n  MutableArrayRef<Value> operands = ret_vals;\n  ReturnOp ret_op = body_builder.create<ReturnOp>(\n      unknown_loc, operands.slice(0, func.ret_size()),\n      operands.slice(func.ret_size()));\n\n  // Now that we have all the types, set the function signature as the\n  // \"function_type\" attribute.\n  {\n    SmallVector<Type> arg_types_with_ctl;\n    for (Type type : arg_types) {\n      arg_types_with_ctl.push_back(type);\n      arg_types_with_ctl.push_back(control_ty);\n    }\n    attrs.append(\"function_type\",\n                 TypeAttr::get(builder.getFunctionType(\n                     arg_types_with_ctl, ret_op.getOperandTypes())));\n  }\n  func_op->setAttrs(attrs);\n  return ::tensorflow::OkStatus();\n}",
      "line_statements": [
        [
          482,
          "    TF_ASSIGN_OR_RETURN("
        ],
        [
          483,
          "        ret_vals[position->second],"
        ],
        [
          484,
          "        value_manager.GetValueOrCreatePlaceholder(ret_val.second));"
        ],
        [
          498,
          "    TF_ASSIGN_OR_RETURN(Value result, value_manager.GetValueOrCreatePlaceholder("
        ],
        [
          499,
          "                                          (Twine(\"^\") + ret_val.second).str()));"
        ]
      ],
      "statements": [
        [
          482,
          "TF_ASSIGN_OR_RETURN(\n        ret_vals[position->second],\n        value_manager.GetValueOrCreatePlaceholder(ret_val.second));"
        ],
        [
          498,
          "    TF_ASSIGN_OR_RETURN(Value result, value_manager.GetValueOrCreatePlaceholder(\n"
        ],
        [
          499,
          "                                          (Twine(\"^\") + ret_val.second).str()));\n"
        ]
      ],
      "cve": "CVE-2023-25671"
    },
    {
      "commit_id": "2cd30c2b06ce332dede81cccad8b334cde997281",
      "filepath": "src/bin/jp2/convert.c",
      "project": "openjpeg",
      "project_repo_path": "symbol_backend_projects/openjpeg",
      "is_vulnerable": false,
      "func_name": "get_tga_ushort",
      "func_body": "static unsigned short get_tga_ushort(const unsigned char *data)\n{\n    return data[0] | (data[1] << 8);\n}",
      "line_statements": [
        [
          584,
          "static unsigned short get_tga_ushort(const unsigned char *data)"
        ],
        [
          586,
          "    return data[0] | (data[1] << 8);"
        ]
      ],
      "statements": [
        [
          584,
          "static unsigned short get_tga_ushort(const unsigned char *data)"
        ],
        [
          586,
          "return data[0] | (data[1] << 8);"
        ]
      ],
      "cve": "CVE-2017-14040"
    },
    {
      "commit_id": "fb2288c46dd4c864b78f00a47a364b96a09a5c0f",
      "filepath": "wolfcrypt/src/rsa.c",
      "project": "wolfssl",
      "project_repo_path": "symbol_backend_projects/wolfssl",
      "is_vulnerable": false,
      "func_name": "RsaPad_PSS",
      "func_body": "static int RsaPad_PSS(const byte* input, word32 inputLen, byte* pkcsBlock,\n        word32 pkcsBlockLen, WC_RNG* rng, enum wc_HashType hType, int mgf,\n        int saltLen, int bits, void* heap)\n{\n    int   ret = 0;\n    int   hLen, i, o, maskLen, hiBits;\n    byte* m;\n    byte* s;\n#if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)\n    byte msg[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];\n#else\n    byte* msg = NULL;\n#endif\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    byte* salt;\n#else\n    byte salt[WC_MAX_DIGEST_SIZE];\n#endif\n\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    if (pkcsBlockLen > RSA_MAX_SIZE/8) {\n        return MEMORY_E;\n    }\n#endif\n\n    hLen = wc_HashGetDigestSize(hType);\n    if (hLen < 0)\n        return hLen;\n    if ((int)inputLen != hLen) {\n        return BAD_FUNC_ARG;\n    }\n\n    hiBits = (bits - 1) & 0x7;\n    if (hiBits == 0) {\n        /* Per RFC8017, set the leftmost 8emLen - emBits bits of the\n           leftmost octet in DB to zero.\n        */\n        *(pkcsBlock++) = 0;\n        pkcsBlockLen--;\n    }\n\n    if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {\n        saltLen = hLen;\n        #ifdef WOLFSSL_SHA512\n            /* See FIPS 186-4 section 5.5 item (e). */\n            if (bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE) {\n                saltLen = RSA_PSS_SALT_MAX_SZ;\n            }\n        #endif\n    }\n#ifndef WOLFSSL_PSS_LONG_SALT\n    else if (saltLen > hLen) {\n        return PSS_SALTLEN_E;\n    }\n#endif\n#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER\n    else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {\n        return PSS_SALTLEN_E;\n    }\n#else\n    else if (saltLen == RSA_PSS_SALT_LEN_DISCOVER) {\n        saltLen = (int)pkcsBlockLen - hLen - 2;\n        if (saltLen < 0) {\n            return PSS_SALTLEN_E;\n        }\n    }\n    else if (saltLen < RSA_PSS_SALT_LEN_DISCOVER) {\n        return PSS_SALTLEN_E;\n    }\n#endif\n    if ((int)pkcsBlockLen - hLen < saltLen + 2) {\n        return PSS_SALTLEN_E;\n    }\n    maskLen = pkcsBlockLen - 1 - hLen;\n\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n                                                       DYNAMIC_TYPE_RSA_BUFFER);\n        if (msg == NULL) {\n            return MEMORY_E;\n        }\n    #endif\n    salt = s = m = msg;\n    XMEMSET(m, 0, RSA_PSS_PAD_SZ);\n    m += RSA_PSS_PAD_SZ;\n    XMEMCPY(m, input, inputLen);\n    m += inputLen;\n    o = (int)(m - s);\n    if (saltLen > 0) {\n        ret = wc_RNG_GenerateBlock(rng, m, saltLen);\n        if (ret == 0) {\n            m += saltLen;\n        }\n    }\n#else\n    if (pkcsBlockLen < RSA_PSS_PAD_SZ + inputLen + saltLen) {\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n                                                       DYNAMIC_TYPE_RSA_BUFFER);\n        if (msg == NULL) {\n            return MEMORY_E;\n        }\n    #endif\n        m = msg;\n    }\n    else {\n        m = pkcsBlock;\n    }\n    s = m;\n    XMEMSET(m, 0, RSA_PSS_PAD_SZ);\n    m += RSA_PSS_PAD_SZ;\n    XMEMCPY(m, input, inputLen);\n    m += inputLen;\n    o = 0;\n    if (saltLen > 0) {\n        ret = wc_RNG_GenerateBlock(rng, salt, saltLen);\n        if (ret == 0) {\n            XMEMCPY(m, salt, saltLen);\n            m += saltLen;\n        }\n    }\n#endif\n    if (ret == 0) {\n        /* Put Hash at end of pkcsBlock - 1 */\n        ret = wc_Hash(hType, s, (word32)(m - s), pkcsBlock + maskLen, hLen);\n    }\n    if (ret == 0) {\n       /* Set the last eight bits or trailer field to the octet 0xbc */\n        pkcsBlock[pkcsBlockLen - 1] = RSA_PSS_PAD_TERM;\n\n        ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, pkcsBlock, maskLen, heap);\n    }\n    if (ret == 0) {\n        /* Clear the first high bit when \"8emLen - emBits\" is non-zero.\n           where emBits = n modBits - 1 */\n        if (hiBits)\n            pkcsBlock[0] &= (1 << hiBits) - 1;\n\n        m = pkcsBlock + maskLen - saltLen - 1;\n        *(m++) ^= 0x01;\n        for (i = 0; i < saltLen; i++) {\n            m[i] ^= salt[o + i];\n        }\n    }\n\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        if (msg != NULL) {\n            XFREE(msg, heap, DYNAMIC_TYPE_RSA_BUFFER);\n        }\n    #endif\n    return ret;\n}",
      "line_statements": [
        [
          1119,
          "#if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)"
        ],
        [
          1120,
          "    byte msg[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];"
        ],
        [
          1121,
          "#else"
        ],
        [
          1122,
          "    byte* msg = NULL;"
        ],
        [
          1123,
          "#endif"
        ],
        [
          1125,
          "    byte* salt;"
        ],
        [
          1188,
          "        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,"
        ],
        [
          1190,
          "        if (msg == NULL) {"
        ],
        [
          1194,
          "    salt = s = m = msg;"
        ],
        [
          1207,
          "    if (pkcsBlockLen < RSA_PSS_PAD_SZ + inputLen + saltLen) {"
        ],
        [
          1208,
          "    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)"
        ],
        [
          1209,
          "        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,"
        ],
        [
          1210,
          "                                                       DYNAMIC_TYPE_RSA_BUFFER);"
        ],
        [
          1211,
          "        if (msg == NULL) {"
        ],
        [
          1212,
          "            return MEMORY_E;"
        ],
        [
          1213,
          "        }"
        ],
        [
          1214,
          "    #endif"
        ],
        [
          1215,
          "        m = msg;"
        ],
        [
          1216,
          "    }"
        ],
        [
          1217,
          "    else {"
        ],
        [
          1218,
          "        m = pkcsBlock;"
        ],
        [
          1219,
          "    }"
        ],
        [
          1220,
          "    s = m;"
        ],
        [
          1258,
          "        if (msg != NULL) {"
        ],
        [
          1259,
          "            XFREE(msg, heap, DYNAMIC_TYPE_RSA_BUFFER);"
        ]
      ],
      "statements": [
        [
          1119,
          "#if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)\n    byte msg[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];\n#else\n    byte* msg = NULL;\n#endif"
        ],
        [
          1120,
          "byte msg[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];"
        ],
        [
          1121,
          "#else\n    byte* msg = NULL;"
        ],
        [
          1122,
          "byte* msg = NULL;"
        ],
        [
          1125,
          "byte* salt;"
        ],
        [
          1188,
          "msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n                                                       DYNAMIC_TYPE_RSA_BUFFER);"
        ],
        [
          1190,
          "if (msg == NULL)"
        ],
        [
          1194,
          "salt = s = m = msg;"
        ],
        [
          1207,
          "if (pkcsBlockLen < RSA_PSS_PAD_SZ + inputLen + saltLen)"
        ],
        [
          1208,
          "#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n                                                       DYNAMIC_TYPE_RSA_BUFFER);\n        if (msg == NULL) {\n            return MEMORY_E;\n        }\n    #endif"
        ],
        [
          1209,
          "msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n                                                       DYNAMIC_TYPE_RSA_BUFFER);"
        ],
        [
          1211,
          "if (msg == NULL)"
        ],
        [
          1212,
          "return MEMORY_E;"
        ],
        [
          1213,
          "        }\n"
        ],
        [
          1215,
          "m = msg;"
        ],
        [
          1216,
          "    }\n"
        ],
        [
          1217,
          "else"
        ],
        [
          1218,
          "m = pkcsBlock;"
        ],
        [
          1219,
          "    }\n"
        ],
        [
          1220,
          "s = m;"
        ],
        [
          1258,
          "if (msg != NULL)"
        ],
        [
          1259,
          "XFREE(msg, heap, DYNAMIC_TYPE_RSA_BUFFER);"
        ]
      ],
      "cve": "CVE-2020-36177"
    },
    {
      "commit_id": "17743798d81238ab13050e8e2833699b54e15467",
      "filepath": "mm/hugetlb.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "proc_hugetlb_doulongvec_minmax",
      "func_body": "static int proc_hugetlb_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t\t\t\t  void *buffer, size_t *length,\n\t\t\t\t\t  loff_t *ppos, unsigned long *out)\n{\n\tstruct ctl_table dup_table;\n\n\t/*\n\t * In order to avoid races with __do_proc_doulongvec_minmax(), we\n\t * can duplicate the @table and alter the duplicate of it.\n\t */\n\tdup_table = *table;\n\tdup_table.data = out;\n\n\treturn proc_doulongvec_minmax(&dup_table, write, buffer, length, ppos);\n}\n",
      "line_statements": [
        [
          3468,
          "static int proc_hugetlb_doulongvec_minmax(struct ctl_table *table, int write,\n"
        ],
        [
          3469,
          "\t\t\t\t\t  void *buffer, size_t *length,\n"
        ],
        [
          3470,
          "\t\t\t\t\t  loff_t *ppos, unsigned long *out)\n"
        ],
        [
          3471,
          "{\n"
        ],
        [
          3472,
          "\tstruct ctl_table dup_table;\n"
        ],
        [
          3473,
          "\n"
        ],
        [
          3474,
          "\t/*\n"
        ],
        [
          3475,
          "\t * In order to avoid races with __do_proc_doulongvec_minmax(), we\n"
        ],
        [
          3476,
          "\t * can duplicate the @table and alter the duplicate of it.\n"
        ],
        [
          3477,
          "\t */\n"
        ],
        [
          3478,
          "\tdup_table = *table;\n"
        ],
        [
          3479,
          "\tdup_table.data = out;\n"
        ],
        [
          3480,
          "\n"
        ],
        [
          3481,
          "\treturn proc_doulongvec_minmax(&dup_table, write, buffer, length, ppos);\n"
        ],
        [
          3482,
          "}\n"
        ]
      ],
      "statements": [
        [
          3468,
          "static int proc_hugetlb_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t\t\t\t  void *buffer, size_t *length,\n\t\t\t\t\t  loff_t *ppos, unsigned long *out)"
        ],
        [
          3471,
          "{\n"
        ],
        [
          3472,
          "struct ctl_table dup_table;"
        ],
        [
          3473,
          "\n"
        ],
        [
          3474,
          "/*\n\t * In order to avoid races with __do_proc_doulongvec_minmax(), we\n\t * can duplicate the @table and alter the duplicate of it.\n\t */"
        ],
        [
          3478,
          "dup_table = *table;"
        ],
        [
          3479,
          "dup_table.data = out;"
        ],
        [
          3480,
          "\n"
        ],
        [
          3481,
          "return proc_doulongvec_minmax(&dup_table, write, buffer, length, ppos);"
        ],
        [
          3482,
          "}\n"
        ]
      ],
      "cve": "CVE-2020-25285"
    },
    {
      "commit_id": "8bc1379b82b8e809eef77a9fedbb75c6c297be19",
      "filepath": "fs/ext4/xattr.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "ext4_xattr_ibody_inline_set",
      "func_body": "int ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s, handle, inode, false /* is_block */);\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}\n",
      "line_statements": [
        [
          2215,
          "\tif (error)\n"
        ],
        [
          2216,
          "\t\treturn error;\n"
        ]
      ],
      "statements": [
        [
          2215,
          "if (error)"
        ],
        [
          2216,
          "return error;"
        ]
      ],
      "cve": "CVE-2018-10883"
    },
    {
      "commit_id": "c101abff4c6756db4f5e740fde289decb9452efa",
      "filepath": "src/diff.c",
      "project": "vim",
      "project_repo_path": "symbol_backend_projects/vim",
      "is_vulnerable": false,
      "func_name": "diff_mark_adjust_tp",
      "func_body": "diff_mark_adjust_tp(\n    tabpage_T\t*tp,\n    int\t\tidx,\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after)\n{\n    diff_T\t*dp;\n    diff_T\t*dprev;\n    diff_T\t*dnext;\n    int\t\ti;\n    int\t\tinserted, deleted;\n    int\t\tn, off;\n    linenr_T\tlast;\n    linenr_T\tlnum_deleted = line1;\t// lnum of remaining deletion\n    int\t\tcheck_unchanged;\n\n    if (diff_internal())\n    {\n\t// Will update diffs before redrawing.  Set _invalid to update the\n\t// diffs themselves, set _update to also update folds properly just\n\t// before redrawing.\n\t// Do update marks here, it is needed for :%diffput.\n\ttp->tp_diff_invalid = TRUE;\n\ttp->tp_diff_update = TRUE;\n    }\n\n    if (line2 == MAXLNUM)\n    {\n\t// mark_adjust(99, MAXLNUM, 9, 0): insert lines\n\tinserted = amount;\n\tdeleted = 0;\n    }\n    else if (amount_after > 0)\n    {\n\t// mark_adjust(99, 98, MAXLNUM, 9): a change that inserts lines\n\tinserted = amount_after;\n\tdeleted = 0;\n    }\n    else\n    {\n\t// mark_adjust(98, 99, MAXLNUM, -2): delete lines\n\tinserted = 0;\n\tdeleted = -amount_after;\n    }\n\n    dprev = NULL;\n    dp = tp->tp_first_diff;\n    for (;;)\n    {\n\t// If the change is after the previous diff block and before the next\n\t// diff block, thus not touching an existing change, create a new diff\n\t// block.  Don't do this when ex_diffgetput() is busy.\n\tif ((dp == NULL || dp->df_lnum[idx] - 1 > line2\n\t\t    || (line2 == MAXLNUM && dp->df_lnum[idx] > line1))\n\t\t&& (dprev == NULL\n\t\t    || dprev->df_lnum[idx] + dprev->df_count[idx] < line1)\n\t\t&& !diff_busy)\n\t{\n\t    dnext = diff_alloc_new(tp, dprev, dp);\n\t    if (dnext == NULL)\n\t\treturn;\n\n\t    dnext->df_lnum[idx] = line1;\n\t    dnext->df_count[idx] = inserted;\n\t    for (i = 0; i < DB_COUNT; ++i)\n\t\tif (tp->tp_diffbuf[i] != NULL && i != idx)\n\t\t{\n\t\t    if (dprev == NULL)\n\t\t\tdnext->df_lnum[i] = line1;\n\t\t    else\n\t\t\tdnext->df_lnum[i] = line1\n\t\t\t    + (dprev->df_lnum[i] + dprev->df_count[i])\n\t\t\t    - (dprev->df_lnum[idx] + dprev->df_count[idx]);\n\t\t    dnext->df_count[i] = deleted;\n\t\t}\n\t}\n\n\t// if at end of the list, quit\n\tif (dp == NULL)\n\t    break;\n\n\t/*\n\t * Check for these situations:\n\t *\t  1  2\t3\n\t *\t  1  2\t3\n\t * line1     2\t3  4  5\n\t *\t     2\t3  4  5\n\t *\t     2\t3  4  5\n\t * line2     2\t3  4  5\n\t *\t\t3     5  6\n\t *\t\t3     5  6\n\t */\n\t// compute last line of this change\n\tlast = dp->df_lnum[idx] + dp->df_count[idx] - 1;\n\n\t// 1. change completely above line1: nothing to do\n\tif (last >= line1 - 1)\n\t{\n\t    // 6. change below line2: only adjust for amount_after; also when\n\t    // \"deleted\" became zero when deleted all lines between two diffs\n\t    if (dp->df_lnum[idx] - (deleted + inserted != 0) > line2)\n\t    {\n\t\tif (amount_after == 0)\n\t\t    break;\t// nothing left to change\n\t\tdp->df_lnum[idx] += amount_after;\n\t    }\n\t    else\n\t    {\n\t\tcheck_unchanged = FALSE;\n\n\t\t// 2. 3. 4. 5.: inserted/deleted lines touching this diff.\n\t\tif (deleted > 0)\n\t\t{\n\t\t    off = 0;\n\t\t    if (dp->df_lnum[idx] >= line1)\n\t\t    {\n\t\t\tif (last <= line2)\n\t\t\t{\n\t\t\t    // 4. delete all lines of diff\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp->df_next->df_lnum[idx] - lnum_deleted;\n\t\t\t\tdeleted -= n;\n\t\t\t\tn -= dp->df_count[idx];\n\t\t\t\tlnum_deleted = dp->df_next->df_lnum[idx];\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tn = deleted - dp->df_count[idx];\n\t\t\t    dp->df_count[idx] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // 5. delete lines at or just before top of diff\n\t\t\t    off = dp->df_lnum[idx] - lnum_deleted;\n\t\t\t    n = off;\n\t\t\t    dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\tdp->df_lnum[idx] = line1;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (last < line2)\n\t\t\t{\n\t\t\t    // 2. delete at end of diff\n\t\t\t    dp->df_count[idx] -= last - lnum_deleted + 1;\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp->df_next->df_lnum[idx] - 1 - last;\n\t\t\t\tdeleted -= dp->df_next->df_lnum[idx]\n\t\t\t\t\t\t\t       - lnum_deleted;\n\t\t\t\tlnum_deleted = dp->df_next->df_lnum[idx];\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tn = line2 - last;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // 3. delete lines inside the diff\n\t\t\t    n = 0;\n\t\t\t    dp->df_count[idx] -= deleted;\n\t\t\t}\n\t\t    }\n\n\t\t    for (i = 0; i < DB_COUNT; ++i)\n\t\t\tif (tp->tp_diffbuf[i] != NULL && i != idx)\n\t\t\t{\n\t\t\t    dp->df_lnum[i] -= off;\n\t\t\t    dp->df_count[i] += n;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (dp->df_lnum[idx] <= line1)\n\t\t    {\n\t\t\t// inserted lines somewhere in this diff\n\t\t\tdp->df_count[idx] += inserted;\n\t\t\tcheck_unchanged = TRUE;\n\t\t    }\n\t\t    else\n\t\t\t// inserted lines somewhere above this diff\n\t\t\tdp->df_lnum[idx] += inserted;\n\t\t}\n\n\t\tif (check_unchanged)\n\t\t    // Check if inserted lines are equal, may reduce the\n\t\t    // size of the diff.  TODO: also check for equal lines\n\t\t    // in the middle and perhaps split the block.\n\t\t    diff_check_unchanged(tp, dp);\n\t    }\n\t}\n\n\t// check if this block touches the previous one, may merge them.\n\tif (dprev != NULL && dprev->df_lnum[idx] + dprev->df_count[idx]\n\t\t\t\t\t\t\t  == dp->df_lnum[idx])\n\t{\n\t    for (i = 0; i < DB_COUNT; ++i)\n\t\tif (tp->tp_diffbuf[i] != NULL)\n\t\t    dprev->df_count[i] += dp->df_count[i];\n\t    dprev->df_next = dp->df_next;\n\t    vim_free(dp);\n\t    dp = dprev->df_next;\n\t}\n\telse\n\t{\n\t    // Advance to next entry.\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t}\n    }\n\n    dprev = NULL;\n    dp = tp->tp_first_diff;\n    while (dp != NULL)\n    {\n\t// All counts are zero, remove this entry.\n\tfor (i = 0; i < DB_COUNT; ++i)\n\t    if (tp->tp_diffbuf[i] != NULL && dp->df_count[i] != 0)\n\t\tbreak;\n\tif (i == DB_COUNT)\n\t{\n\t    dnext = dp->df_next;\n\t    vim_free(dp);\n\t    dp = dnext;\n\t    if (dprev == NULL)\n\t\ttp->tp_first_diff = dnext;\n\t    else\n\t\tdprev->df_next = dnext;\n\t}\n\telse\n\t{\n\t    // Advance to next entry.\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t}\n\n    }\n\n    if (tp == curtab)\n    {\n\t// Don't redraw right away, this updates the diffs, which can be slow.\n\tneed_diff_redraw = TRUE;\n\n\t// Need to recompute the scroll binding, may remove or add filler\n\t// lines (e.g., when adding lines above w_topline). But it's slow when\n\t// making many changes, postpone until redrawing.\n\tdiff_need_scrollbind = TRUE;\n    }\n}",
      "line_statements": [
        [
          406,
          "\t\t    off = 0;"
        ],
        [
          429,
          "\t\t\t    off = dp->df_lnum[idx] - lnum_deleted;"
        ]
      ],
      "statements": [
        [
          406,
          "off = 0;"
        ],
        [
          429,
          "off = dp->df_lnum[idx] - lnum_deleted;"
        ]
      ],
      "cve": "CVE-2022-2210"
    },
    {
      "commit_id": "88cf60a3ed4a2b40d71a1c2ced72fa3902a30967",
      "filepath": "DesktopEditor/common/File.cpp",
      "project": "core",
      "project_repo_path": "symbol_backend_projects/core",
      "is_vulnerable": false,
      "func_name": "NSFile::CUtf8Converter::GetUnicodeStringFromUTF8_4bytes",
      "func_body": "    void CUtf8Converter::GetUnicodeStringFromUTF8_4bytes( BYTE* pBuffer, LONG lCount, std::wstring& sOutput )\n    {\n        WCHAR* pUnicodeString = new WCHAR[lCount + 1];\n        LONG lIndexUnicode = 0;\n\n        LONG lIndex = 0;\n        while (lIndex < lCount)\n        {\n            BYTE byteMain = pBuffer[lIndex];\n            if (0x00 == (byteMain & 0x80))\n            {\n                // 1 byte\n                pUnicodeString[lIndexUnicode++] = (WCHAR)byteMain;\n                ++lIndex;\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                // 2 byte\n                int val = 0;\n                if ((lIndex + 1) < lCount)\n                {\n                    val = (int)(((byteMain & 0x1F) << 6) |\n                                (pBuffer[lIndex + 1] & 0x3F));\n                }\n\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                // 3 byte\n                int val = 0;\n                if ((lIndex + 2) < lCount)\n                {\n                    val = (int)(((byteMain & 0x0F) << 12) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 2] & 0x3F));\n                }\n\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                // 4 byte\n                int val = 0;\n                if ((lIndex + 3) < lCount)\n                {\n                    val = (int)(((byteMain & 0x07) << 18) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 3] & 0x3F));\n                }\n\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                // 4 byte\n                int val = 0;\n                if ((lIndex + 3) < lCount)\n                {\n                    val = (int)(((byteMain & 0x07) << 18) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 3] & 0x3F));\n                }\n\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                // 5 byte\n                int val = 0;\n                if ((lIndex + 4) < lCount)\n                {\n                    val = (int)(((byteMain & 0x03) << 24) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 4] & 0x3F));\n                }\n\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 5;\n            }\n            else\n            {\n                // 6 byte\n                int val = 0;\n                if ((lIndex + 5) < lCount)\n                {\n                    val = (int)(((byteMain & 0x01) << 30) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                                ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 5] & 0x3F));\n                }\n\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 5;\n            }\n        }\n\n        pUnicodeString[lIndexUnicode] = 0;\n\n        sOutput.append(pUnicodeString);\n\n        delete [] pUnicodeString;\n    }",
      "line_statements": [
        [
          162,
          "                int val = 0;"
        ],
        [
          163,
          "                if ((lIndex + 1) < lCount)"
        ],
        [
          164,
          "                {"
        ],
        [
          165,
          "                    val = (int)(((byteMain & 0x1F) << 6) |"
        ],
        [
          166,
          "                                (pBuffer[lIndex + 1] & 0x3F));"
        ],
        [
          167,
          "                }"
        ],
        [
          168,
          ""
        ],
        [
          175,
          "                int val = 0;"
        ],
        [
          176,
          "                if ((lIndex + 2) < lCount)"
        ],
        [
          177,
          "                {"
        ],
        [
          178,
          "                    val = (int)(((byteMain & 0x0F) << 12) |"
        ],
        [
          179,
          "                                ((pBuffer[lIndex + 1] & 0x3F) << 6) |"
        ],
        [
          180,
          "                                (pBuffer[lIndex + 2] & 0x3F));"
        ],
        [
          181,
          "                }"
        ],
        [
          182,
          ""
        ],
        [
          189,
          "                int val = 0;"
        ],
        [
          190,
          "                if ((lIndex + 3) < lCount)"
        ],
        [
          191,
          "                {"
        ],
        [
          192,
          "                    val = (int)(((byteMain & 0x07) << 18) |"
        ],
        [
          193,
          "                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |"
        ],
        [
          194,
          "                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |"
        ],
        [
          195,
          "                                (pBuffer[lIndex + 3] & 0x3F));"
        ],
        [
          196,
          "                }"
        ],
        [
          197,
          ""
        ],
        [
          204,
          "                int val = 0;"
        ],
        [
          205,
          "                if ((lIndex + 3) < lCount)"
        ],
        [
          206,
          "                {"
        ],
        [
          207,
          "                    val = (int)(((byteMain & 0x07) << 18) |"
        ],
        [
          208,
          "                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |"
        ],
        [
          209,
          "                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |"
        ],
        [
          210,
          "                                (pBuffer[lIndex + 3] & 0x3F));"
        ],
        [
          211,
          "                }"
        ],
        [
          212,
          ""
        ],
        [
          219,
          "                int val = 0;"
        ],
        [
          220,
          "                if ((lIndex + 4) < lCount)"
        ],
        [
          221,
          "                {"
        ],
        [
          222,
          "                    val = (int)(((byteMain & 0x03) << 24) |"
        ],
        [
          223,
          "                                ((pBuffer[lIndex + 1] & 0x3F) << 18) |"
        ],
        [
          224,
          "                                ((pBuffer[lIndex + 2] & 0x3F) << 12) |"
        ],
        [
          225,
          "                                ((pBuffer[lIndex + 3] & 0x3F) << 6) |"
        ],
        [
          226,
          "                                (pBuffer[lIndex + 4] & 0x3F));"
        ],
        [
          227,
          "                }"
        ],
        [
          228,
          ""
        ],
        [
          235,
          "                int val = 0;"
        ],
        [
          236,
          "                if ((lIndex + 5) < lCount)"
        ],
        [
          237,
          "                {"
        ],
        [
          238,
          "                    val = (int)(((byteMain & 0x01) << 30) |"
        ],
        [
          239,
          "                                ((pBuffer[lIndex + 1] & 0x3F) << 24) |"
        ],
        [
          240,
          "                                ((pBuffer[lIndex + 2] & 0x3F) << 18) |"
        ],
        [
          241,
          "                                ((pBuffer[lIndex + 3] & 0x3F) << 12) |"
        ],
        [
          242,
          "                                ((pBuffer[lIndex + 4] & 0x3F) << 6) |"
        ],
        [
          243,
          "                                (pBuffer[lIndex + 5] & 0x3F));"
        ],
        [
          244,
          "                }"
        ],
        [
          245,
          ""
        ]
      ],
      "statements": [
        [
          162,
          "int val = 0;"
        ],
        [
          163,
          "if ((lIndex + 1) < lCount)"
        ],
        [
          164,
          "                {\n"
        ],
        [
          165,
          "val = (int)(((byteMain & 0x1F) << 6) |\n                                (pBuffer[lIndex + 1] & 0x3F));"
        ],
        [
          167,
          "                }\n"
        ],
        [
          168,
          "\n"
        ],
        [
          175,
          "int val = 0;"
        ],
        [
          176,
          "if ((lIndex + 2) < lCount)"
        ],
        [
          177,
          "                {\n"
        ],
        [
          178,
          "val = (int)(((byteMain & 0x0F) << 12) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 2] & 0x3F));"
        ],
        [
          181,
          "                }\n"
        ],
        [
          182,
          "\n"
        ],
        [
          189,
          "int val = 0;"
        ],
        [
          190,
          "if ((lIndex + 3) < lCount)"
        ],
        [
          191,
          "                {\n"
        ],
        [
          192,
          "val = (int)(((byteMain & 0x07) << 18) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 3] & 0x3F));"
        ],
        [
          196,
          "                }\n"
        ],
        [
          197,
          "\n"
        ],
        [
          204,
          "int val = 0;"
        ],
        [
          205,
          "if ((lIndex + 3) < lCount)"
        ],
        [
          206,
          "                {\n"
        ],
        [
          207,
          "val = (int)(((byteMain & 0x07) << 18) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 3] & 0x3F));"
        ],
        [
          211,
          "                }\n"
        ],
        [
          212,
          "\n"
        ],
        [
          219,
          "int val = 0;"
        ],
        [
          220,
          "if ((lIndex + 4) < lCount)"
        ],
        [
          221,
          "                {\n"
        ],
        [
          222,
          "val = (int)(((byteMain & 0x03) << 24) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 4] & 0x3F));"
        ],
        [
          227,
          "                }\n"
        ],
        [
          228,
          "\n"
        ],
        [
          235,
          "int val = 0;"
        ],
        [
          236,
          "if ((lIndex + 5) < lCount)"
        ],
        [
          237,
          "                {\n"
        ],
        [
          238,
          "val = (int)(((byteMain & 0x01) << 30) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                                ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 5] & 0x3F));"
        ],
        [
          244,
          "                }\n"
        ],
        [
          245,
          "\n"
        ]
      ],
      "cve": "CVE-2022-29776"
    },
    {
      "commit_id": "36cfd9efb9b22b891adee9c48d30202289cfa620",
      "filepath": "src/svg/qsvghandler.cpp",
      "project": "qtsvg",
      "project_repo_path": "symbol_backend_projects/qtsvg",
      "is_vulnerable": false,
      "func_name": "parsePathDataFast",
      "func_body": "static bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n{\n    const int maxElementCount = 0x7fff; // Assume file corruption if more path elements than this\n    qreal x0 = 0, y0 = 0;              // starting point\n    qreal x = 0, y = 0;                // current point\n    char lastMode = 0;\n    QPointF ctrlPt;\n    const QChar *str = dataStr.constData();\n    const QChar *end = str + dataStr.size();\n\n    bool ok = true;\n    while (ok && str != end) {\n        while (str->isSpace() && (str + 1) != end)\n            ++str;\n        QChar pathElem = *str;\n        ++str;\n        QChar endc = *end;\n        *const_cast<QChar *>(end) = u'\\0'; // parseNumbersArray requires 0-termination that QStringView cannot guarantee\n        const char *pattern = nullptr;\n        if (pathElem == QLatin1Char('a') || pathElem == QLatin1Char('A'))\n            pattern = \"rrrffrr\";\n        QVarLengthArray<qreal, 8> arg;\n        parseNumbersArray(str, arg, pattern);\n        *const_cast<QChar *>(end) = endc;\n        if (pathElem == QLatin1Char('z') || pathElem == QLatin1Char('Z'))\n            arg.append(0);//dummy\n        const qreal *num = arg.constData();\n        int count = arg.count();\n        while (ok && count > 0) {\n            qreal offsetX = x;        // correction offsets\n            qreal offsetY = y;        // for relative commands\n            switch (pathElem.unicode()) {\n            case 'm': {\n                if (count < 2) {\n                    ok = false;\n                    break;\n                }\n                x = x0 = num[0] + offsetX;\n                y = y0 = num[1] + offsetY;\n                num += 2;\n                count -= 2;\n                path.moveTo(x0, y0);\n\n                 // As per 1.2  spec 8.3.2 The \"moveto\" commands\n                 // If a 'moveto' is followed by multiple pairs of coordinates without explicit commands,\n                 // the subsequent pairs shall be treated as implicit 'lineto' commands.\n                 pathElem = QLatin1Char('l');\n            }\n                break;\n            case 'M': {\n                if (count < 2) {\n                    ok = false;\n                    break;\n                }\n                x = x0 = num[0];\n                y = y0 = num[1];\n                num += 2;\n                count -= 2;\n                path.moveTo(x0, y0);\n\n                // As per 1.2  spec 8.3.2 The \"moveto\" commands\n                // If a 'moveto' is followed by multiple pairs of coordinates without explicit commands,\n                // the subsequent pairs shall be treated as implicit 'lineto' commands.\n                pathElem = QLatin1Char('L');\n            }\n                break;\n            case 'z':\n            case 'Z': {\n                x = x0;\n                y = y0;\n                count--; // skip dummy\n                num++;\n                path.closeSubpath();\n            }\n                break;\n            case 'l': {\n                if (count < 2) {\n                    ok = false;\n                    break;\n                }\n                x = num[0] + offsetX;\n                y = num[1] + offsetY;\n                num += 2;\n                count -= 2;\n                path.lineTo(x, y);\n\n            }\n                break;\n            case 'L': {\n                if (count < 2) {\n                    ok = false;\n                    break;\n                }\n                x = num[0];\n                y = num[1];\n                num += 2;\n                count -= 2;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'h': {\n                x = num[0] + offsetX;\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'H': {\n                x = num[0];\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'v': {\n                y = num[0] + offsetY;\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'V': {\n                y = num[0];\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'c': {\n                if (count < 6) {\n                    ok = false;\n                    break;\n                }\n                QPointF c1(num[0] + offsetX, num[1] + offsetY);\n                QPointF c2(num[2] + offsetX, num[3] + offsetY);\n                QPointF e(num[4] + offsetX, num[5] + offsetY);\n                num += 6;\n                count -= 6;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'C': {\n                if (count < 6) {\n                    ok = false;\n                    break;\n                }\n                QPointF c1(num[0], num[1]);\n                QPointF c2(num[2], num[3]);\n                QPointF e(num[4], num[5]);\n                num += 6;\n                count -= 6;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 's': {\n                if (count < 4) {\n                    ok = false;\n                    break;\n                }\n                QPointF c1;\n                if (lastMode == 'c' || lastMode == 'C' ||\n                    lastMode == 's' || lastMode == 'S')\n                    c1 = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c1 = QPointF(x, y);\n                QPointF c2(num[0] + offsetX, num[1] + offsetY);\n                QPointF e(num[2] + offsetX, num[3] + offsetY);\n                num += 4;\n                count -= 4;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'S': {\n                if (count < 4) {\n                    ok = false;\n                    break;\n                }\n                QPointF c1;\n                if (lastMode == 'c' || lastMode == 'C' ||\n                    lastMode == 's' || lastMode == 'S')\n                    c1 = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c1 = QPointF(x, y);\n                QPointF c2(num[0], num[1]);\n                QPointF e(num[2], num[3]);\n                num += 4;\n                count -= 4;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'q': {\n                if (count < 4) {\n                    ok = false;\n                    break;\n                }\n                QPointF c(num[0] + offsetX, num[1] + offsetY);\n                QPointF e(num[2] + offsetX, num[3] + offsetY);\n                num += 4;\n                count -= 4;\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'Q': {\n                if (count < 4) {\n                    ok = false;\n                    break;\n                }\n                QPointF c(num[0], num[1]);\n                QPointF e(num[2], num[3]);\n                num += 4;\n                count -= 4;\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 't': {\n                if (count < 2) {\n                    ok = false;\n                    break;\n                }\n                QPointF e(num[0] + offsetX, num[1] + offsetY);\n                num += 2;\n                count -= 2;\n                QPointF c;\n                if (lastMode == 'q' || lastMode == 'Q' ||\n                    lastMode == 't' || lastMode == 'T')\n                    c = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c = QPointF(x, y);\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'T': {\n                if (count < 2) {\n                    ok = false;\n                    break;\n                }\n                QPointF e(num[0], num[1]);\n                num += 2;\n                count -= 2;\n                QPointF c;\n                if (lastMode == 'q' || lastMode == 'Q' ||\n                    lastMode == 't' || lastMode == 'T')\n                    c = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c = QPointF(x, y);\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'a': {\n                if (count < 7) {\n                    ok = false;\n                    break;\n                }\n                qreal rx = (*num++);\n                qreal ry = (*num++);\n                qreal xAxisRotation = (*num++);\n                qreal largeArcFlag  = (*num++);\n                qreal sweepFlag = (*num++);\n                qreal ex = (*num++) + offsetX;\n                qreal ey = (*num++) + offsetY;\n                count -= 7;\n                qreal curx = x;\n                qreal cury = y;\n                pathArc(path, rx, ry, xAxisRotation, int(largeArcFlag),\n                        int(sweepFlag), ex, ey, curx, cury);\n\n                x = ex;\n                y = ey;\n            }\n                break;\n            case 'A': {\n                if (count < 7) {\n                    ok = false;\n                    break;\n                }\n                qreal rx = (*num++);\n                qreal ry = (*num++);\n                qreal xAxisRotation = (*num++);\n                qreal largeArcFlag  = (*num++);\n                qreal sweepFlag = (*num++);\n                qreal ex = (*num++);\n                qreal ey = (*num++);\n                count -= 7;\n                qreal curx = x;\n                qreal cury = y;\n                pathArc(path, rx, ry, xAxisRotation, int(largeArcFlag),\n                        int(sweepFlag), ex, ey, curx, cury);\n\n                x = ex;\n                y = ey;\n            }\n                break;\n            default:\n                ok = false;\n                break;\n            }\n            lastMode = pathElem.toLatin1();\n            if (path.elementCount() > maxElementCount)\n                ok = false;\n        }\n    }\n    return ok;\n}",
      "line_statements": [
        [
          1598,
          "    const int maxElementCount = 0x7fff; // Assume file corruption if more path elements than this"
        ],
        [
          1606,
          "    bool ok = true;"
        ],
        [
          1607,
          "    while (ok && str != end) {"
        ],
        [
          1624,
          "        while (ok && count > 0) {"
        ],
        [
          1630,
          "                    ok = false;"
        ],
        [
          1647,
          "                    ok = false;"
        ],
        [
          1673,
          "                    ok = false;"
        ],
        [
          1686,
          "                    ok = false;"
        ],
        [
          1726,
          "                    ok = false;"
        ],
        [
          1742,
          "                    ok = false;"
        ],
        [
          1758,
          "                    ok = false;"
        ],
        [
          1779,
          "                    ok = false;"
        ],
        [
          1800,
          "                    ok = false;"
        ],
        [
          1815,
          "                    ok = false;"
        ],
        [
          1830,
          "                    ok = false;"
        ],
        [
          1850,
          "                    ok = false;"
        ],
        [
          1870,
          "                    ok = false;"
        ],
        [
          1892,
          "                    ok = false;"
        ],
        [
          1913,
          "                ok = false;"
        ],
        [
          1914,
          "                break;"
        ],
        [
          1917,
          "            if (path.elementCount() > maxElementCount)"
        ],
        [
          1918,
          "                ok = false;"
        ],
        [
          1921,
          "    return ok;"
        ]
      ],
      "statements": [
        [
          1598,
          "    const int maxElementCount = 0x7fff; // Assume file corruption if more path elements than this\n"
        ],
        [
          1606,
          "bool ok = true;"
        ],
        [
          1607,
          "while (ok && str != end) {"
        ],
        [
          1624,
          "while (ok && count > 0) {"
        ],
        [
          1630,
          "ok = false;"
        ],
        [
          1647,
          "ok = false;"
        ],
        [
          1673,
          "ok = false;"
        ],
        [
          1686,
          "ok = false;"
        ],
        [
          1726,
          "ok = false;"
        ],
        [
          1742,
          "ok = false;"
        ],
        [
          1758,
          "ok = false;"
        ],
        [
          1779,
          "ok = false;"
        ],
        [
          1800,
          "ok = false;"
        ],
        [
          1815,
          "ok = false;"
        ],
        [
          1830,
          "ok = false;"
        ],
        [
          1850,
          "ok = false;"
        ],
        [
          1870,
          "ok = false;"
        ],
        [
          1892,
          "ok = false;"
        ],
        [
          1913,
          "ok = false;"
        ],
        [
          1914,
          "break;"
        ],
        [
          1917,
          "if (path.elementCount() > maxElementCount)"
        ],
        [
          1918,
          "ok = false;"
        ],
        [
          1921,
          "return ok;"
        ]
      ],
      "cve": "CVE-2021-45930"
    },
    {
      "commit_id": "61135001a625364e29bdce83832f043eebde7b5a",
      "filepath": "coders/gif.c",
      "project": "ImageMagick",
      "project_repo_path": "symbol_backend_projects/ImageMagick",
      "is_vulnerable": false,
      "func_name": "EncodeImage",
      "func_body": "static MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,\n  const size_t data_size,ExceptionInfo *exception)\n{\n#define MaxCode(number_bits)  ((one << (number_bits))-1)\n#define MaxHashTable  5003\n#define MaxGIFBits  12UL\n#define MaxGIFTable  (1UL << MaxGIFBits)\n#define GIFOutputCode(code) \\\n{ \\\n  /*  \\\n    Emit a code. \\\n  */ \\\n  if (bits > 0) \\\n    datum|=(size_t) (code) << bits; \\\n  else \\\n    datum=(size_t) (code); \\\n  bits+=number_bits; \\\n  while (bits >= 8) \\\n  { \\\n    /*  \\\n      Add a character to current packet. \\\n    */ \\\n    packet[length++]=(unsigned char) (datum & 0xff); \\\n    if (length >= 254) \\\n      { \\\n        (void) WriteBlobByte(image,(unsigned char) length); \\\n        (void) WriteBlob(image,length,packet); \\\n        length=0; \\\n      } \\\n    datum>>=8; \\\n    bits-=8; \\\n  } \\\n  if (free_code > max_code)  \\\n    { \\\n      number_bits++; \\\n      if (number_bits == MaxGIFBits) \\\n        max_code=MaxGIFTable; \\\n      else \\\n        max_code=MaxCode(number_bits); \\\n    } \\\n}\n\n  Quantum\n    index;\n\n  short\n    *hash_code,\n    *hash_prefix,\n    waiting_code;\n\n  size_t\n    bits,\n    clear_code,\n    datum,\n    end_of_information_code,\n    free_code,\n    length,\n    max_code,\n    next_pixel,\n    number_bits,\n    one,\n    pass;\n\n  ssize_t\n    displacement,\n    offset,\n    k,\n    y;\n\n  unsigned char\n    *packet,\n    *hash_suffix;\n\n  /*\n    Allocate encoder tables.\n  */\n  assert(image != (Image *) NULL);\n  one=1;\n  packet=(unsigned char *) AcquireQuantumMemory(256,sizeof(*packet));\n  hash_code=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_code));\n  hash_prefix=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_prefix));\n  hash_suffix=(unsigned char *) AcquireQuantumMemory(MaxHashTable,\n    sizeof(*hash_suffix));\n  if ((packet == (unsigned char *) NULL) || (hash_code == (short *) NULL) ||\n      (hash_prefix == (short *) NULL) ||\n      (hash_suffix == (unsigned char *) NULL))\n    {\n      if (packet != (unsigned char *) NULL)\n        packet=(unsigned char *) RelinquishMagickMemory(packet);\n      if (hash_code != (short *) NULL)\n        hash_code=(short *) RelinquishMagickMemory(hash_code);\n      if (hash_prefix != (short *) NULL)\n        hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);\n      if (hash_suffix != (unsigned char *) NULL)\n        hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);\n      return(MagickFalse);\n    }\n  /*\n    Initialize GIF encoder.\n  */\n  (void) memset(packet,0,256*sizeof(*packet));\n  (void) memset(hash_code,0,MaxHashTable*sizeof(*hash_code));\n  (void) memset(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix));\n  (void) memset(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix));\n  number_bits=data_size;\n  max_code=MaxCode(number_bits);\n  clear_code=((short) one << (data_size-1));\n  end_of_information_code=clear_code+1;\n  free_code=clear_code+2;\n  length=0;\n  datum=0;\n  bits=0;\n  GIFOutputCode(clear_code);\n  /*\n    Encode pixels.\n  */\n  offset=0;\n  pass=0;\n  waiting_code=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,offset,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if (y == 0)\n      {\n        waiting_code=(short) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n    for (x=(ssize_t) (y == 0 ? 1 : 0); x < (ssize_t) image->columns; x++)\n    {\n      /*\n        Probe hash table.\n      */\n      next_pixel=MagickFalse;\n      displacement=1;\n      index=(Quantum) ((size_t) GetPixelIndex(image,p) & 0xff);\n      p+=GetPixelChannels(image);\n      k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code);\n      if (k >= MaxHashTable)\n        k-=MaxHashTable;\n      if (k < 0)\n        continue;\n      if (hash_code[k] > 0)\n        {\n          if ((hash_prefix[k] == waiting_code) &&\n              (hash_suffix[k] == (unsigned char) index))\n            {\n              waiting_code=hash_code[k];\n              continue;\n            }\n          if (k != 0)\n            displacement=MaxHashTable-k;\n          for ( ; ; )\n          {\n            k-=displacement;\n            if (k < 0)\n              k+=MaxHashTable;\n            if (hash_code[k] == 0)\n              break;\n            if ((hash_prefix[k] == waiting_code) &&\n                (hash_suffix[k] == (unsigned char) index))\n              {\n                waiting_code=hash_code[k];\n                next_pixel=MagickTrue;\n                break;\n              }\n          }\n          if (next_pixel != MagickFalse)\n            continue;\n        }\n      GIFOutputCode(waiting_code);\n      if (free_code < MaxGIFTable)\n        {\n          hash_code[k]=(short) free_code++;\n          hash_prefix[k]=waiting_code;\n          hash_suffix[k]=(unsigned char) index;\n        }\n      else\n        {\n          /*\n            Fill the hash table with empty entries.\n          */\n          for (k=0; k < MaxHashTable; k++)\n            hash_code[k]=0;\n          /*\n            Reset compressor and issue a clear code.\n          */\n          free_code=clear_code+2;\n          GIFOutputCode(clear_code);\n          number_bits=data_size;\n          max_code=MaxCode(number_bits);\n        }\n      waiting_code=(short) index;\n    }\n    if (image_info->interlace == NoInterlace)\n      offset++;\n    else\n      switch (pass)\n      {\n        case 0:\n        default:\n        {\n          offset+=8;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=4;\n            }\n          break;\n        }\n        case 1:\n        {\n          offset+=8;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=2;\n            }\n          break;\n        }\n        case 2:\n        {\n          offset+=4;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=1;\n            }\n          break;\n        }\n        case 3:\n        {\n          offset+=2;\n          break;\n        }\n      }\n  }\n  /*\n    Flush out the buffered code.\n  */\n  GIFOutputCode(waiting_code);\n  GIFOutputCode(end_of_information_code);\n  if (bits > 0)\n    {\n      /*\n        Add a character to current packet.\n      */\n      packet[length++]=(unsigned char) (datum & 0xff);\n      if (length >= 254)\n        {\n          (void) WriteBlobByte(image,(unsigned char) length);\n          (void) WriteBlob(image,length,packet);\n          length=0;\n        }\n    }\n  /*\n    Flush accumulated data.\n  */\n  if (length > 0)\n    {\n      (void) WriteBlobByte(image,(unsigned char) length);\n      (void) WriteBlob(image,length,packet);\n    }\n  /*\n    Free encoder memory.\n  */\n  hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);\n  hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);\n  hash_code=(short *) RelinquishMagickMemory(hash_code);\n  packet=(unsigned char *) RelinquishMagickMemory(packet);\n  return(MagickTrue);\n}",
      "line_statements": [
        [
          676,
          "      next_pixel=MagickFalse;"
        ],
        [
          677,
          "      displacement=1;"
        ],
        [
          683,
          "      if (k < 0)"
        ],
        [
          684,
          "        continue;"
        ]
      ],
      "statements": [
        [
          676,
          "next_pixel=MagickFalse;"
        ],
        [
          677,
          "displacement=1;"
        ],
        [
          683,
          "if (k < 0)"
        ],
        [
          684,
          "continue;"
        ]
      ],
      "cve": "CVE-2019-13308"
    }
  ],
  "CWE-119": [
    {
      "commit_id": "fbb687db1088ddd894d975996e5f6a4252b9a2b4",
      "filepath": "src/plugins/preauth/pkinit/pkinit_crypto_openssl.c",
      "project": "krb5",
      "project_repo_path": "symbol_backend_projects/krb5",
      "is_vulnerable": false,
      "func_name": "rfc2253_name",
      "func_body": "rfc2253_name(X509_NAME *name, char **str_out)\n{\n    BIO *b = NULL;\n    char *str;\n\n    *str_out = NULL;\n    b = BIO_new(BIO_s_mem());\n    if (b == NULL)\n        return ENOMEM;\n    if (X509_NAME_print_ex(b, name, 0, XN_FLAG_SEP_COMMA_PLUS) < 0)\n        goto error;\n    str = calloc(BIO_number_written(b) + 1, 1);\n    if (str == NULL)\n        goto error;\n    BIO_read(b, str, BIO_number_written(b));\n    BIO_free(b);\n    *str_out = str;\n    return 0;\n\nerror:\n    BIO_free(b);\n    return ENOMEM;\n}",
      "line_statements": [
        [
          5006,
          "rfc2253_name(X509_NAME *name, char **str_out)"
        ],
        [
          5008,
          "    BIO *b = NULL;"
        ],
        [
          5009,
          "    char *str;"
        ],
        [
          5011,
          "    *str_out = NULL;"
        ],
        [
          5012,
          "    b = BIO_new(BIO_s_mem());"
        ],
        [
          5013,
          "    if (b == NULL)"
        ],
        [
          5014,
          "        return ENOMEM;"
        ],
        [
          5015,
          "    if (X509_NAME_print_ex(b, name, 0, XN_FLAG_SEP_COMMA_PLUS) < 0)"
        ],
        [
          5016,
          "        goto error;"
        ],
        [
          5017,
          "    str = calloc(BIO_number_written(b) + 1, 1);"
        ],
        [
          5018,
          "    if (str == NULL)"
        ],
        [
          5019,
          "        goto error;"
        ],
        [
          5020,
          "    BIO_read(b, str, BIO_number_written(b));"
        ],
        [
          5021,
          "    BIO_free(b);"
        ],
        [
          5022,
          "    *str_out = str;"
        ],
        [
          5023,
          "    return 0;"
        ],
        [
          5024,
          ""
        ],
        [
          5025,
          "error:"
        ],
        [
          5026,
          "    BIO_free(b);"
        ],
        [
          5027,
          "    return ENOMEM;"
        ]
      ],
      "statements": [
        [
          5006,
          "rfc2253_name(X509_NAME *name, char **str_out)"
        ],
        [
          5008,
          "BIO *b = NULL;"
        ],
        [
          5009,
          "char *str;"
        ],
        [
          5011,
          "*str_out = NULL;"
        ],
        [
          5012,
          "b = BIO_new(BIO_s_mem());"
        ],
        [
          5013,
          "if (b == NULL)"
        ],
        [
          5014,
          "return ENOMEM;"
        ],
        [
          5015,
          "if (X509_NAME_print_ex(b, name, 0, XN_FLAG_SEP_COMMA_PLUS) < 0)"
        ],
        [
          5016,
          "goto error;"
        ],
        [
          5017,
          "str = calloc(BIO_number_written(b) + 1, 1);"
        ],
        [
          5018,
          "if (str == NULL)"
        ],
        [
          5019,
          "goto error;"
        ],
        [
          5020,
          "BIO_read(b, str, BIO_number_written(b));"
        ],
        [
          5021,
          "BIO_free(b);"
        ],
        [
          5022,
          "*str_out = str;"
        ],
        [
          5023,
          "return 0;"
        ],
        [
          5024,
          "\n"
        ],
        [
          5025,
          "error:"
        ],
        [
          5026,
          "BIO_free(b);"
        ],
        [
          5027,
          "return ENOMEM;"
        ]
      ],
      "cve": "CVE-2017-15088"
    },
    {
      "commit_id": "3d32e4dbe71374a6780eaf51d719d76f9a9bf22f",
      "filepath": "virt/kvm/iommu.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "kvm_pin_pages",
      "func_body": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + (size >> PAGE_SHIFT);\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}\n",
      "line_statements": [
        [
          46,
          "\t\t\t   unsigned long size)\n"
        ],
        [
          52,
          "\tend_gfn = gfn + (size >> PAGE_SHIFT);\n"
        ]
      ],
      "statements": [
        [
          45,
          "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)"
        ],
        [
          52,
          "end_gfn = gfn + (size >> PAGE_SHIFT);"
        ]
      ],
      "cve": "CVE-2014-8369"
    },
    {
      "commit_id": "0b29669c065f60501e7289e1950fa2a618962358",
      "filepath": "drivers/media/video/videobuf-vmalloc.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "__videobuf_mmap_mapper",
      "func_body": "static int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}",
      "line_statements": [
        [
          224,
          "\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);"
        ]
      ],
      "statements": [
        [
          224,
          "map = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);"
        ]
      ],
      "cve": "CVE-2007-6761"
    },
    {
      "commit_id": "ff7f30129f15f7a2213f8ced0cd65c9a331493d9",
      "filepath": "util.c",
      "project": "bfgminer",
      "project_repo_path": "symbol_backend_projects/bfgminer",
      "is_vulnerable": false,
      "func_name": "initiate_stratum",
      "func_body": "bool initiate_stratum(struct pool *pool)\n{\n\tchar s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;\n\tjson_t *val = NULL, *res_val, *err_val;\n\tbool ret = false, recvd = false;\n\tjson_error_t err;\n\tint n2size;\n\n\tif (!setup_stratum_curl(pool))\n\t\tgoto out;\n\nresend:\n\tif (pool->sessionid)\n\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"%s\\\"]}\", swork_id++, pool->sessionid);\n\telse\n\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": []}\", swork_id++);\n\n\tif (!__stratum_send(pool, s, strlen(s))) {\n\t\tapplog(LOG_DEBUG, \"Failed to send s in initiate_stratum\");\n\t\tgoto out;\n\t}\n\n\tif (!socket_full(pool, true)) {\n\t\tapplog(LOG_DEBUG, \"Timed out waiting for response in initiate_stratum\");\n\t\tgoto out;\n\t}\n\n\tsret = recv_line(pool);\n\tif (!sret)\n\t\tgoto out;\n\n\trecvd = true;\n\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\tgoto out;\n\t}\n\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val || json_is_null(res_val) ||\n\t    (err_val && !json_is_null(err_val))) {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC decode failed: %s\", ss);\n\n\t\tfree(ss);\n\n\t\tgoto out;\n\t}\n\n\tsessionid = json_array_string(json_array_get(res_val, 0), 1);\n\tif (!sessionid) {\n\t\tapplog(LOG_INFO, \"Failed to get sessionid in initiate_stratum\");\n\t\tgoto out;\n\t}\n\tnonce1 = json_array_string(res_val, 1);\n\tif (!nonce1) {\n\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tgoto out;\n\t}\n\tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (n2size < 1)\n\t{\n\t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tfree(nonce1);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&pool->pool_lock);\n\tpool->sessionid = sessionid;\n\tfree(pool->nonce1);\n\tpool->nonce1 = nonce1;\n\tpool->n1_len = strlen(nonce1) / 2;\n\tpool->n2size = n2size;\n\tmutex_unlock(&pool->pool_lock);\n\n\tapplog(LOG_DEBUG, \"Pool %d stratum session id: %s\", pool->pool_no, pool->sessionid);\n\n\tret = true;\nout:\n\tif (val)\n\t\tjson_decref(val);\n\n\tif (ret) {\n\t\tif (!pool->stratum_url)\n\t\t\tpool->stratum_url = pool->sockaddr_url;\n\t\tpool->stratum_active = true;\n\t\tpool->swork.diff = 1;\n\t\tif (opt_protocol) {\n\t\t\tapplog(LOG_DEBUG, \"Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d\",\n\t\t\t       pool->pool_no, pool->nonce1, pool->n2size);\n\t\t}\n\t} else {\n\t\tif (recvd && pool->sessionid) {\n\t\t\t/* Reset the sessionid used for stratum resuming in case the pool\n\t\t\t* does not support it, or does not know how to respond to the\n\t\t\t* presence of the sessionid parameter. */\n\t\t\tmutex_lock(&pool->pool_lock);\n\t\t\tfree(pool->sessionid);\n\t\t\tfree(pool->nonce1);\n\t\t\tpool->sessionid = pool->nonce1 = NULL;\n\t\t\tmutex_unlock(&pool->pool_lock);\n\t\t\tapplog(LOG_DEBUG, \"Failed to resume stratum, trying afresh\");\n\t\t\tgoto resend;\n\t\t}\n\t\tapplog(LOG_DEBUG, \"Initiate stratum failed\");\n\t\tif (pool->sock != INVSOCK) {\n\t\t\tshutdown(pool->sock, SHUT_RDWR);\n\t\t\tpool->sock = INVSOCK;\n\t\t}\n\t}\n\n\treturn ret;\n}",
      "line_statements": [
        [
          1708,
          "\tif (n2size < 1)"
        ],
        [
          1709,
          "\t{"
        ]
      ],
      "statements": [
        [
          1708,
          "if (n2size < 1)"
        ],
        [
          1709,
          "\t{\n"
        ]
      ],
      "cve": "CVE-2014-4502"
    },
    {
      "commit_id": "4ea77014af0d6205b05503d1c7aac6eace11d473",
      "filepath": "kernel/signal.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "kill_something_info",
      "func_body": "static int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\n\t/* -INT_MIN is undefined.  Exclude this case to avoid a UBSAN warning */\n\tif (pid == INT_MIN)\n\t\treturn -ESRCH;\n\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}\n",
      "line_statements": [
        [
          1405,
          "\t/* -INT_MIN is undefined.  Exclude this case to avoid a UBSAN warning */\n"
        ],
        [
          1406,
          "\tif (pid == INT_MIN)\n"
        ],
        [
          1407,
          "\t\treturn -ESRCH;\n"
        ],
        [
          1408,
          "\n"
        ]
      ],
      "statements": [
        [
          1405,
          "/* -INT_MIN is undefined.  Exclude this case to avoid a UBSAN warning */"
        ],
        [
          1406,
          "if (pid == INT_MIN)"
        ],
        [
          1407,
          "return -ESRCH;"
        ],
        [
          1408,
          "\n"
        ]
      ],
      "cve": "CVE-2018-10124"
    },
    {
      "commit_id": "59c816c1f24df0204e01851431d3bab3eb76719c",
      "filepath": "drivers/vhost/scsi.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "vhost_scsi_send_evt",
      "func_body": "static void\nvhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\n\tif (tpg && lun) {\n\t\t/* TODO: share lun setup code with virtio-scsi.ko */\n\t\t/*\n\t\t * Note: evt->event is zeroed when we allocate it and\n\t\t * lun[4-7] need to be zero according to virtio-scsi spec.\n\t\t */\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}\n",
      "line_statements": [
        [
          1252,
          "\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n"
        ]
      ],
      "statements": [
        [
          1252,
          "evt->event.lun[1] = tpg->tport_tpgt & 0xFF;"
        ]
      ],
      "cve": "CVE-2015-4036"
    },
    {
      "commit_id": "ed53cd148f43cbab905eaa0f5308c2bf3c48cc37",
      "filepath": "libfreerdp/core/update.c",
      "project": "FreeRDP",
      "project_repo_path": "symbol_backend_projects/FreeRDP",
      "is_vulnerable": false,
      "func_name": "update_recv",
      "func_body": "BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
      "line_statements": [
        [
          810,
          "\t\t\tif (!update_read_synchronize(update, s))"
        ],
        [
          811,
          "\t\t\t\tgoto fail;"
        ]
      ],
      "statements": [
        [
          810,
          "if (!update_read_synchronize(update, s))"
        ],
        [
          811,
          "goto fail;"
        ]
      ],
      "cve": "CVE-2020-11046"
    },
    {
      "commit_id": "f30f9339c9a0b9bbcc6f5ad38804af39db1f479e",
      "filepath": "src/Driver/Ntdriver.c",
      "project": "VeraCrypt",
      "project_repo_path": "symbol_backend_projects/VeraCrypt",
      "is_vulnerable": false,
      "func_name": "ProcessMainDeviceControlIrp",
      "func_body": "NTSTATUS ProcessMainDeviceControlIrp (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension, PIRP Irp)\n{\n\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\tNTSTATUS ntStatus;\n\n\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t{\n\tcase TC_IOCTL_GET_DRIVER_VERSION:\n\tcase TC_IOCTL_LEGACY_GET_DRIVER_VERSION:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))\n\t\t{\n\t\t\tLONG tmp = VERSION_NUM;\n\t\t\tmemcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);\n\t\t\tIrp->IoStatus.Information = sizeof (LONG);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DEVICE_REFCOUNT:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\tLONG deviceObjectCount = 0;\n\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;\n\n\t\t\tif (IoEnumerateDeviceObjectList (TCDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)\n\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;\n\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_ANY_VOLUME_MOUNTED:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\tint drive;\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 0;\n\n\t\t\tfor (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)\n\t\t\t{\n\t\t\t\tif (GetVirtualVolumeDeviceObject (drive))\n\t\t\t\t{\n\t\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (IsBootDriveMounted())\n\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 1;\n\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_OPEN_TEST:\n\t\t{\n\t\t\tOPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tOBJECT_ATTRIBUTES ObjectAttributes;\n\t\t\tHANDLE NtFileHandle;\n\t\t\tUNICODE_STRING FullFileName;\n\t\t\tIO_STATUS_BLOCK IoStatus;\n\t\t\tLARGE_INTEGER offset;\n\t\t\tACCESS_MASK access = FILE_READ_ATTRIBUTES;\n\n\t\t\tif (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))\n\t\t\t\tbreak;\n\n\t\t\tEnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));\n\t\t\tRtlInitUnicodeString (&FullFileName, opentest->wszFileName);\n\n\t\t\tInitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)\n\t\t\t\taccess |= FILE_READ_DATA;\n\n\t\t\tntStatus = ZwCreateFile (&NtFileHandle,\n\t\t\t\t\t\t SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,\n\t\t\t\t\t\t 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);\n\n\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t{\n\t\t\t\topentest->TCBootLoaderDetected = FALSE;\n\t\t\t\topentest->FilesystemDetected = FALSE;\n\t\t\t\tmemset (opentest->VolumeIDComputed, 0, sizeof (opentest->VolumeIDComputed));\n\t\t\t\tmemset (opentest->volumeIDs, 0, sizeof (opentest->volumeIDs));\n\n\t\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)\n\t\t\t\t{\n\t\t\t\t\tbyte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);\n\t\t\t\t\tif (!readBuffer)\n\t\t\t\t\t{\n\t\t\t\t\t\tntStatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Determine if the first sector contains a portion of the VeraCrypt Boot Loader\n\n\t\t\t\t\t\t\toffset.QuadPart = 0;\n\n\t\t\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t\t\t&offset,\n\t\t\t\t\t\t\t\tNULL);\n\n\t\t\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsize_t i;\n\n\t\t\t\t\t\t\t\tif (opentest->bDetectTCBootLoader && IoStatus.Information >= TC_SECTOR_SIZE_BIOS)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Search for the string \"VeraCrypt\"\n\t\t\t\t\t\t\t\t\tfor (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME); ++i)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\topentest->TCBootLoaderDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tswitch (BE64 (*(uint64 *) readBuffer))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcase 0xEB52904E54465320ULL: // NTFS\n\t\t\t\t\t\t\t\t\tcase 0xEB3C904D53444F53ULL: // FAT16/FAT32\n\t\t\t\t\t\t\t\t\tcase 0xEB58904D53444F53ULL: // FAT32\n\t\t\t\t\t\t\t\t\tcase 0xEB76904558464154ULL: // exFAT\n\t\t\t\t\t\t\t\t\tcase 0x0000005265465300ULL: // ReFS\n\t\t\t\t\t\t\t\t\tcase 0xEB58906D6B66732EULL: // FAT32 mkfs.fat\n\t\t\t\t\t\t\t\t\tcase 0xEB58906D6B646F73ULL: // FAT32 mkfs.vfat/mkdosfs\n\t\t\t\t\t\t\t\t\tcase 0xEB3C906D6B66732EULL: // FAT16/FAT12 mkfs.fat\n\t\t\t\t\t\t\t\t\tcase 0xEB3C906D6B646F73ULL: // FAT16/FAT12 mkfs.vfat/mkdosfs\n\t\t\t\t\t\t\t\t\t\topentest->FilesystemDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 0x0000000000000000ULL:\n\t\t\t\t\t\t\t\t\t\t// all 512 bytes are zeroes => unencrypted filesystem like Microsoft reserved partition\n\t\t\t\t\t\t\t\t\t\tif (IsAllZeroes (readBuffer + 8, TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8))\n\t\t\t\t\t\t\t\t\t\t\topentest->FilesystemDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (opentest->bComputeVolumeIDs && (!opentest->DetectFilesystem || !opentest->FilesystemDetected))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint volumeType;\n\t\t\t\t\t\t\t// Go through all volume types (e.g., normal, hidden)\n\t\t\t\t\t\t\tfor (volumeType = TC_VOLUME_TYPE_NORMAL;\n\t\t\t\t\t\t\t\tvolumeType < TC_VOLUME_TYPE_COUNT;\n\t\t\t\t\t\t\t\tvolumeType++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Read the volume header */\n\t\t\t\t\t\t\t\tswitch (volumeType)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase TC_VOLUME_TYPE_NORMAL:\n\t\t\t\t\t\t\t\t\toffset.QuadPart = TC_VOLUME_HEADER_OFFSET;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase TC_VOLUME_TYPE_HIDDEN:\n\n\t\t\t\t\t\t\t\t\toffset.QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t\t\t&offset,\n\t\t\t\t\t\t\t\tNULL);\n\n\t\t\t\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t/* compute the ID of this volume: SHA-256 of the effective header */\n\t\t\t\t\t\t\t\t\tsha256 (opentest->volumeIDs[volumeType], readBuffer, TC_VOLUME_HEADER_EFFECTIVE_SIZE);\n\t\t\t\t\t\t\t\t\topentest->VolumeIDComputed[volumeType] = TRUE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tTCfree (readBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tZwClose (NtFileHandle);\n\t\t\t\tDump (\"Open test on file %ls success.\\n\", opentest->wszFileName);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#if 0\n\t\t\t\tDump (\"Open test on file %ls failed NTSTATUS 0x%08x\\n\", opentest->wszFileName, ntStatus);\n#endif\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;\n\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG:\n\t\t{\n\t\t\tGetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tOBJECT_ATTRIBUTES ObjectAttributes;\n\t\t\tHANDLE NtFileHandle;\n\t\t\tUNICODE_STRING FullFileName;\n\t\t\tIO_STATUS_BLOCK IoStatus;\n\t\t\tLARGE_INTEGER offset;\n\t\t\tsize_t devicePathLen = 0;\n\n\t\t\tif (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))\n\t\t\t\tbreak;\n\n\t\t\t// check that request->DevicePath has the expected format \"\\\\Device\\\\HarddiskXXX\\\\Partition0\"\n\t\t\tif (\t!NT_SUCCESS (RtlUnalignedStringCchLengthW (request->DevicePath, TC_MAX_PATH, &devicePathLen))\n\t\t\t\t||\t(devicePathLen < 28) // 28 is the length of \"\\\\Device\\\\Harddisk0\\\\Partition0\" which is the minimum\n\t\t\t\t||\t(devicePathLen > 30) // 30 is the length of \"\\\\Device\\\\Harddisk255\\\\Partition0\" which is the maximum\n\t\t\t\t||\t(memcmp (request->DevicePath, L\"\\\\Device\\\\Harddisk\", 16 * sizeof (WCHAR)))\n\t\t\t\t||\t(memcmp (&request->DevicePath[devicePathLen - 11], L\"\\\\Partition0\", 11 * sizeof (WCHAR)))\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tEnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));\n\t\t\tRtlInitUnicodeString (&FullFileName, request->DevicePath);\n\n\t\t\tInitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\t\t\tntStatus = ZwCreateFile (&NtFileHandle,\n\t\t\t\tSYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,\n\t\t\t\tFILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);\n\n\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t{\n\t\t\t\tbyte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);\n\t\t\t\tif (!readBuffer)\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Determine if the first sector contains a portion of the VeraCrypt Boot Loader\n\t\t\t\t\toffset.QuadPart = 0;\t// MBR\n\n\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t&offset,\n\t\t\t\t\t\tNULL);\n\n\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t{\n\t\t\t\t\t\t// check that we could read all needed data\n\t\t\t\t\t\tif (IoStatus.Information >= TC_SECTOR_SIZE_BIOS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsize_t i;\n\n\t\t\t\t\t\t\t// Check for dynamic drive\n\t\t\t\t\t\t\trequest->DriveIsDynamic = FALSE;\n\n\t\t\t\t\t\t\tif (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint i;\n\t\t\t\t\t\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trequest->DriveIsDynamic = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trequest->BootLoaderVersion = 0;\n\t\t\t\t\t\t\trequest->Configuration = 0;\n\t\t\t\t\t\t\trequest->UserConfiguration = 0;\n\t\t\t\t\t\t\trequest->CustomUserMessage[0] = 0;\n\n\t\t\t\t\t\t\t// Search for the string \"VeraCrypt\"\n\t\t\t\t\t\t\tfor (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\trequest->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));\n\t\t\t\t\t\t\t\t\trequest->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];\n\n\t\t\t\t\t\t\t\t\tif (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trequest->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];\n\t\t\t\t\t\t\t\t\t\tmemcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (*request);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tTCfree (readBuffer);\n\t\t\t\t}\n\n\t\t\t\tZwClose (NtFileHandle);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_WIPE_PASSWORD_CACHE:\n\t\tWipeCache ();\n\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_PASSWORD_CACHE_STATUS:\n\t\tIrp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_SET_PORTABLE_MODE_STATUS:\n\t\tif (!UserCanAccessDriveDevice())\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_ACCESS_DENIED;\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPortableMode = TRUE;\n\t\t\tDump (\"Setting portable mode\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_PORTABLE_MODE_STATUS:\n\t\tIrp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_MOUNTED_VOLUMES:\n\n\t\tif (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))\n\t\t{\n\t\t\tMOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice;\n\t\t\tint drive;\n\n\t\t\tlist->ulMountedDrives = 0;\n\n\t\t\tfor (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension;\n\n\t\t\t\tListDevice = GetVirtualVolumeDeviceObject (drive);\n\t\t\t\tif (!ListDevice)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t{\n\t\t\t\t\tlist->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);\n\t\t\t\t\tRtlStringCbCopyW (list->wszVolume[ListExtension->nDosDriveNo], sizeof(list->wszVolume[ListExtension->nDosDriveNo]),ListExtension->wszVolume);\n\t\t\t\t\tRtlStringCbCopyW (list->wszLabel[ListExtension->nDosDriveNo], sizeof(list->wszLabel[ListExtension->nDosDriveNo]),ListExtension->wszLabel);\n\t\t\t\t\tmemcpy (list->volumeID[ListExtension->nDosDriveNo], ListExtension->volumeID, VOLUME_ID_SIZE);\n\t\t\t\t\tlist->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;\n\t\t\t\t\tlist->ea[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->ea;\n\t\t\t\t\tif (ListExtension->cryptoInfo->hiddenVolume)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;\t// Hidden volume\n\t\t\t\t\telse if (ListExtension->cryptoInfo->bHiddenVolProtectionAction)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;\t// Normal/outer volume (hidden volume protected AND write already prevented)\n\t\t\t\t\telse if (ListExtension->cryptoInfo->bProtectHiddenVolume)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;\t// Normal/outer volume (hidden volume protected)\n\t\t\t\t\telse\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;\t// Normal volume\n\t\t\t\t\tlist->truecryptMode[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->bTrueCryptMode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))\n\t\t{\n\t\t\t// Prevent the user from downgrading to versions lower than 5.0 by faking mounted volumes.\n\t\t\t// The user could render the system unbootable by downgrading when boot encryption\n\t\t\t// is active or being set up.\n\n\t\t\tmemset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\t\t\t*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_VOLUME_PROPERTIES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tVOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);\n\n\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\tIrp->IoStatus.Information = 0;\n\n\t\t\tif (ListDevice)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t{\n\t\t\t\t\tprop->uniqueId = ListExtension->UniqueVolumeId;\n\t\t\t\t\tRtlStringCbCopyW (prop->wszVolume, sizeof(prop->wszVolume),ListExtension->wszVolume);\n\t\t\t\t\tRtlStringCbCopyW (prop->wszLabel, sizeof(prop->wszLabel),ListExtension->wszLabel);\n\t\t\t\t\tmemcpy (prop->volumeID, ListExtension->volumeID, VOLUME_ID_SIZE);\n\t\t\t\t\tprop->bDriverSetLabel = ListExtension->bDriverSetLabel;\n\t\t\t\t\tprop->diskLength = ListExtension->DiskLength;\n\t\t\t\t\tprop->ea = ListExtension->cryptoInfo->ea;\n\t\t\t\t\tprop->mode = ListExtension->cryptoInfo->mode;\n\t\t\t\t\tprop->pkcs5 = ListExtension->cryptoInfo->pkcs5;\n\t\t\t\t\tprop->pkcs5Iterations = ListExtension->cryptoInfo->noIterations;\n\t\t\t\t\tprop->volumePim = ListExtension->cryptoInfo->volumePim;\n#if 0\n\t\t\t\t\tprop->volumeCreationTime = ListExtension->cryptoInfo->volume_creation_time;\n\t\t\t\t\tprop->headerCreationTime = ListExtension->cryptoInfo->header_creation_time;\n#endif\n\t\t\t\t\tprop->volumeHeaderFlags = ListExtension->cryptoInfo->HeaderFlags;\n\t\t\t\t\tprop->readOnly = ListExtension->bReadOnly;\n\t\t\t\t\tprop->removable = ListExtension->bRemovable;\n\t\t\t\t\tprop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;\n\t\t\t\t\tprop->hiddenVolume = ListExtension->cryptoInfo->hiddenVolume;\n\n\t\t\t\t\tif (ListExtension->cryptoInfo->bProtectHiddenVolume)\n\t\t\t\t\t\tprop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;\n\t\t\t\t\telse\n\t\t\t\t\t\tprop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;\n\n\t\t\t\t\tprop->totalBytesRead = ListExtension->Queue.TotalBytesRead;\n\t\t\t\t\tprop->totalBytesWritten = ListExtension->Queue.TotalBytesWritten;\n\n\t\t\t\t\tprop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;\n\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\tIrp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_RESOLVED_SYMLINK:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tRESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));\n\n\t\t\t\tntStatus = SymbolicLinkToTarget (resolve->symLinkName,\n\t\t\t\t\tresolve->targetName,\n\t\t\t\t\tsizeof (resolve->targetName));\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DRIVE_PARTITION_INFO:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tPARTITION_INFORMATION_EX pi;\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));\n\n\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));\n\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t{\n\t\t\t\t\tmemset (&info->partInfo, 0, sizeof (info->partInfo));\n\n\t\t\t\t\tinfo->partInfo.PartitionLength = pi.PartitionLength;\n\t\t\t\t\tinfo->partInfo.PartitionNumber = pi.PartitionNumber;\n\t\t\t\t\tinfo->partInfo.StartingOffset = pi.StartingOffset;\n\n\t\t\t\t\tif (pi.PartitionStyle == PARTITION_STYLE_MBR)\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo->partInfo.PartitionType = pi.Mbr.PartitionType;\n\t\t\t\t\t\tinfo->partInfo.BootIndicator = pi.Mbr.BootIndicator;\n\t\t\t\t\t}\n\n\t\t\t\t\tinfo->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX\n\t\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));\n\t\t\t\t\tinfo->IsGPT = FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (!NT_SUCCESS (ntStatus))\n\t\t\t\t{\n\t\t\t\t\tGET_LENGTH_INFORMATION lengthInfo;\n\t\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));\n\n\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemset (&info->partInfo, 0, sizeof (info->partInfo));\n\t\t\t\t\t\tinfo->partInfo.PartitionLength = lengthInfo.Length;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinfo->IsDynamic = FALSE;\n\n\t\t\t\tif (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)\n\t\t\t\t{\n#\t\t\t\t\tdefine IOCTL_VOLUME_IS_DYNAMIC CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\t\t\t\t\tif (!NT_SUCCESS (TCDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))\n\t\t\t\t\t\tinfo->IsDynamic = FALSE;\n\t\t\t\t}\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DRIVE_GEOMETRY:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));\n\t\t\t\tDump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);\n\n\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY,\n\t\t\t\t\tNULL, 0, &g->diskGeometry, sizeof (g->diskGeometry));\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase VC_IOCTL_GET_DRIVE_GEOMETRY_EX:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_EX_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_GEOMETRY_EX_STRUCT *g = (DISK_GEOMETRY_EX_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\t\t\t\tPVOID buffer = TCalloc (256); // enough for DISK_GEOMETRY_EX and padded data\n\t\t\t\tif (buffer)\n\t\t\t\t{\n\t\t\t\t\tEnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));\n\t\t\t\t\tDump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY_EX on %ls\\n\", g->deviceName);\n\n\t\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY_EX,\n\t\t\t\t\t\tNULL, 0, buffer, 256);\n\n\t\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t\t{\n\t\t\t\t\t\tPDISK_GEOMETRY_EX pGeo = (PDISK_GEOMETRY_EX) buffer;\n\t\t\t\t\t\tmemcpy (&g->diskGeometry, &pGeo->Geometry, sizeof (DISK_GEOMETRY));\n\t\t\t\t\t\tg->DiskSize.QuadPart = pGeo->DiskSize.QuadPart;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDISK_GEOMETRY dg = {0};\n\t\t\t\t\t\tDump (\"Failed. Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);\n\t\t\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY,\n\t\t\t\t\t\t\tNULL, 0, &dg, sizeof (dg));\n\n\t\t\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemcpy (&g->diskGeometry, &dg, sizeof (DISK_GEOMETRY));\n\t\t\t\t\t\t\tg->DiskSize.QuadPart = dg.Cylinders.QuadPart * dg.SectorsPerTrack * dg.TracksPerCylinder * dg.BytesPerSector;\n\n\t\t\t\t\t\t\tif (OsMajorVersion >= 6)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSTORAGE_READ_CAPACITY storage = {0};\n\t\t\t\t\t\t\t\tNTSTATUS lStatus;\n\t\t\t\t\t\t\t\tstorage.Version = sizeof (STORAGE_READ_CAPACITY);\n\t\t\t\t\t\t\t\tDump (\"Calling IOCTL_STORAGE_READ_CAPACITY on %ls\\n\", g->deviceName);\n\t\t\t\t\t\t\t\tlStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\t\t\t\tIOCTL_STORAGE_READ_CAPACITY,\n\t\t\t\t\t\t\t\t\tNULL, 0, &storage, sizeof (STORAGE_READ_CAPACITY));\n\t\t\t\t\t\t\t\tif (\tNT_SUCCESS(lStatus)\n\t\t\t\t\t\t\t\t\t&& (storage.Size == sizeof (STORAGE_READ_CAPACITY))\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tg->DiskSize.QuadPart = storage.DiskLength.QuadPart;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTCfree (buffer);\n\n\t\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY_EX_STRUCT);\n\t\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_PROBE_REAL_DRIVE_SIZE:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))\n\t\t{\n\t\t\tProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tNTSTATUS status;\n\t\t\tUNICODE_STRING name;\n\t\t\tPFILE_OBJECT fileObject;\n\t\t\tPDEVICE_OBJECT deviceObject;\n\n\t\t\tEnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));\n\n\t\t\tRtlInitUnicodeString (&name, request->DeviceName);\n\t\t\tstatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);\n\t\t\tif (!NT_SUCCESS (status))\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);\n\t\t\tObDereferenceObject (fileObject);\n\n\t\t\tif (status == STATUS_TIMEOUT)\n\t\t\t{\n\t\t\t\trequest->TimeOut = TRUE;\n\t\t\t\tIrp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t}\n\t\t\telse if (!NT_SUCCESS (status))\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trequest->TimeOut = FALSE;\n\t\t\t\tIrp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_MOUNT_VOLUME:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tMOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tif (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD\n\t\t\t\t||\tmount->pkcs5_prf < 0 || mount->pkcs5_prf > LAST_PRF_ID\n\t\t\t\t||\tmount->VolumePim < -1 || mount->VolumePim == INT_MAX\n\t\t\t\t|| mount->ProtectedHidVolPkcs5Prf < 0 || mount->ProtectedHidVolPkcs5Prf > LAST_PRF_ID\n\t\t\t\t|| (mount->bTrueCryptMode != FALSE && mount->bTrueCryptMode != TRUE)\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tEnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));\n\t\t\tEnsureNullTerminatedString (mount->wszLabel, sizeof (mount->wszLabel));\n\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = MountDevice (DeviceObject, mount);\n\n\t\t\tburn (&mount->VolumePassword, sizeof (mount->VolumePassword));\n\t\t\tburn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));\n\t\t\tburn (&mount->pkcs5_prf, sizeof (mount->pkcs5_prf));\n\t\t\tburn (&mount->VolumePim, sizeof (mount->VolumePim));\n\t\t\tburn (&mount->bTrueCryptMode, sizeof (mount->bTrueCryptMode));\n\t\t\tburn (&mount->ProtectedHidVolPkcs5Prf, sizeof (mount->ProtectedHidVolPkcs5Prf));\n\t\t\tburn (&mount->ProtectedHidVolPim, sizeof (mount->ProtectedHidVolPim));\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_DISMOUNT_VOLUME:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tUNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);\n\n\t\t\tunmount->nReturnCode = ERR_DRIVE_NOT_FOUND;\n\n\t\t\tif (ListDevice)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t\tunmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_DISMOUNT_ALL_VOLUMES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tUNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tunmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);\n\n\t\t\tIrp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_BOOT_ENCRYPTION_SETUP:\n\t\tIrp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP:\n\t\tIrp->IoStatus.Status = AbortBootEncryptionSetup();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:\n\t\tGetBootEncryptionStatus (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT:\n\t\tIrp->IoStatus.Information = 0;\n\t\tIrp->IoStatus.Status = GetSetupResult();\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:\n\t\tGetBootDriveVolumeProperties (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_LOADER_VERSION:\n\t\tGetBootLoaderVersion (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER:\n\t\tReopenBootVolumeHeader (Irp, irpSp);\n\t\tbreak;\n\n\tcase VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT:\n\t\tGetBootLoaderFingerprint (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME:\n\t\tGetBootEncryptionAlgorithmName (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_START_DECOY_SYSTEM_WIPE:\n\t\tIrp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE:\n\t\tIrp->IoStatus.Status = AbortDecoySystemWipe();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT:\n\t\tIrp->IoStatus.Status = GetDecoySystemWipeResult();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:\n\t\tGetDecoySystemWipeStatus (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR:\n\t\tIrp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_WARNING_FLAGS:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))\n\t\t{\n\t\t\tGetWarningFlagsRequest *flags = (GetWarningFlagsRequest *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tflags->PagingFileCreationPrevented = PagingFileCreationPrevented;\n\t\t\tPagingFileCreationPrevented = FALSE;\n\t\t\tflags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;\n\t\t\tSystemFavoriteVolumeDirty = FALSE;\n\n\t\t\tIrp->IoStatus.Information = sizeof (GetWarningFlagsRequest);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY:\n\t\tif (UserCanAccessDriveDevice())\n\t\t{\n\t\t\tSystemFavoriteVolumeDirty = TRUE;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\telse\n\t\t\tIrp->IoStatus.Status = STATUS_ACCESS_DENIED;\n\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_REREAD_DRIVER_CONFIG:\n\t\tIrp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG:\n\t\tif (\t(ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))\n\t\t\t&&\t(Irp->RequestorMode == KernelMode)\n\t\t\t)\n\t\t{\n\t\t\tGetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\trequest->BootDriveFilterExtension = GetBootDriveFilterExtension();\n\t\t\tif (IsBootDriveMounted() && request->BootDriveFilterExtension)\n\t\t\t{\n\t\t\t\trequest->HwEncryptionEnabled = IsHwEncryptionEnabled();\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (*request);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);\n\t}\n\n\n#if defined(DEBUG) || defined(DEBUG_TRACE)\n\tif (!NT_SUCCESS (Irp->IoStatus.Status))\n\t{\n\t\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t\t{\n\t\tcase TC_IOCTL_GET_MOUNTED_VOLUMES:\n\t\tcase TC_IOCTL_GET_PASSWORD_CACHE_STATUS:\n\t\tcase TC_IOCTL_GET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_SET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_OPEN_TEST:\n\t\tcase TC_IOCTL_GET_RESOLVED_SYMLINK:\n\t\tcase TC_IOCTL_GET_DRIVE_PARTITION_INFO:\n\t\tcase TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:\n\t\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:\n\t\tcase TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDump (\"IOCTL error 0x%08x\\n\", Irp->IoStatus.Status);\n\t\t}\n\t}\n#endif\n\n\treturn TCCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);\n}",
      "line_statements": [
        [
          1905,
          "\t\t\tsize_t devicePathLen = 0;"
        ],
        [
          1911,
          "\t\t\tif (\t!NT_SUCCESS (RtlUnalignedStringCchLengthW (request->DevicePath, TC_MAX_PATH, &devicePathLen))"
        ],
        [
          1912,
          "\t\t\t\t||\t(devicePathLen < 28) // 28 is the length of \"\\\\Device\\\\Harddisk0\\\\Partition0\" which is the minimum"
        ],
        [
          1913,
          "\t\t\t\t||\t(devicePathLen > 30) // 30 is the length of \"\\\\Device\\\\Harddisk255\\\\Partition0\" which is the maximum"
        ],
        [
          1914,
          "\t\t\t\t||\t(memcmp (request->DevicePath, L\"\\\\Device\\\\Harddisk\", 16 * sizeof (WCHAR)))"
        ],
        [
          1915,
          "\t\t\t\t||\t(memcmp (&request->DevicePath[devicePathLen - 11], L\"\\\\Partition0\", 11 * sizeof (WCHAR)))"
        ],
        [
          1916,
          "\t\t\t\t)"
        ],
        [
          1917,
          "\t\t\t{"
        ],
        [
          1918,
          "\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;"
        ],
        [
          1919,
          "\t\t\t\tIrp->IoStatus.Information = 0;"
        ],
        [
          1920,
          "\t\t\t\tbreak;"
        ],
        [
          1921,
          "\t\t\t}"
        ],
        [
          1922,
          ""
        ],
        [
          1934,
          "\t\t\t\tbyte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);"
        ],
        [
          1935,
          "\t\t\t\tif (!readBuffer)"
        ],
        [
          1937,
          "\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;"
        ],
        [
          1938,
          "\t\t\t\t\tIrp->IoStatus.Information = 0;"
        ],
        [
          1939,
          "\t\t\t\t}"
        ],
        [
          1940,
          "\t\t\t\telse"
        ],
        [
          1941,
          "\t\t\t\t{"
        ],
        [
          1943,
          "\t\t\t\t\toffset.QuadPart = 0;\t// MBR"
        ],
        [
          1945,
          "\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,"
        ],
        [
          1946,
          "\t\t\t\t\t\tNULL,"
        ],
        [
          1947,
          "\t\t\t\t\t\tNULL,"
        ],
        [
          1948,
          "\t\t\t\t\t\tNULL,"
        ],
        [
          1949,
          "\t\t\t\t\t\t&IoStatus,"
        ],
        [
          1950,
          "\t\t\t\t\t\treadBuffer,"
        ],
        [
          1951,
          "\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,"
        ],
        [
          1952,
          "\t\t\t\t\t\t&offset,"
        ],
        [
          1953,
          "\t\t\t\t\t\tNULL);"
        ],
        [
          1955,
          "\t\t\t\t\tif (NT_SUCCESS (ntStatus))"
        ],
        [
          1958,
          "\t\t\t\t\t\tif (IoStatus.Information >= TC_SECTOR_SIZE_BIOS)"
        ],
        [
          1960,
          "\t\t\t\t\t\t\tsize_t i;"
        ],
        [
          1961,
          ""
        ],
        [
          1963,
          "\t\t\t\t\t\t\trequest->DriveIsDynamic = FALSE;"
        ],
        [
          1964,
          ""
        ],
        [
          1965,
          "\t\t\t\t\t\t\tif (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)"
        ],
        [
          1967,
          "\t\t\t\t\t\t\t\tint i;"
        ],
        [
          1968,
          "\t\t\t\t\t\t\t\tfor (i = 0; i < 4; ++i)"
        ],
        [
          1969,
          "\t\t\t\t\t\t\t\t{"
        ],
        [
          1970,
          "\t\t\t\t\t\t\t\t\tif (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)"
        ],
        [
          1971,
          "\t\t\t\t\t\t\t\t\t{"
        ],
        [
          1972,
          "\t\t\t\t\t\t\t\t\t\trequest->DriveIsDynamic = TRUE;"
        ],
        [
          1973,
          "\t\t\t\t\t\t\t\t\t\tbreak;"
        ],
        [
          1974,
          "\t\t\t\t\t\t\t\t\t}"
        ],
        [
          1975,
          "\t\t\t\t\t\t\t\t}"
        ],
        [
          1978,
          "\t\t\t\t\t\t\trequest->BootLoaderVersion = 0;"
        ],
        [
          1979,
          "\t\t\t\t\t\t\trequest->Configuration = 0;"
        ],
        [
          1980,
          "\t\t\t\t\t\t\trequest->UserConfiguration = 0;"
        ],
        [
          1981,
          "\t\t\t\t\t\t\trequest->CustomUserMessage[0] = 0;"
        ],
        [
          1984,
          "\t\t\t\t\t\t\tfor (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)"
        ],
        [
          1986,
          "\t\t\t\t\t\t\t\tif (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)"
        ],
        [
          1987,
          "\t\t\t\t\t\t\t\t{"
        ],
        [
          1988,
          "\t\t\t\t\t\t\t\t\trequest->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));"
        ],
        [
          1989,
          "\t\t\t\t\t\t\t\t\trequest->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];"
        ],
        [
          1990,
          ""
        ],
        [
          1991,
          "\t\t\t\t\t\t\t\t\tif (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)"
        ],
        [
          1992,
          "\t\t\t\t\t\t\t\t\t{"
        ],
        [
          1993,
          "\t\t\t\t\t\t\t\t\t\trequest->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];"
        ],
        [
          1994,
          "\t\t\t\t\t\t\t\t\t\tmemcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);"
        ],
        [
          1995,
          "\t\t\t\t\t\t\t\t\t}"
        ],
        [
          1996,
          "\t\t\t\t\t\t\t\t\tbreak;"
        ],
        [
          1997,
          "\t\t\t\t\t\t\t\t}"
        ],
        [
          1999,
          ""
        ],
        [
          2000,
          "\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;"
        ],
        [
          2001,
          "\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (*request);"
        ],
        [
          2002,
          "\t\t\t\t\t\t}"
        ],
        [
          2003,
          "\t\t\t\t\t\telse"
        ],
        [
          2004,
          "\t\t\t\t\t\t{"
        ],
        [
          2005,
          "\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;"
        ],
        [
          2006,
          "\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;"
        ],
        [
          2009,
          "\t\t\t\t\telse"
        ],
        [
          2010,
          "\t\t\t\t\t{"
        ],
        [
          2011,
          "\t\t\t\t\t\tIrp->IoStatus.Status = ntStatus;"
        ],
        [
          2012,
          "\t\t\t\t\t\tIrp->IoStatus.Information = 0;"
        ],
        [
          2013,
          "\t\t\t\t\t}"
        ],
        [
          2015,
          "\t\t\t\t\tTCfree (readBuffer);"
        ]
      ],
      "statements": [
        [
          1905,
          "size_t devicePathLen = 0;"
        ],
        [
          1911,
          "if (\t!NT_SUCCESS (RtlUnalignedStringCchLengthW (request->DevicePath, TC_MAX_PATH, &devicePathLen))\n\t\t\t\t||\t(devicePathLen < 28) // 28 is the length of \"\\\\Device\\\\Harddisk0\\\\Partition0\" which is the minimum\n\t\t\t\t||\t(devicePathLen > 30) // 30 is the length of \"\\\\Device\\\\Harddisk255\\\\Partition0\" which is the maximum\n\t\t\t\t||\t(memcmp (request->DevicePath, L\"\\\\Device\\\\Harddisk\", 16 * sizeof (WCHAR)))\n\t\t\t\t||\t(memcmp (&request->DevicePath[devicePathLen - 11], L\"\\\\Partition0\", 11 * sizeof (WCHAR)))\n\t\t\t\t)"
        ],
        [
          1917,
          "\t\t\t{\n"
        ],
        [
          1918,
          "Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;"
        ],
        [
          1919,
          "Irp->IoStatus.Information = 0;"
        ],
        [
          1920,
          "break;"
        ],
        [
          1921,
          "\t\t\t}\n"
        ],
        [
          1922,
          "\n"
        ],
        [
          1934,
          "byte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);"
        ],
        [
          1935,
          "if (!readBuffer)"
        ],
        [
          1937,
          "Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;"
        ],
        [
          1938,
          "Irp->IoStatus.Information = 0;"
        ],
        [
          1939,
          "\t\t\t\t}\n"
        ],
        [
          1940,
          "else"
        ],
        [
          1941,
          "\t\t\t\t{\n"
        ],
        [
          1943,
          "\t\t\t\t\toffset.QuadPart = 0;\t// MBR\n"
        ],
        [
          1945,
          "ntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t&offset,\n\t\t\t\t\t\tNULL);"
        ],
        [
          1955,
          "if (NT_SUCCESS (ntStatus))"
        ],
        [
          1958,
          "if (IoStatus.Information >= TC_SECTOR_SIZE_BIOS)"
        ],
        [
          1960,
          "size_t i;"
        ],
        [
          1961,
          "\n"
        ],
        [
          1963,
          "request->DriveIsDynamic = FALSE;"
        ],
        [
          1964,
          "\n"
        ],
        [
          1965,
          "if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)"
        ],
        [
          1967,
          "int i;"
        ],
        [
          1968,
          "for (i = 0; i < 4; ++i)"
        ],
        [
          1969,
          "\t\t\t\t\t\t\t\t{\n"
        ],
        [
          1970,
          "if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)"
        ],
        [
          1971,
          "\t\t\t\t\t\t\t\t\t{\n"
        ],
        [
          1972,
          "request->DriveIsDynamic = TRUE;"
        ],
        [
          1973,
          "break;"
        ],
        [
          1974,
          "\t\t\t\t\t\t\t\t\t}\n"
        ],
        [
          1975,
          "\t\t\t\t\t\t\t\t}\n"
        ],
        [
          1978,
          "request->BootLoaderVersion = 0;"
        ],
        [
          1979,
          "request->Configuration = 0;"
        ],
        [
          1980,
          "request->UserConfiguration = 0;"
        ],
        [
          1981,
          "request->CustomUserMessage[0] = 0;"
        ],
        [
          1984,
          "for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)"
        ],
        [
          1986,
          "if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)"
        ],
        [
          1987,
          "\t\t\t\t\t\t\t\t{\n"
        ],
        [
          1988,
          "request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));"
        ],
        [
          1989,
          "request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];"
        ],
        [
          1990,
          "\n"
        ],
        [
          1991,
          "if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)"
        ],
        [
          1992,
          "\t\t\t\t\t\t\t\t\t{\n"
        ],
        [
          1993,
          "request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];"
        ],
        [
          1994,
          "memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);"
        ],
        [
          1995,
          "\t\t\t\t\t\t\t\t\t}\n"
        ],
        [
          1996,
          "break;"
        ],
        [
          1997,
          "\t\t\t\t\t\t\t\t}\n"
        ],
        [
          1999,
          "\n"
        ],
        [
          2000,
          "Irp->IoStatus.Status = STATUS_SUCCESS;"
        ],
        [
          2001,
          "Irp->IoStatus.Information = sizeof (*request);"
        ],
        [
          2002,
          "\t\t\t\t\t\t}\n"
        ],
        [
          2003,
          "else"
        ],
        [
          2004,
          "\t\t\t\t\t\t{\n"
        ],
        [
          2005,
          "Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;"
        ],
        [
          2006,
          "Irp->IoStatus.Information = 0;"
        ],
        [
          2009,
          "else"
        ],
        [
          2010,
          "\t\t\t\t\t{\n"
        ],
        [
          2011,
          "Irp->IoStatus.Status = ntStatus;"
        ],
        [
          2012,
          "Irp->IoStatus.Information = 0;"
        ],
        [
          2013,
          "\t\t\t\t\t}\n"
        ],
        [
          2015,
          "TCfree (readBuffer);"
        ]
      ],
      "cve": "CVE-2019-1010208"
    },
    {
      "commit_id": "468f6eafa6c44cb2c5d8aad35e12f06c240a812a",
      "filepath": "kernel/bpf/verifier.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "adjust_scalar_min_max_vals",
      "func_body": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->32 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}\n",
      "line_statements": [
        [
          2034,
          "\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n"
        ],
        [
          2171,
          "\t\tif (umax_val >= insn_bitness) {\n"
        ],
        [
          2172,
          "\t\t\t/* Shifts greater than 31 or 63 are undefined.\n"
        ],
        [
          2173,
          "\t\t\t * This includes shifts by a negative number.\n"
        ],
        [
          2199,
          "\t\tif (umax_val >= insn_bitness) {\n"
        ],
        [
          2200,
          "\t\t\t/* Shifts greater than 31 or 63 are undefined.\n"
        ],
        [
          2201,
          "\t\t\t * This includes shifts by a negative number.\n"
        ],
        [
          2237,
          "\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n"
        ],
        [
          2238,
          "\t\t/* 32-bit ALU ops are (32,32)->32 */\n"
        ],
        [
          2239,
          "\t\tcoerce_reg_to_size(dst_reg, 4);\n"
        ],
        [
          2240,
          "\t\tcoerce_reg_to_size(&src_reg, 4);\n"
        ],
        [
          2241,
          "\t}\n"
        ],
        [
          2242,
          "\n"
        ]
      ],
      "statements": [
        [
          2034,
          "u64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;"
        ],
        [
          2171,
          "if (umax_val >= insn_bitness)"
        ],
        [
          2172,
          "/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */"
        ],
        [
          2199,
          "if (umax_val >= insn_bitness)"
        ],
        [
          2200,
          "/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */"
        ],
        [
          2237,
          "if (BPF_CLASS(insn->code) != BPF_ALU64)"
        ],
        [
          2238,
          "/* 32-bit ALU ops are (32,32)->32 */"
        ],
        [
          2239,
          "coerce_reg_to_size(dst_reg, 4);"
        ],
        [
          2240,
          "coerce_reg_to_size(&src_reg, 4);"
        ],
        [
          2241,
          "\t}\n"
        ],
        [
          2242,
          "\n"
        ]
      ],
      "cve": "CVE-2017-17852"
    },
    {
      "commit_id": "a70934eea95c76a7737b83773bffe8738935082d",
      "filepath": "lib/ofx_preproc.cpp",
      "project": "libofx",
      "project_repo_path": "symbol_backend_projects/libofx",
      "is_vulnerable": true,
      "func_name": "sanitize_proprietary_tags",
      "func_body": "string sanitize_proprietary_tags(string input_string)\n{\n  unsigned int i;\n  size_t input_string_size;\n  bool strip = false;\n  bool tag_open = false;\n  int tag_open_idx = 0; //Are we within < > ?\n  bool closing_tag_open = false; //Are we within </ > ?\n  int orig_tag_open_idx = 0;\n  bool proprietary_tag = false; //Are we within a proprietary element?\n  bool proprietary_closing_tag = false;\n  int crop_end_idx = 0;\n  char buffer[READ_BUFFER_SIZE] = \"\";\n  char tagname[READ_BUFFER_SIZE] = \"\";\n  int tagname_idx = 0;\n  char close_tagname[READ_BUFFER_SIZE] = \"\";\n\n  for (i = 0; i < READ_BUFFER_SIZE; i++)\n  {\n    buffer[i] = 0;\n    tagname[i] = 0;\n    close_tagname[i] = 0;\n  }\n\n  input_string_size = input_string.size();\n\n  for (i = 0; i < input_string_size; i++)\n  {\n    if (input_string.c_str()[i] == '<')\n    {\n      tag_open = true;\n      tag_open_idx = i;\n      if (proprietary_tag == true && input_string.c_str()[i+1] == '/')\n      {\n        //We are now in a closing tag\n        closing_tag_open = true;\n        //cout<<\"Comparaison: \"<<tagname<<\"|\"<<&(input_string.c_str()[i+2])<<\"|\"<<strlen(tagname)<<endl;\n        if (strncmp(tagname, &(input_string.c_str()[i+2]), strlen(tagname)) != 0)\n        {\n          //If it is the begining of an other tag\n          //cout<<\"DIFFERENT!\"<<endl;\n          crop_end_idx = i - 1;\n          strip = true;\n        }\n        else\n        {\n          //Otherwise, it is the start of the closing tag of the proprietary tag\n          proprietary_closing_tag = true;\n        }\n      }\n      else if (proprietary_tag == true)\n      {\n        //It is the start of a new tag, following a proprietary tag\n        crop_end_idx = i - 1;\n        strip = true;\n      }\n    }\n    else if (input_string.c_str()[i] == '>')\n    {\n      tag_open = false;\n      closing_tag_open = false;\n      tagname[tagname_idx] = 0;\n      tagname_idx = 0;\n      if (proprietary_closing_tag == true)\n      {\n        crop_end_idx = i;\n        strip = true;\n      }\n    }\n    else if (tag_open == true && closing_tag_open == false)\n    {\n      if (input_string.c_str()[i] == '.')\n      {\n        if (proprietary_tag != true)\n        {\n          orig_tag_open_idx = tag_open_idx;\n          proprietary_tag = true;\n        }\n      }\n      tagname[tagname_idx] = input_string.c_str()[i];\n      tagname_idx++;\n    }\n    //cerr <<i<<endl;\n    if (strip == true && orig_tag_open_idx < input_string.size())\n    {\n      input_string.copy(buffer, (crop_end_idx - orig_tag_open_idx) + 1, orig_tag_open_idx);\n      message_out(INFO, \"sanitize_proprietary_tags() (end tag or new tag) removed: \" + string(buffer));\n      input_string.erase(orig_tag_open_idx, (crop_end_idx - orig_tag_open_idx) + 1);\n      i = orig_tag_open_idx - 1;\n      proprietary_tag = false;\n      proprietary_closing_tag = false;\n      closing_tag_open = false;\n      tag_open = false;\n      strip = false;\n\n      input_string_size = input_string.size();\n    }\n\n  }//end for\n  if (proprietary_tag == true && orig_tag_open_idx < input_string.size())\n  {\n    if (crop_end_idx == 0)   //no closing tag\n    {\n      crop_end_idx = input_string.size() - 1;\n    }\n    input_string.copy(buffer, (crop_end_idx - orig_tag_open_idx) + 1, orig_tag_open_idx);\n    message_out(INFO, \"sanitize_proprietary_tags() (end of line) removed: \" + string(buffer));\n    input_string.erase(orig_tag_open_idx, (crop_end_idx - orig_tag_open_idx) + 1);\n    input_string_size = input_string.size();\n  }\n  return input_string;\n}",
      "line_statements": [
        [
          420,
          "  size_t input_string_size;"
        ],
        [
          441,
          "  input_string_size = input_string.size();"
        ],
        [
          442,
          ""
        ],
        [
          443,
          "  for (i = 0; i < input_string_size; i++)"
        ]
      ],
      "statements": [
        [
          420,
          "size_t input_string_size;"
        ],
        [
          441,
          "input_string_size = input_string.size();"
        ],
        [
          442,
          "\n"
        ],
        [
          443,
          "for (i = 0; i < input_string_size; i++)"
        ]
      ],
      "cve": "CVE-2017-2920"
    },
    {
      "commit_id": "4dc1a2d7931017d3625f2d7cff70a17ce58b53b4",
      "filepath": "src/gd_xbm.c",
      "project": "libgd",
      "project_repo_path": "symbol_backend_projects/libgd",
      "is_vulnerable": true,
      "func_name": "gdImageXbmCtx",
      "func_body": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\t/* only in C-locale isalnum() would work */\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\tgdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));\n\tgdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));\n\tgdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);\n\n\tfree(name);\n\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPrintf(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPrintf(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"};\\n\");\n}",
      "line_statements": [
        [
          218,
          "\tgdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));"
        ],
        [
          219,
          "\tgdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));"
        ],
        [
          220,
          "\tgdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);"
        ],
        [
          237,
          "\t\t\t\t\tgdCtxPrintf(out, \", \");"
        ],
        [
          239,
          "\t\t\t\t\t\tgdCtxPrintf(out, \"\\n  \");"
        ],
        [
          251,
          "\tgdCtxPrintf(out, \"};\\n\");"
        ]
      ],
      "statements": [
        [
          218,
          "gdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));"
        ],
        [
          219,
          "gdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));"
        ],
        [
          220,
          "gdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);"
        ],
        [
          237,
          "gdCtxPrintf(out, \", \");"
        ],
        [
          239,
          "gdCtxPrintf(out, \"\\n  \");"
        ],
        [
          251,
          "gdCtxPrintf(out, \"};\\n\");"
        ]
      ],
      "cve": "CVE-2016-5116"
    },
    {
      "commit_id": "d689d14dbcd768c028eab2fb378d849e543dcfe9",
      "filepath": "src/tcpcapinfo.c",
      "project": "tcpreplay",
      "project_repo_path": "symbol_backend_projects/tcpreplay",
      "is_vulnerable": true,
      "func_name": "main",
      "func_body": "main(int argc, char *argv[])\n{\n    int i, fd, swapped, pkthdrlen, ret, optct, backwards, caplentoobig;\n    struct pcap_file_header pcap_fh;\n    struct pcap_pkthdr pcap_ph;\n    struct pcap_sf_patched_pkthdr pcap_patched_ph; /* Kuznetzov */\n    char buf[10000];\n    struct stat statinfo;\n    uint64_t pktcnt;\n    uint32_t readword;\n    int32_t last_sec, last_usec, caplen;\n\n    optct = optionProcess(&tcpcapinfoOptions, argc, argv);\n    argc -= optct;\n    argv += optct;\n\n#ifdef DEBUG\n    if (HAVE_OPT(DBUG))\n        debug = OPT_VALUE_DBUG;\n#endif\n\n    for (i = 0; i < argc; i++) {\n        dbgx(1, \"processing:  %s\\n\", argv[i]);\n        if ((fd = open(argv[i], O_RDONLY)) < 0)\n            errx(-1, \"Error opening file %s: %s\", argv[i], strerror(errno));\n\n        if (fstat(fd, &statinfo) < 0)\n            errx(-1, \"Error getting file stat info %s: %s\", argv[i], strerror(errno));\n\n        printf(\"file size   = %\"PRIu64\" bytes\\n\", (uint64_t)statinfo.st_size);\n\n        if ((ret = read(fd, &buf, sizeof(pcap_fh))) != sizeof(pcap_fh))\n            errx(-1, \"File too small.  Unable to read pcap_file_header from %s\", argv[i]);\n\n        dbgx(3, \"Read %d bytes for file header\", ret);\n\n        swapped = 0;\n\n        memcpy(&pcap_fh, &buf, sizeof(pcap_fh));\n\n        pkthdrlen = 16; /* pcap_pkthdr isn't the actual on-disk format for 64bit systems! */\n\n        switch (pcap_fh.magic) {\n            case TCPDUMP_MAGIC:\n            printf(\"magic       = 0x%08\"PRIx32\" (tcpdump) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n\n            case SWAPLONG(TCPDUMP_MAGIC):\n            printf(\"magic       = 0x%08\"PRIx32\" (tcpdump/swapped) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n\n            case KUZNETZOV_TCPDUMP_MAGIC:\n            pkthdrlen = sizeof(pcap_patched_ph);\n            printf(\"magic       = 0x%08\"PRIx32\" (Kuznetzov) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n\n            case SWAPLONG(KUZNETZOV_TCPDUMP_MAGIC):\n            pkthdrlen = sizeof(pcap_patched_ph);\n            printf(\"magic       = 0x%08\"PRIx32\" (Kuznetzov/swapped) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n\n            case FMESQUITA_TCPDUMP_MAGIC:\n            printf(\"magic       = 0x%08\"PRIx32\" (Fmesquita) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n\n            case SWAPLONG(FMESQUITA_TCPDUMP_MAGIC):\n            printf(\"magic       = 0x%08\"PRIx32\" (Fmesquita) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n\n            case NAVTEL_TCPDUMP_MAGIC:\n            printf(\"magic       = 0x%08\"PRIx32\" (Navtel) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n\n            case SWAPLONG(NAVTEL_TCPDUMP_MAGIC):\n            printf(\"magic       = 0x%08\"PRIx32\" (Navtel/swapped) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n\n            case NSEC_TCPDUMP_MAGIC:\n            printf(\"magic       = 0x%08\"PRIx32\" (Nsec) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n\n            case SWAPLONG(NSEC_TCPDUMP_MAGIC):\n            printf(\"magic       = 0x%08\"PRIx32\" (Nsec/swapped) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n\n            default:\n            printf(\"magic       = 0x%08\"PRIx32\" (unknown)\\n\", pcap_fh.magic);\n        }\n\n        if (swapped == 1) {\n            pcap_fh.version_major = SWAPSHORT(pcap_fh.version_major);\n            pcap_fh.version_minor = SWAPSHORT(pcap_fh.version_minor);\n            pcap_fh.thiszone = SWAPLONG(pcap_fh.thiszone);\n            pcap_fh.sigfigs = SWAPLONG(pcap_fh.sigfigs);\n            pcap_fh.snaplen = SWAPLONG(pcap_fh.snaplen);\n            pcap_fh.linktype = SWAPLONG(pcap_fh.linktype);\n        }\n\n        printf(\"version     = %hu.%hu\\n\", pcap_fh.version_major, pcap_fh.version_minor);\n        printf(\"thiszone    = 0x%08\"PRIx32\"\\n\", pcap_fh.thiszone);\n        printf(\"sigfigs     = 0x%08\"PRIx32\"\\n\", pcap_fh.sigfigs);\n        printf(\"snaplen     = %\"PRIu32\"\\n\", pcap_fh.snaplen);\n        printf(\"linktype    = 0x%08\"PRIx32\"\\n\", pcap_fh.linktype);\n\n        if (pcap_fh.version_major != 2 && pcap_fh.version_minor != 4) {\n            printf(\"Sorry, we only support file format version 2.4\\n\");\n            close(fd);\n            continue;\n        }\n\n        dbgx(5, \"Packet header len: %d\", pkthdrlen);\n\n        if (pkthdrlen == 24) {\n            printf(\"Packet\\tOrigLen\\t\\tCaplen\\t\\tTimestamp\\t\\tIndex\\tProto\\tPktType\\tPktCsum\\tNote\\n\");\n        } else {\n            printf(\"Packet\\tOrigLen\\t\\tCaplen\\t\\tTimestamp\\tCsum\\tNote\\n\");\n        }\n\n        pktcnt = 0;\n        last_sec = 0;\n        last_usec = 0;\n        while ((ret = read(fd, &buf, pkthdrlen)) == pkthdrlen) {\n            pktcnt ++;\n            backwards = 0;\n            caplentoobig = 0;\n            dbgx(3, \"Read %d bytes for packet %\"PRIu64\" header\", ret, pktcnt);\n\n            memset(&pcap_ph, 0, sizeof(pcap_ph));\n\n            /* see what packet header we're using */\n            if (pkthdrlen == sizeof(pcap_patched_ph)) {\n                memcpy(&pcap_patched_ph, &buf, sizeof(pcap_patched_ph));\n\n                if (swapped == 1) {\n                    dbg(3, \"Swapping packet header bytes...\");\n                    pcap_patched_ph.caplen = SWAPLONG(pcap_patched_ph.caplen);\n                    pcap_patched_ph.len = SWAPLONG(pcap_patched_ph.len);\n                    pcap_patched_ph.ts.tv_sec = SWAPLONG(pcap_patched_ph.ts.tv_sec);\n                    pcap_patched_ph.ts.tv_usec = SWAPLONG(pcap_patched_ph.ts.tv_usec);\n                    pcap_patched_ph.index = SWAPLONG(pcap_patched_ph.index);\n                    pcap_patched_ph.protocol = SWAPSHORT(pcap_patched_ph.protocol);\n                }\n                printf(\"%\"PRIu64\"\\t%4\"PRIu32\"\\t\\t%4\"PRIu32\"\\t\\t%\"\n                        PRIx32\".%\"PRIx32\"\\t\\t%4\"PRIu32\"\\t%4hu\\t%4hhu\", \n                        pktcnt, pcap_patched_ph.len, pcap_patched_ph.caplen, \n                        pcap_patched_ph.ts.tv_sec, pcap_patched_ph.ts.tv_usec,\n                        pcap_patched_ph.index, pcap_patched_ph.protocol, pcap_patched_ph.pkt_type);\n\n                if (pcap_fh.snaplen < pcap_patched_ph.caplen) {\n                    caplentoobig = 1;\n                }\n\n                caplen = pcap_patched_ph.caplen;\n\n            } else {\n                /* manually map on-disk bytes to our memory structure */\n                memcpy(&readword, buf, 4);\n                pcap_ph.ts.tv_sec = readword;\n                memcpy(&readword, &buf[4], 4);\n                pcap_ph.ts.tv_usec = readword;\n                memcpy(&pcap_ph.caplen, &buf[8], 4);\n                memcpy(&pcap_ph.len, &buf[12], 4);\n\n                if (swapped == 1) {\n                    dbg(3, \"Swapping packet header bytes...\");\n                    pcap_ph.caplen = SWAPLONG(pcap_ph.caplen);\n                    pcap_ph.len = SWAPLONG(pcap_ph.len);\n                    pcap_ph.ts.tv_sec = SWAPLONG(pcap_ph.ts.tv_sec);\n                    pcap_ph.ts.tv_usec = SWAPLONG(pcap_ph.ts.tv_usec);\n                }\n                printf(\"%\"PRIu64\"\\t%4\"PRIu32\"\\t\\t%4\"PRIu32\"\\t\\t%\"\n                        PRIx32\".%\"PRIx32,\n                        pktcnt, pcap_ph.len, pcap_ph.caplen, \n                        (unsigned int)pcap_ph.ts.tv_sec, (unsigned int)pcap_ph.ts.tv_usec);\n                if (pcap_fh.snaplen < pcap_ph.caplen) {\n                    caplentoobig = 1;\n                }\n                caplen = pcap_ph.caplen;\n            }\n\n            /* check to make sure timestamps don't go backwards */\n            if (last_sec > 0 && last_usec > 0) {\n                if ((pcap_ph.ts.tv_sec == last_sec) ? \n                        (pcap_ph.ts.tv_usec < last_usec) : \n                        (pcap_ph.ts.tv_sec < last_sec)) {\n                    backwards = 1;\n                }\n            }\n            if (pkthdrlen == sizeof(pcap_patched_ph)) {\n                last_sec = pcap_patched_ph.ts.tv_sec;\n                last_usec = pcap_patched_ph.ts.tv_usec;\n            } else {\n                last_sec = pcap_ph.ts.tv_sec;\n                last_usec = pcap_ph.ts.tv_usec;\n            }\n\n            /* read the frame */\n            if ((ret = read(fd, &buf, caplen)) != caplen) {\n                if (ret < 0) {\n                    printf(\"Error reading file: %s: %s\\n\", argv[i], strerror(errno));\n                } else {\n                    printf(\"File truncated!  Unable to jump to next packet.\\n\");\n                }\n\n                close(fd);\n                continue;\n            }\n\n            /* print the frame checksum */\n            printf(\"\\t%x\\t\", do_checksum_math((u_int16_t *)buf, caplen));\n\n            /* print the Note */\n            if (! backwards && ! caplentoobig) {\n                printf(\"OK\\n\");\n            } else if (backwards && ! caplentoobig) {\n                printf(\"BAD_TS\\n\");\n            } else if (caplentoobig && ! backwards) {\n                printf(\"TOOBIG\\n\");\n            } else if (backwards && caplentoobig) {\n                printf(\"BAD_TS|TOOBIG\");\n            } \n\n        }\n\n    }\n\n    exit(0);\n\n}",
      "line_statements": [
        [
          309,
          "                continue;"
        ]
      ],
      "statements": [
        [
          309,
          "continue;"
        ]
      ],
      "cve": "CVE-2017-6429"
    },
    {
      "commit_id": "7bc2b55a5c030685b399bb65b6baa9ccc3d1f167",
      "filepath": "drivers/scsi/arcmsr/arcmsr_hba.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "arcmsr_iop_message_xfer",
      "func_body": "static int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\n\t\tstruct scsi_cmnd *cmd)\n{\n\tchar *buffer;\n\tunsigned short use_sg;\n\tint retvalue = 0, transfer_len = 0;\n\tunsigned long flags;\n\tstruct CMD_MESSAGE_FIELD *pcmdmessagefld;\n\tuint32_t controlcode = (uint32_t)cmd->cmnd[5] << 24 |\n\t\t(uint32_t)cmd->cmnd[6] << 16 |\n\t\t(uint32_t)cmd->cmnd[7] << 8 |\n\t\t(uint32_t)cmd->cmnd[8];\n\tstruct scatterlist *sg;\n\n\tuse_sg = scsi_sg_count(cmd);\n\tsg = scsi_sglist(cmd);\n\tbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\n\tif (use_sg > 1) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tgoto message_out;\n\t}\n\ttransfer_len += sg->length;\n\tif (transfer_len > sizeof(struct CMD_MESSAGE_FIELD)) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: ARCMSR_MESSAGE_FAIL!\\n\", __func__);\n\t\tgoto message_out;\n\t}\n\tpcmdmessagefld = (struct CMD_MESSAGE_FIELD *)buffer;\n\tswitch (controlcode) {\n\tcase ARCMSR_MESSAGE_READ_RQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint8_t *ptmpQbuffer;\n\t\tuint32_t allxfer_len = 0;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tpr_info(\"%s: memory not enough!\\n\", __func__);\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpQbuffer = ver_addr;\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tif (acb->rqbuf_getIndex != acb->rqbuf_putIndex) {\n\t\t\tunsigned int tail = acb->rqbuf_getIndex;\n\t\t\tunsigned int head = acb->rqbuf_putIndex;\n\t\t\tunsigned int cnt_to_end = CIRC_CNT_TO_END(head, tail, ARCMSR_MAX_QBUFFER);\n\n\t\t\tallxfer_len = CIRC_CNT(head, tail, ARCMSR_MAX_QBUFFER);\n\t\t\tif (allxfer_len > ARCMSR_API_DATA_BUFLEN)\n\t\t\t\tallxfer_len = ARCMSR_API_DATA_BUFLEN;\n\n\t\t\tif (allxfer_len <= cnt_to_end)\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, allxfer_len);\n\t\t\telse {\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, cnt_to_end);\n\t\t\t\tmemcpy(ptmpQbuffer + cnt_to_end, acb->rqbuffer, allxfer_len - cnt_to_end);\n\t\t\t}\n\t\t\tacb->rqbuf_getIndex = (acb->rqbuf_getIndex + allxfer_len) % ARCMSR_MAX_QBUFFER;\n\t\t}\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer, ver_addr,\n\t\t\tallxfer_len);\n\t\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\t\tstruct QBUFFER __iomem *prbuffer;\n\t\t\tacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\n\t\t\tprbuffer = arcmsr_get_iop_rqbuffer(acb);\n\t\t\tif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\n\t\t\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tpcmdmessagefld->cmdmessage.Length = allxfer_len;\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_WRITE_WQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint32_t user_len;\n\t\tint32_t cnt2end;\n\t\tuint8_t *pQbuffer, *ptmpuserbuffer;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpuserbuffer = ver_addr;\n\t\tuser_len = pcmdmessagefld->cmdmessage.Length;\n\t\tif (user_len > ARCMSR_API_DATA_BUFLEN) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tkfree(ver_addr);\n\t\t\tgoto message_out;\n\t\t}\n\t\tmemcpy(ptmpuserbuffer,\n\t\t\tpcmdmessagefld->messagedatabuffer, user_len);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tif (acb->wqbuf_putIndex != acb->wqbuf_getIndex) {\n\t\t\tstruct SENSE_DATA *sensebuffer =\n\t\t\t\t(struct SENSE_DATA *)cmd->sense_buffer;\n\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t/* has error report sensedata */\n\t\t\tsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\n\t\t\tsensebuffer->SenseKey = ILLEGAL_REQUEST;\n\t\t\tsensebuffer->AdditionalSenseLength = 0x0A;\n\t\t\tsensebuffer->AdditionalSenseCode = 0x20;\n\t\t\tsensebuffer->Valid = 1;\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t} else {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_putIndex];\n\t\t\tcnt2end = ARCMSR_MAX_QBUFFER - acb->wqbuf_putIndex;\n\t\t\tif (user_len > cnt2end) {\n\t\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, cnt2end);\n\t\t\t\tptmpuserbuffer += cnt2end;\n\t\t\t\tuser_len -= cnt2end;\n\t\t\t\tacb->wqbuf_putIndex = 0;\n\t\t\t\tpQbuffer = acb->wqbuffer;\n\t\t\t}\n\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, user_len);\n\t\t\tacb->wqbuf_putIndex += user_len;\n\t\t\tacb->wqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_CLEARED) {\n\t\t\t\tacb->acb_flags &=\n\t\t\t\t\t\t~ACB_F_MESSAGE_WQBUFFER_CLEARED;\n\t\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_RQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->rqbuffer;\n\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_WQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->wqbuffer;\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_ALLQBUFFER: {\n\t\tuint8_t *pQbuffer;\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tpQbuffer = acb->rqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tpQbuffer = acb->wqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_RETURN_CODE_3F: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_3F;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_HELLO: {\n\t\tint8_t *hello_string = \"Hello! I am ARCMSR\";\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer,\n\t\t\thello_string, (int16_t)strlen(hello_string));\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_GOODBYE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_iop_parking(acb);\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_flush_adapter_cache(acb);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: unknown controlcode!\\n\", __func__);\n\t}\nmessage_out:\n\tif (use_sg) {\n\t\tstruct scatterlist *sg = scsi_sglist(cmd);\n\t\tkunmap_atomic(buffer - sg->offset);\n\t}\n\treturn retvalue;\n}\n",
      "line_statements": [
        [
          2391,
          "\t\tuint32_t user_len;\n"
        ],
        [
          2392,
          "\t\tint32_t cnt2end;\n"
        ],
        [
          2401,
          "\t\tif (user_len > ARCMSR_API_DATA_BUFLEN) {\n"
        ],
        [
          2402,
          "\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n"
        ],
        [
          2403,
          "\t\t\tkfree(ver_addr);\n"
        ],
        [
          2404,
          "\t\t\tgoto message_out;\n"
        ],
        [
          2405,
          "\t\t}\n"
        ]
      ],
      "statements": [
        [
          2391,
          "uint32_t user_len;"
        ],
        [
          2392,
          "int32_t cnt2end;"
        ],
        [
          2401,
          "if (user_len > ARCMSR_API_DATA_BUFLEN)"
        ],
        [
          2402,
          "retvalue = ARCMSR_MESSAGE_FAIL;"
        ],
        [
          2403,
          "kfree(ver_addr);"
        ],
        [
          2404,
          "goto message_out;"
        ],
        [
          2405,
          "\t\t}\n"
        ]
      ],
      "cve": "CVE-2016-7425"
    },
    {
      "commit_id": "7f7ccc2ccc2e70c6054685f5e3522efa81556830",
      "filepath": "fs/proc/base.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "proc_pid_cmdline_read",
      "func_body": "static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,\n\t\t\t\t     size_t _count, loff_t *pos)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tchar *page;\n\tunsigned long count = _count;\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\tunsigned long len1, len2, len;\n\tunsigned long p;\n\tchar c;\n\tssize_t rv;\n\n\tBUG_ON(*pos < 0);\n\n\ttsk = get_proc_task(file_inode(file));\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tmm = get_task_mm(tsk);\n\tput_task_struct(tsk);\n\tif (!mm)\n\t\treturn 0;\n\t/* Check if process spawned far enough to have cmdline. */\n\tif (!mm->env_end) {\n\t\trv = 0;\n\t\tgoto out_mmput;\n\t}\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page) {\n\t\trv = -ENOMEM;\n\t\tgoto out_mmput;\n\t}\n\n\tdown_read(&mm->mmap_sem);\n\targ_start = mm->arg_start;\n\targ_end = mm->arg_end;\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\tBUG_ON(arg_start > arg_end);\n\tBUG_ON(env_start > env_end);\n\n\tlen1 = arg_end - arg_start;\n\tlen2 = env_end - env_start;\n\n\t/* Empty ARGV. */\n\tif (len1 == 0) {\n\t\trv = 0;\n\t\tgoto out_free_page;\n\t}\n\t/*\n\t * Inherently racy -- command line shares address space\n\t * with code and data.\n\t */\n\trv = access_remote_vm(mm, arg_end - 1, &c, 1, 0);\n\tif (rv <= 0)\n\t\tgoto out_free_page;\n\n\trv = 0;\n\n\tif (c == '\\0') {\n\t\t/* Command line (set of strings) occupies whole ARGV. */\n\t\tif (len1 <= *pos)\n\t\t\tgoto out_free_page;\n\n\t\tp = arg_start + *pos;\n\t\tlen = len1 - *pos;\n\t\twhile (count > 0 && len > 0) {\n\t\t\tunsigned int _count;\n\t\t\tint nr_read;\n\n\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n\t\t\tif (nr_read < 0)\n\t\t\t\trv = nr_read;\n\t\t\tif (nr_read <= 0)\n\t\t\t\tgoto out_free_page;\n\n\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\trv = -EFAULT;\n\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\tp\t+= nr_read;\n\t\t\tlen\t-= nr_read;\n\t\t\tbuf\t+= nr_read;\n\t\t\tcount\t-= nr_read;\n\t\t\trv\t+= nr_read;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Command line (1 string) occupies ARGV and\n\t\t * extends into ENVP.\n\t\t */\n\t\tstruct {\n\t\t\tunsigned long p;\n\t\t\tunsigned long len;\n\t\t} cmdline[2] = {\n\t\t\t{ .p = arg_start, .len = len1 },\n\t\t\t{ .p = env_start, .len = len2 },\n\t\t};\n\t\tloff_t pos1 = *pos;\n\t\tunsigned int i;\n\n\t\ti = 0;\n\t\twhile (i < 2 && pos1 >= cmdline[i].len) {\n\t\t\tpos1 -= cmdline[i].len;\n\t\t\ti++;\n\t\t}\n\t\twhile (i < 2) {\n\t\t\tp = cmdline[i].p + pos1;\n\t\t\tlen = cmdline[i].len - pos1;\n\t\t\twhile (count > 0 && len > 0) {\n\t\t\t\tunsigned int _count, l;\n\t\t\t\tint nr_read;\n\t\t\t\tbool final;\n\n\t\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n\t\t\t\tif (nr_read < 0)\n\t\t\t\t\trv = nr_read;\n\t\t\t\tif (nr_read <= 0)\n\t\t\t\t\tgoto out_free_page;\n\n\t\t\t\t/*\n\t\t\t\t * Command line can be shorter than whole ARGV\n\t\t\t\t * even if last \"marker\" byte says it is not.\n\t\t\t\t */\n\t\t\t\tfinal = false;\n\t\t\t\tl = strnlen(page, nr_read);\n\t\t\t\tif (l < nr_read) {\n\t\t\t\t\tnr_read = l;\n\t\t\t\t\tfinal = true;\n\t\t\t\t}\n\n\t\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\t\trv = -EFAULT;\n\t\t\t\t\tgoto out_free_page;\n\t\t\t\t}\n\n\t\t\t\tp\t+= nr_read;\n\t\t\t\tlen\t-= nr_read;\n\t\t\t\tbuf\t+= nr_read;\n\t\t\t\tcount\t-= nr_read;\n\t\t\t\trv\t+= nr_read;\n\n\t\t\t\tif (final)\n\t\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\t/* Only first chunk can be read partially. */\n\t\t\tpos1 = 0;\n\t\t\ti++;\n\t\t}\n\t}\n\nout_free_page:\n\tfree_page((unsigned long)page);\nout_mmput:\n\tmmput(mm);\n\tif (rv > 0)\n\t\t*pos += rv;\n\treturn rv;\n}\n",
      "line_statements": [
        [
          264,
          "\trv = access_remote_vm(mm, arg_end - 1, &c, 1, 0);\n"
        ],
        [
          282,
          "\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n"
        ],
        [
          328,
          "\t\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n"
        ]
      ],
      "statements": [
        [
          264,
          "rv = access_remote_vm(mm, arg_end - 1, &c, 1, 0);"
        ],
        [
          282,
          "nr_read = access_remote_vm(mm, p, page, _count, 0);"
        ],
        [
          328,
          "nr_read = access_remote_vm(mm, p, page, _count, 0);"
        ]
      ],
      "cve": "CVE-2018-1120"
    },
    {
      "commit_id": "0a2d3e3644a7453b6513db2f9bc270f77943573f",
      "filepath": "src/KaxBlock.cpp",
      "project": "libmatroska",
      "project_repo_path": "symbol_backend_projects/libmatroska",
      "is_vulnerable": false,
      "func_name": "KaxInternalBlock::ReadData",
      "func_body": "filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  filepos_t Result;\n\n  FirstFrameLocation = input.getFilePointer(); // will be updated accordingly below\n\n  SetValueIsSet(false);\n\n  try {\n    if (ReadFully == SCOPE_ALL_DATA) {\n      Result = EbmlBinary::ReadData(input, ReadFully);\n      if (Result != GetSize())\n        throw SafeReadIOCallback::EndOfStreamX(GetSize() - Result);\n\n      binary *BufferStart = EbmlBinary::GetBuffer();\n\n      SafeReadIOCallback Mem(*this);\n      uint8 BlockHeadSize = 4;\n\n      // update internal values\n      TrackNumber = Mem.GetUInt8();\n      if ((TrackNumber & 0x80) == 0) {\n        // there is extra data\n        if ((TrackNumber & 0x40) == 0) {\n          // We don't support track numbers that large !\n          throw SafeReadIOCallback::EndOfStreamX(0);\n        }\n        TrackNumber = (TrackNumber & 0x3F) << 8;\n        TrackNumber += Mem.GetUInt8();\n        BlockHeadSize++;\n      } else {\n        TrackNumber &= 0x7F;\n      }\n\n      LocalTimecode = int16(Mem.GetUInt16BE());\n      bLocalTimecodeUsed = true;\n\n      uint8 Flags = Mem.GetUInt8();\n      if (EbmlId(*this) == EBML_ID(KaxSimpleBlock)) {\n        bIsKeyframe = (Flags & 0x80) != 0;\n        bIsDiscardable = (Flags & 0x01) != 0;\n      }\n      mInvisible = (Flags & 0x08) >> 3;\n      mLacing = LacingType((Flags & 0x06) >> 1);\n\n      // put all Frames in the list\n      if (mLacing == LACING_NONE) {\n        FirstFrameLocation += Mem.GetPosition();\n        DataBuffer * soloFrame = new DataBuffer(BufferStart + Mem.GetPosition(), GetSize() - BlockHeadSize);\n        myBuffers.push_back(soloFrame);\n        SizeList.resize(1);\n        SizeList[0] = GetSize() - BlockHeadSize;\n      } else {\n        // read the number of frames in the lace\n        uint32 LastBufferSize = GetSize() - BlockHeadSize - 1; // 1 for number of frame\n        uint8 FrameNum = Mem.GetUInt8(); // number of frames in the lace - 1\n        // read the list of frame sizes\n        uint8 Index;\n        int32 FrameSize;\n        uint32 SizeRead;\n        uint64 SizeUnknown;\n\n        SizeList.resize(FrameNum + 1);\n\n        switch (mLacing) {\n          case LACING_XIPH:\n            for (Index=0; Index<FrameNum; Index++) {\n              // get the size of the frame\n              FrameSize = 0;\n              uint8 Value;\n              do {\n                Value = Mem.GetUInt8();\n                FrameSize += Value;\n                LastBufferSize--;\n              } while (Value == 0xFF);\n              SizeList[Index] = FrameSize;\n              LastBufferSize -= FrameSize;\n            }\n            SizeList[Index] = LastBufferSize;\n            break;\n          case LACING_EBML:\n            SizeRead = LastBufferSize;\n            FrameSize = ReadCodedSizeValue(BufferStart + Mem.GetPosition(), SizeRead, SizeUnknown);\n            if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))\n              throw SafeReadIOCallback::EndOfStreamX(SizeRead);\n            SizeList[0] = FrameSize;\n            Mem.Skip(SizeRead);\n            LastBufferSize -= FrameSize + SizeRead;\n\n            for (Index=1; Index<FrameNum; Index++) {\n              // get the size of the frame\n              SizeRead = LastBufferSize;\n              FrameSize += ReadCodedSizeSignedValue(BufferStart + Mem.GetPosition(), SizeRead, SizeUnknown);\n              if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))\n                throw SafeReadIOCallback::EndOfStreamX(SizeRead);\n              SizeList[Index] = FrameSize;\n              Mem.Skip(SizeRead);\n              LastBufferSize -= FrameSize + SizeRead;\n            }\n            if (Index <= FrameNum) // Safety check if FrameNum == 0\n              SizeList[Index] = LastBufferSize;\n            break;\n          case LACING_FIXED:\n            for (Index=0; Index<=FrameNum; Index++) {\n              // get the size of the frame\n              SizeList[Index] = LastBufferSize / (FrameNum + 1);\n            }\n            break;\n          default: // other lacing not supported\n            assert(0);\n        }\n\n        FirstFrameLocation += Mem.GetPosition();\n\n        for (Index=0; Index<=FrameNum; Index++) {\n          DataBuffer * lacedFrame = new DataBuffer(BufferStart + Mem.GetPosition(), SizeList[Index]);\n          myBuffers.push_back(lacedFrame);\n          Mem.Skip(SizeList[Index]);\n        }\n      }\n\n      binary *BufferEnd = BufferStart + GetSize();\n      size_t NumFrames  = myBuffers.size();\n\n      // Sanity checks for frame pointers and boundaries.\n      for (size_t Index = 0; Index < NumFrames; ++Index) {\n        binary *FrameStart  = myBuffers[Index]->Buffer();\n        binary *FrameEnd    = FrameStart + myBuffers[Index]->Size();\n        binary *ExpectedEnd = (Index + 1) < NumFrames ? myBuffers[Index + 1]->Buffer() : BufferEnd;\n\n        if ((FrameStart < BufferStart) || (FrameEnd > BufferEnd) || (FrameEnd != ExpectedEnd))\n          throw SafeReadIOCallback::EndOfStreamX(0);\n      }\n\n      SetValueIsSet();\n    } else if (ReadFully == SCOPE_PARTIAL_DATA) {\n      binary _TempHead[5];\n      Result = input.read(_TempHead, 5);\n      if (Result != 5)\n        throw SafeReadIOCallback::EndOfStreamX(0);\n      binary *cursor = _TempHead;\n      binary *_tmpBuf;\n      uint8 BlockHeadSize = 4;\n\n      // update internal values\n      TrackNumber = *cursor++;\n      if ((TrackNumber & 0x80) == 0) {\n        // there is extra data\n        if ((TrackNumber & 0x40) == 0) {\n          // We don't support track numbers that large !\n          return Result;\n        }\n        TrackNumber = (TrackNumber & 0x3F) << 8;\n        TrackNumber += *cursor++;\n        BlockHeadSize++;\n      } else {\n        TrackNumber &= 0x7F;\n      }\n\n      big_int16 b16;\n      b16.Eval(cursor);\n      LocalTimecode = int16(b16);\n      bLocalTimecodeUsed = true;\n      cursor += 2;\n\n      if (EbmlId(*this) == EBML_ID(KaxSimpleBlock)) {\n        bIsKeyframe = (*cursor & 0x80) != 0;\n        bIsDiscardable = (*cursor & 0x01) != 0;\n      }\n      mInvisible = (*cursor & 0x08) >> 3;\n      mLacing = LacingType((*cursor++ & 0x06) >> 1);\n      if (cursor == &_TempHead[4]) {\n        _TempHead[0] = _TempHead[4];\n      } else {\n        Result += input.read(_TempHead, 1);\n      }\n\n      FirstFrameLocation += cursor - _TempHead;\n\n      // put all Frames in the list\n      if (mLacing != LACING_NONE) {\n        // read the number of frames in the lace\n        uint32 LastBufferSize = GetSize() - BlockHeadSize - 1; // 1 for number of frame\n        uint8 FrameNum = _TempHead[0]; // number of frames in the lace - 1\n        // read the list of frame sizes\n        uint8 Index;\n        int32 FrameSize;\n        uint32 SizeRead;\n        uint64 SizeUnknown;\n\n        SizeList.resize(FrameNum + 1);\n\n        switch (mLacing) {\n          case LACING_XIPH:\n            for (Index=0; Index<FrameNum; Index++) {\n              // get the size of the frame\n              FrameSize = 0;\n              do {\n                Result += input.read(_TempHead, 1);\n                FrameSize += uint8(_TempHead[0]);\n                LastBufferSize--;\n\n                FirstFrameLocation++;\n              } while (_TempHead[0] == 0xFF);\n\n              FirstFrameLocation++;\n              SizeList[Index] = FrameSize;\n              LastBufferSize -= FrameSize;\n            }\n            SizeList[Index] = LastBufferSize;\n            break;\n          case LACING_EBML:\n            SizeRead = LastBufferSize;\n            cursor = _tmpBuf = new binary[FrameNum*4]; /// \\warning assume the mean size will be coded in less than 4 bytes\n            Result += input.read(cursor, FrameNum*4);\n            FrameSize = ReadCodedSizeValue(cursor, SizeRead, SizeUnknown);\n            SizeList[0] = FrameSize;\n            cursor += SizeRead;\n            LastBufferSize -= FrameSize + SizeRead;\n\n            for (Index=1; Index<FrameNum; Index++) {\n              // get the size of the frame\n              SizeRead = LastBufferSize;\n              FrameSize += ReadCodedSizeSignedValue(cursor, SizeRead, SizeUnknown);\n              SizeList[Index] = FrameSize;\n              cursor += SizeRead;\n              LastBufferSize -= FrameSize + SizeRead;\n            }\n\n            FirstFrameLocation += cursor - _tmpBuf;\n\n            SizeList[Index] = LastBufferSize;\n            delete [] _tmpBuf;\n            break;\n          case LACING_FIXED:\n            for (Index=0; Index<=FrameNum; Index++) {\n              // get the size of the frame\n              SizeList[Index] = LastBufferSize / (FrameNum + 1);\n            }\n            break;\n          default: // other lacing not supported\n            assert(0);\n        }\n      } else {\n        SizeList.resize(1);\n        SizeList[0] = GetSize() - BlockHeadSize;\n      }\n      SetValueIsSet(false);\n      Result = GetSize();\n    } else {\n      SetValueIsSet(false);\n      Result = GetSize();\n    }\n\n  } catch (SafeReadIOCallback::EndOfStreamX &) {\n    SetValueIsSet(false);\n\n    std::memset(EbmlBinary::GetBuffer(), 0, GetSize());\n    myBuffers.clear();\n    SizeList.clear();\n    Timecode           = 0;\n    LocalTimecode      = 0;\n    TrackNumber        = 0;\n    bLocalTimecodeUsed = false;\n    FirstFrameLocation = 0;\n\n    return 0;\n  }\n\n  return Result;\n}",
      "line_statements": [
        [
          532,
          "            if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))"
        ],
        [
          533,
          "              throw SafeReadIOCallback::EndOfStreamX(SizeRead);"
        ],
        [
          542,
          "              if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))"
        ],
        [
          543,
          "                throw SafeReadIOCallback::EndOfStreamX(SizeRead);"
        ]
      ],
      "statements": [
        [
          532,
          "if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))"
        ],
        [
          533,
          "throw SafeReadIOCallback::EndOfStreamX(SizeRead);"
        ],
        [
          542,
          "if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))"
        ],
        [
          543,
          "throw SafeReadIOCallback::EndOfStreamX(SizeRead);"
        ]
      ],
      "cve": "CVE-2015-8792"
    },
    {
      "commit_id": "c4cca4c20e75359c9a13a1f9a36cb7b4e9601d29",
      "filepath": "ext/wddx/wddx.c",
      "project": "php-src",
      "project_repo_path": "symbol_backend_projects/php-src",
      "is_vulnerable": true,
      "func_name": "php_wddx_push_element",
      "func_body": " */\nstatic void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tALLOC_ZVAL(ent.data);\n\t\t\t\tINIT_PZVAL(ent.data);\n\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i], strlen(atts[i]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup(atts[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[++i] && atts[i][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}",
      "line_statements": [
        [
          783,
          "\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0]) {"
        ],
        [
          786,
          "\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i], NULL, 16));"
        ],
        [
          804,
          "\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0]) {"
        ],
        [
          812,
          "\t\t\t\tphp_wddx_process_data(user_data, atts[i], strlen(atts[i]));"
        ],
        [
          845,
          "\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {"
        ],
        [
          847,
          "\t\t\t\tstack->varname = estrdup(atts[i]);"
        ],
        [
          860,
          "\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[++i] && atts[i][0]) {"
        ],
        [
          896,
          "\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {"
        ],
        [
          902,
          "\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS) {"
        ]
      ],
      "statements": [
        [
          783,
          "if (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0])"
        ],
        [
          786,
          "snprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i], NULL, 16));"
        ],
        [
          804,
          "if (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0])"
        ],
        [
          812,
          "php_wddx_process_data(user_data, atts[i], strlen(atts[i]));"
        ],
        [
          845,
          "if (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0])"
        ],
        [
          847,
          "stack->varname = estrdup(atts[i]);"
        ],
        [
          860,
          "if (!strcmp(atts[i], \"fieldNames\") && atts[++i] && atts[i][0])"
        ],
        [
          896,
          "if (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0])"
        ],
        [
          900,
          "if (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS)"
        ]
      ],
      "cve": "CVE-2016-7418"
    },
    {
      "commit_id": "103b171d8fc282ef435f8de9afbf7782e312961f",
      "filepath": "ssl/d1_pkt.c",
      "project": "openssl",
      "project_repo_path": "symbol_backend_projects/openssl",
      "is_vulnerable": true,
      "func_name": "dtls1_read_bytes",
      "func_body": "int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)\n\t{\n\tint al,i,j,ret;\n\tunsigned int n;\n\tSSL3_RECORD *rr;\n\tvoid (*cb)(const SSL *ssl,int type2,int val)=NULL;\n\n\tif (s->s3->rbuf.buf == NULL) /* Not initialized yet */\n\t\tif (!ssl3_setup_buffers(s))\n\t\t\treturn(-1);\n\n\tif ((type && (type != SSL3_RT_APPLICATION_DATA) && \n\t\t(type != SSL3_RT_HANDSHAKE)) ||\n\t    (peek && (type != SSL3_RT_APPLICATION_DATA)))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);\n\t\treturn -1;\n\t\t}\n\n\t/* check whether there's a handshake message (client hello?) waiting */\n\tif ( (ret = have_handshake_fragment(s, type, buf, len, peek)))\n\t\treturn ret;\n\n\t/* Now s->d1->handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE. */\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Continue handshake if it had to be interrupted to read\n\t * app data with SCTP.\n\t */\n\tif ((!s->in_handshake && SSL_in_init(s)) ||\n\t    (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t     (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK) &&\n\t     s->s3->in_read_app_data != 2))\n#else\n\tif (!s->in_handshake && SSL_in_init(s))\n#endif\n\t\t{\n\t\t/* type == SSL3_RT_APPLICATION_DATA */\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\t\t}\n\nstart:\n\ts->rwstate=SSL_NOTHING;\n\n\t/*-\n\t * s->s3->rrec.type\t    - is the type of record\n\t * s->s3->rrec.data,    - data\n\t * s->s3->rrec.off,     - offset into 'data' for next read\n\t * s->s3->rrec.length,  - number of bytes. \n\t */\n\trr = &(s->s3->rrec);\n\n\t/* We are not handshaking and have no data yet,\n\t * so process data buffered during the last handshake\n\t * in advance, if any.\n\t */\n\tif (s->state == SSL_ST_OK && rr->length == 0)\n\t\t{\n\t\tpitem *item;\n\t\titem = pqueue_pop(s->d1->buffered_app_data.q);\n\t\tif (item)\n\t\t\t{\n#ifndef OPENSSL_NO_SCTP\n\t\t\t/* Restore bio_dgram_sctp_rcvinfo struct */\n\t\t\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)))\n\t\t\t\t{\n\t\t\t\tDTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *) item->data;\n\t\t\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t\t\t\t}\n#endif\n\n\t\t\tdtls1_copy_record(s, item);\n\n\t\t\tOPENSSL_free(item->data);\n\t\t\tpitem_free(item);\n\t\t\t}\n\t\t}\n\n\t/* Check for timeout */\n\tif (dtls1_handle_timeout(s) > 0)\n\t\tgoto start;\n\n\t/* get new packet if necessary */\n\tif ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))\n\t\t{\n\t\tret=dtls1_get_record(s);\n\t\tif (ret <= 0) \n\t\t\t{\n\t\t\tret = dtls1_read_failed(s, ret);\n\t\t\t/* anything other than a timeout is an error */\n\t\t\tif (ret <= 0)  \n\t\t\t\treturn(ret);\n\t\t\telse\n\t\t\t\tgoto start;\n\t\t\t}\n\t\t}\n\n\tif (s->d1->listen && rr->type != SSL3_RT_HANDSHAKE)\n\t\t{\n\t\trr->length = 0;\n\t\tgoto start;\n\t\t}\n\n\t/* we now have a packet which can be read and processed */\n\n\tif (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n\t                               * reset by ssl3_get_finished */\n\t\t&& (rr->type != SSL3_RT_HANDSHAKE))\n\t\t{\n\t\t/* We now have application data between CCS and Finished.\n\t\t * Most likely the packets were reordered on their way, so\n\t\t * buffer the application data for later processing rather\n\t\t * than dropping the connection.\n\t\t */\n\t\tdtls1_buffer_record(s, &(s->d1->buffered_app_data), rr->seq_num);\n\t\trr->length = 0;\n\t\tgoto start;\n\t\t}\n\n\t/* If the other end has shut down, throw anything we read away\n\t * (even in 'peek' mode) */\n\tif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\n\t\t{\n\t\trr->length=0;\n\t\ts->rwstate=SSL_NOTHING;\n\t\treturn(0);\n\t\t}\n\n\n\tif (type == rr->type) /* SSL3_RT_APPLICATION_DATA or SSL3_RT_HANDSHAKE */\n\t\t{\n\t\t/* make sure that we are not getting application data when we\n\t\t * are doing a handshake for the first time */\n\t\tif (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n\t\t\t(s->enc_read_ctx == NULL))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (len <= 0) return(len);\n\n\t\tif ((unsigned int)len > rr->length)\n\t\t\tn = rr->length;\n\t\telse\n\t\t\tn = (unsigned int)len;\n\n\t\tmemcpy(buf,&(rr->data[rr->off]),n);\n\t\tif (!peek)\n\t\t\t{\n\t\t\trr->length-=n;\n\t\t\trr->off+=n;\n\t\t\tif (rr->length == 0)\n\t\t\t\t{\n\t\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\t\trr->off=0;\n\t\t\t\t}\n\t\t\t}\n\n#ifndef OPENSSL_NO_SCTP\n\t\t\t/* We were about to renegotiate but had to read\n\t\t\t * belated application data first, so retry.\n\t\t\t */\n\t\t\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t\t\t    rr->type == SSL3_RT_APPLICATION_DATA &&\n\t\t\t    (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK))\n\t\t\t\t{\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\t\t}\n\n\t\t\t/* We might had to delay a close_notify alert because\n\t\t\t * of reordered app data. If there was an alert and there\n\t\t\t * is no message to read anymore, finally set shutdown.\n\t\t\t */\n\t\t\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t\t\t    s->d1->shutdown_received && !BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))\n\t\t\t\t{\n\t\t\t\ts->shutdown |= SSL_RECEIVED_SHUTDOWN;\n\t\t\t\treturn(0);\n\t\t\t\t}\n#endif\t\t\t\n\t\treturn(n);\n\t\t}\n\n\n\t/* If we get here, then type != rr->type; if we have a handshake\n\t * message, then it was unexpected (Hello Request or Client Hello). */\n\n\t/* In case of record types for which we have 'fragment' storage,\n\t * fill that so that we can process the data at a fixed place.\n\t */\n\t\t{\n\t\tunsigned int k, dest_maxlen = 0;\n\t\tunsigned char *dest = NULL;\n\t\tunsigned int *dest_len = NULL;\n\n\t\tif (rr->type == SSL3_RT_HANDSHAKE)\n\t\t\t{\n\t\t\tdest_maxlen = sizeof s->d1->handshake_fragment;\n\t\t\tdest = s->d1->handshake_fragment;\n\t\t\tdest_len = &s->d1->handshake_fragment_len;\n\t\t\t}\n\t\telse if (rr->type == SSL3_RT_ALERT)\n\t\t\t{\n\t\t\tdest_maxlen = sizeof(s->d1->alert_fragment);\n\t\t\tdest = s->d1->alert_fragment;\n\t\t\tdest_len = &s->d1->alert_fragment_len;\n\t\t\t}\n#ifndef OPENSSL_NO_HEARTBEATS\n\t\telse if (rr->type == TLS1_RT_HEARTBEAT)\n\t\t\t{\n\t\t\tdtls1_process_heartbeat(s);\n\n\t\t\t/* Exit and notify application to read again */\n\t\t\trr->length = 0;\n\t\t\ts->rwstate=SSL_READING;\n\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\treturn(-1);\n\t\t\t}\n#endif\n\t\t/* else it's a CCS message, or application data or wrong */\n\t\telse if (rr->type != SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\t\t{\n\t\t\t/* Application data while renegotiating\n\t\t\t * is allowed. Try again reading.\n\t\t\t */\n\t\t\tif (rr->type == SSL3_RT_APPLICATION_DATA)\n\t\t\t\t{\n\t\t\t\tBIO *bio;\n\t\t\t\ts->s3->in_read_app_data=2;\n\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\n\t\t\t/* Not certain if this is the right error handling */\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (dest_maxlen > 0)\n\t\t\t{\n            /* XDTLS:  In a pathalogical case, the Client Hello\n             *  may be fragmented--don't always expect dest_maxlen bytes */\n\t\t\tif ( rr->length < dest_maxlen)\n\t\t\t\t{\n#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE\n\t\t\t\t/*\n\t\t\t\t * for normal alerts rr->length is 2, while\n\t\t\t\t * dest_maxlen is 7 if we were to handle this\n\t\t\t\t * non-existing alert...\n\t\t\t\t */\n\t\t\t\tFIX ME\n#endif\n\t\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\t\trr->length = 0;\n\t\t\t\tgoto start;\n\t\t\t\t}\n\n\t\t\t/* now move 'n' bytes: */\n\t\t\tfor ( k = 0; k < dest_maxlen; k++)\n\t\t\t\t{\n\t\t\t\tdest[k] = rr->data[rr->off++];\n\t\t\t\trr->length--;\n\t\t\t\t}\n\t\t\t*dest_len = dest_maxlen;\n\t\t\t}\n\t\t}\n\n\t/* s->d1->handshake_fragment_len == 12  iff  rr->type == SSL3_RT_HANDSHAKE;\n\t * s->d1->alert_fragment_len == 7      iff  rr->type == SSL3_RT_ALERT.\n\t * (Possibly rr is 'empty' now, i.e. rr->length may be 0.) */\n\n\t/* If we are a client, check for an incoming 'Hello Request': */\n\tif ((!s->server) &&\n\t\t(s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) &&\n\t\t(s->d1->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n\t\t(s->session != NULL) && (s->session->cipher != NULL))\n\t\t{\n\t\ts->d1->handshake_fragment_len = 0;\n\n\t\tif ((s->d1->handshake_fragment[1] != 0) ||\n\t\t\t(s->d1->handshake_fragment[2] != 0) ||\n\t\t\t(s->d1->handshake_fragment[3] != 0))\n\t\t\t{\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_BAD_HELLO_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* no need to check sequence number on HELLO REQUEST messages */\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, \n\t\t\t\ts->d1->handshake_fragment, 4, s, s->msg_callback_arg);\n\n\t\tif (SSL_is_init_finished(s) &&\n\t\t\t!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n\t\t\t!s->s3->renegotiate)\n\t\t\t{\n\t\t\ts->d1->handshake_read_seq++;\n\t\t\ts->new_session = 1;\n\t\t\tssl3_renegotiate(s);\n\t\t\tif (ssl3_renegotiate_check(s))\n\t\t\t\t{\n\t\t\t\ti=s->handshake_func(s);\n\t\t\t\tif (i < 0) return(i);\n\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\t\t\treturn(-1);\n\t\t\t\t\t}\n\n\t\t\t\tif (!(s->mode & SSL_MODE_AUTO_RETRY))\n\t\t\t\t\t{\n\t\t\t\t\tif (s->s3->rbuf.left == 0) /* no read-ahead left? */\n\t\t\t\t\t\t{\n\t\t\t\t\t\tBIO *bio;\n\t\t\t\t\t\t/* In the case where we try to read application data,\n\t\t\t\t\t\t * but we trigger an SSL handshake, we return -1 with\n\t\t\t\t\t\t * the retry option set.  Otherwise renegotiation may\n\t\t\t\t\t\t * cause nasty problems in the blocking world */\n\t\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t/* we either finished a handshake or ignored the request,\n\t\t * now try again to obtain the (application) data we were asked for */\n\t\tgoto start;\n\t\t}\n\n\tif (s->d1->alert_fragment_len >= DTLS1_AL_HEADER_LENGTH)\n\t\t{\n\t\tint alert_level = s->d1->alert_fragment[0];\n\t\tint alert_descr = s->d1->alert_fragment[1];\n\n\t\ts->d1->alert_fragment_len = 0;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_ALERT, \n\t\t\t\ts->d1->alert_fragment, 2, s, s->msg_callback_arg);\n\n\t\tif (s->info_callback != NULL)\n\t\t\tcb=s->info_callback;\n\t\telse if (s->ctx->info_callback != NULL)\n\t\t\tcb=s->ctx->info_callback;\n\n\t\tif (cb != NULL)\n\t\t\t{\n\t\t\tj = (alert_level << 8) | alert_descr;\n\t\t\tcb(s, SSL_CB_READ_ALERT, j);\n\t\t\t}\n\n\t\tif (alert_level == 1) /* warning */\n\t\t\t{\n\t\t\ts->s3->warn_alert = alert_descr;\n\t\t\tif (alert_descr == SSL_AD_CLOSE_NOTIFY)\n\t\t\t\t{\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\t/* With SCTP and streams the socket may deliver app data\n\t\t\t\t * after a close_notify alert. We have to check this\n\t\t\t\t * first so that nothing gets discarded.\n\t\t\t\t */\n\t\t\t\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t\t\t\t\tBIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))\n\t\t\t\t\t{\n\t\t\t\t\ts->d1->shutdown_received = 1;\n\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n#endif\n\t\t\t\ts->shutdown |= SSL_RECEIVED_SHUTDOWN;\n\t\t\t\treturn(0);\n\t\t\t\t}\n#if 0\n            /* XXX: this is a possible improvement in the future */\n\t\t\t/* now check if it's a missing record */\n\t\t\tif (alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE)\n\t\t\t\t{\n\t\t\t\tunsigned short seq;\n\t\t\t\tunsigned int frag_off;\n\t\t\t\tunsigned char *p = &(s->d1->alert_fragment[2]);\n\n\t\t\t\tn2s(p, seq);\n\t\t\t\tn2l3(p, frag_off);\n\n\t\t\t\tdtls1_retransmit_message(s,\n\t\t\t\t\t\t\t\t\t\t dtls1_get_queue_priority(frag->msg_header.seq, 0),\n\t\t\t\t\t\t\t\t\t\t frag_off, &found);\n\t\t\t\tif ( ! found  && SSL_in_init(s))\n\t\t\t\t\t{\n\t\t\t\t\t/* fprintf( stderr,\"in init = %d\\n\", SSL_in_init(s)); */\n\t\t\t\t\t/* requested a message not yet sent, \n\t\t\t\t\t   send an alert ourselves */\n\t\t\t\t\tssl3_send_alert(s,SSL3_AL_WARNING,\n\t\t\t\t\t\tDTLS1_AD_MISSING_HANDSHAKE_MESSAGE);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\telse if (alert_level == 2) /* fatal */\n\t\t\t{\n\t\t\tchar tmp[16];\n\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\ts->s3->fatal_alert = alert_descr;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n\t\t\tBIO_snprintf(tmp,sizeof tmp,\"%d\",alert_descr);\n\t\t\tERR_add_error_data(2,\"SSL alert number \",tmp);\n\t\t\ts->shutdown|=SSL_RECEIVED_SHUTDOWN;\n\t\t\tSSL_CTX_remove_session(s->ctx,s->session);\n\t\t\treturn(0);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tgoto start;\n\t\t}\n\n\tif (s->shutdown & SSL_SENT_SHUTDOWN) /* but we have not received a shutdown */\n\t\t{\n\t\ts->rwstate=SSL_NOTHING;\n\t\trr->length=0;\n\t\treturn(0);\n\t\t}\n\n\tif (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\t{\n\t\tstruct ccs_header_st ccs_hdr;\n\t\tunsigned int ccs_hdr_len = DTLS1_CCS_HEADER_LENGTH;\n\n\t\tdtls1_get_ccs_header(rr->data, &ccs_hdr);\n\n\t\tif (s->version == DTLS1_BAD_VER)\n\t\t\tccs_hdr_len = 3;\n\n\t\t/* 'Change Cipher Spec' is just a single byte, so we know\n\t\t * exactly what the record payload has to look like */\n\t\t/* XDTLS: check that epoch is consistent */\n\t\tif (\t(rr->length != ccs_hdr_len) || \n\t\t\t(rr->off != 0) || (rr->data[0] != SSL3_MT_CCS))\n\t\t\t{\n\t\t\ti=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\trr->length=0;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, \n\t\t\t\trr->data, 1, s, s->msg_callback_arg);\n\n\t\t/* We can't process a CCS now, because previous handshake\n\t\t * messages are still missing, so just drop it.\n\t\t */\n\t\tif (!s->d1->change_cipher_spec_ok)\n\t\t\t{\n\t\t\tgoto start;\n\t\t\t}\n\n\t\ts->d1->change_cipher_spec_ok = 0;\n\n\t\ts->s3->change_cipher_spec=1;\n\t\tif (!ssl3_do_change_cipher_spec(s))\n\t\t\tgoto err;\n\n\t\t/* do this whenever CCS is processed */\n\t\tdtls1_reset_seq_numbers(s, SSL3_CC_READ);\n\n\t\tif (s->version == DTLS1_BAD_VER)\n\t\t\ts->d1->handshake_read_seq++;\n\n#ifndef OPENSSL_NO_SCTP\n\t\t/* Remember that a CCS has been received,\n\t\t * so that an old key of SCTP-Auth can be\n\t\t * deleted when a CCS is sent. Will be ignored\n\t\t * if no SCTP is used\n\t\t */\n\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD, 1, NULL);\n#endif\n\n\t\tgoto start;\n\t\t}\n\n\t/* Unexpected handshake message (Client Hello, or protocol violation) */\n\tif ((s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) && \n\t\t!s->in_handshake)\n\t\t{\n\t\tstruct hm_header_st msg_hdr;\n\t\t\n\t\t/* this may just be a stale retransmit */\n\t\tdtls1_get_message_header(rr->data, &msg_hdr);\n\t\tif( rr->epoch != s->d1->r_epoch)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\tgoto start;\n\t\t\t}\n\n\t\t/* If we are server, we may have a repeated FINISHED of the\n\t\t * client here, then retransmit our CCS and FINISHED.\n\t\t */\n\t\tif (msg_hdr.type == SSL3_MT_FINISHED)\n\t\t\t{\n\t\t\tif (dtls1_check_timeout_num(s) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tdtls1_retransmit_buffered_messages(s);\n\t\t\trr->length = 0;\n\t\t\tgoto start;\n\t\t\t}\n\n\t\tif (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&\n\t\t\t!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))\n\t\t\t{\n#if 0 /* worked only because C operator preferences are not as expected (and\n       * because this is not really needed for clients except for detecting\n       * protocol violations): */\n\t\t\ts->state=SSL_ST_BEFORE|(s->server)\n\t\t\t\t?SSL_ST_ACCEPT\n\t\t\t\t:SSL_ST_CONNECT;\n#else\n\t\t\ts->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;\n#endif\n\t\t\ts->renegotiate=1;\n\t\t\ts->new_session=1;\n\t\t\t}\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\n\t\tif (!(s->mode & SSL_MODE_AUTO_RETRY))\n\t\t\t{\n\t\t\tif (s->s3->rbuf.left == 0) /* no read-ahead left? */\n\t\t\t\t{\n\t\t\t\tBIO *bio;\n\t\t\t\t/* In the case where we try to read application data,\n\t\t\t\t * but we trigger an SSL handshake, we return -1 with\n\t\t\t\t * the retry option set.  Otherwise renegotiation may\n\t\t\t\t * cause nasty problems in the blocking world */\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\t}\n\t\tgoto start;\n\t\t}\n\n\tswitch (rr->type)\n\t\t{\n\tdefault:\n#ifndef OPENSSL_NO_TLS\n\t\t/* TLS just ignores unknown message types */\n\t\tif (s->version == TLS1_VERSION)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\tgoto start;\n\t\t\t}\n#endif\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\tgoto f_err;\n\tcase SSL3_RT_CHANGE_CIPHER_SPEC:\n\tcase SSL3_RT_ALERT:\n\tcase SSL3_RT_HANDSHAKE:\n\t\t/* we already handled all of these, with the possible exception\n\t\t * of SSL3_RT_HANDSHAKE when s->in_handshake is set, but that\n\t\t * should not happen when type != rr->type */\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,ERR_R_INTERNAL_ERROR);\n\t\tgoto f_err;\n\tcase SSL3_RT_APPLICATION_DATA:\n\t\t/* At this point, we were expecting handshake data,\n\t\t * but have application data.  If the library was\n\t\t * running inside ssl3_read() (i.e. in_read_app_data\n\t\t * is set) and it makes sense to read application data\n\t\t * at this point (session renegotiation not yet started),\n\t\t * we will indulge it.\n\t\t */\n\t\tif (s->s3->in_read_app_data &&\n\t\t\t(s->s3->total_renegotiations != 0) &&\n\t\t\t((\n\t\t\t\t(s->state & SSL_ST_CONNECT) &&\n\t\t\t\t(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&\n\t\t\t\t(s->state <= SSL3_ST_CR_SRVR_HELLO_A)\n\t\t\t\t) || (\n\t\t\t\t\t(s->state & SSL_ST_ACCEPT) &&\n\t\t\t\t\t(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&\n\t\t\t\t\t(s->state >= SSL3_ST_SR_CLNT_HELLO_A)\n\t\t\t\t\t)\n\t\t\t\t))\n\t\t\t{\n\t\t\ts->s3->in_read_app_data=2;\n\t\t\treturn(-1);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\t/* not reached */\n\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\treturn(-1);\n\t}",
      "line_statements": [
        [
          872,
          "\t\tdtls1_buffer_record(s, &(s->d1->buffered_app_data), rr->seq_num);"
        ]
      ],
      "statements": [
        [
          872,
          "dtls1_buffer_record(s, &(s->d1->buffered_app_data), rr->seq_num);"
        ]
      ],
      "cve": "CVE-2015-0206"
    },
    {
      "commit_id": "ad3e14d7c5268c2e24477c6ef54bbdf88add5d36",
      "filepath": "drivers/hid/hid-logitech-dj.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "logi_dj_raw_event",
      "func_body": "static int logi_dj_raw_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_report *dj_report = (struct dj_report *) data;\n\tunsigned long flags;\n\tbool report_processed = false;\n\n\tdbg_hid(\"%s, size:%d\\n\", __func__, size);\n\n\t/* Here we receive all data coming from iface 2, there are 4 cases:\n\t *\n\t * 1) Data should continue its normal processing i.e. data does not\n\t * come from the DJ collection, in which case we do nothing and\n\t * return 0, so hid-core can continue normal processing (will forward\n\t * to associated hidraw device)\n\t *\n\t * 2) Data is from DJ collection, and is intended for this driver i. e.\n\t * data contains arrival, departure, etc notifications, in which case\n\t * we queue them for delayed processing by the work queue. We return 1\n\t * to hid-core as no further processing is required from it.\n\t *\n\t * 3) Data is from DJ collection, and informs a connection change,\n\t * if the change means rf link loss, then we must send a null report\n\t * to the upper layer to discard potentially pressed keys that may be\n\t * repeated forever by the input layer. Return 1 to hid-core as no\n\t * further processing is required.\n\t *\n\t * 4) Data is from DJ collection and is an actual input event from\n\t * a paired DJ device in which case we forward it to the correct hid\n\t * device (via hid_input_report() ) and return 1 so hid-core does not do\n\t * anything else with it.\n\t */\n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t\t__func__, dj_report->device_index);\n\t\treturn false;\n\t}\n\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tif (dj_report->report_id == REPORT_ID_DJ_SHORT) {\n\t\tswitch (dj_report->report_type) {\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\n\t\t\tlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\n\t\t\tbreak;\n\t\tcase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\n\t\t\tif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\n\t\t\t    STATUS_LINKLOSS) {\n\t\t\t\tlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogi_dj_recv_forward_report(djrcv_dev, dj_report);\n\t\t}\n\t\treport_processed = true;\n\t}\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\n\treturn report_processed;\n}\n",
      "line_statements": [
        [
          686,
          "\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n"
        ],
        [
          687,
          "\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n"
        ],
        [
          688,
          "\t\tdev_err(&hdev->dev, \"%s: invalid device index:%d\\n\",\n"
        ],
        [
          689,
          "\t\t\t\t__func__, dj_report->device_index);\n"
        ],
        [
          690,
          "\t\treturn false;\n"
        ],
        [
          691,
          "\t}\n"
        ]
      ],
      "statements": [
        [
          686,
          "if ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX))"
        ],
        [
          688,
          "dev_err(&hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t\t__func__, dj_report->device_index);"
        ],
        [
          690,
          "return false;"
        ],
        [
          691,
          "\t}\n"
        ]
      ],
      "cve": "CVE-2014-3182"
    },
    {
      "commit_id": "905ad269c55fc62bee3da29f7b1d1efeba8aa1e1",
      "filepath": "fs/proc/root.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "proc_root_init",
      "func_body": "void __init proc_root_init(void)\n{\n\tint err;\n\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\terr = pid_ns_prepare_proc(&init_pid_ns);\n\tif (err) {\n\t\tunregister_filesystem(&proc_fs_type);\n\t\treturn;\n\t}\n\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\n\tproc_net_init();\n\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); /* somewhere for the nfsd filesystem to be mounted */\n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\t/* just give it a mountpoint */\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n#ifdef CONFIG_PROC_DEVICETREE\n\tproc_device_tree_init();\n#endif\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}",
      "line_statements": [
        [
          100,
          "\terr = pid_ns_prepare_proc(&init_pid_ns);"
        ],
        [
          101,
          "\tif (err) {"
        ]
      ],
      "statements": [
        [
          100,
          "err = pid_ns_prepare_proc(&init_pid_ns);"
        ],
        [
          101,
          "if (err)"
        ]
      ],
      "cve": "CVE-2012-2127"
    },
    {
      "commit_id": "35c94dc6acc418f1ad7f6241a6680e5327495793",
      "filepath": "src/readelf.c",
      "project": "file",
      "project_repo_path": "symbol_backend_projects/file",
      "is_vulnerable": false,
      "func_name": "do_bid_note",
      "func_body": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 && descsz <= 20)) {\n\t\tuint8_t desc[20];\n\t\tconst char *btype;\n\t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
      "line_statements": [
        [
          514,
          "\t    type == NT_GNU_BUILD_ID && (descsz >= 4 && descsz <= 20)) {"
        ]
      ],
      "statements": [
        [
          509,
          "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 && descsz <= 20)) {\n\t\tuint8_t desc[20];"
        ]
      ],
      "cve": "CVE-2017-1000249"
    },
    {
      "commit_id": "f833c53cb596e9e1792949f762e0b33661822748",
      "filepath": "src/aiff.c",
      "project": "libsndfile",
      "project_repo_path": "symbol_backend_projects/libsndfile",
      "is_vulnerable": true,
      "func_name": "aiff_read_chanmap",
      "func_body": "aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\n\tif (bytesread < dword)\n\t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n\n\tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;\n\n\t\tfree (psf->channel_map) ;\n\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\n\treturn 0 ;\n} /* aiff_read_chanmap */",
      "line_statements": [
        [
          1762,
          "\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;"
        ]
      ],
      "statements": [
        [
          1762,
          "\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;\n"
        ]
      ],
      "cve": "CVE-2017-6892"
    },
    {
      "commit_id": "1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b",
      "filepath": "src/cdf.c",
      "project": "file",
      "project_repo_path": "symbol_backend_projects/file",
      "is_vulnerable": true,
      "func_name": "cdf_read_property_info",
      "func_body": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p +\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\", i,\n\t\t    inp[i].pi_id, inp[i].pi_type, q - p,\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %\" SIZE_T_FORMAT\n\t\t\t\t    \"u, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}",
      "line_statements": [
        [
          802,
          "\t\t    ((const char *)(const void *)p +"
        ],
        [
          803,
          "\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);"
        ],
        [
          810,
          "\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\", i,"
        ],
        [
          811,
          "\t\t    inp[i].pi_id, inp[i].pi_type, q - p,"
        ],
        [
          812,
          "\t\t    CDF_GETUINT32(p, (i << 1) + 1)));"
        ]
      ],
      "statements": [
        [
          801,
          "q = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p +\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);"
        ],
        [
          810,
          "DPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\", i,\n\t\t    inp[i].pi_id, inp[i].pi_type, q - p,\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)));"
        ]
      ],
      "cve": "CVE-2012-1571"
    },
    {
      "commit_id": "d325dc6eb763c10f591c239550b8c7e5466a5d09",
      "filepath": "fs/nilfs2/inode.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "nilfs_new_inode",
      "func_body": "struct inode *nilfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_root *root;\n\tint err = -ENOMEM;\n\tino_t ino;\n\n\tinode = new_inode(sb);\n\tif (unlikely(!inode))\n\t\tgoto failed;\n\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t   mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS));\n\n\troot = NILFS_I(dir)->i_root;\n\tii = NILFS_I(inode);\n\tii->i_state = BIT(NILFS_I_NEW);\n\tii->i_root = root;\n\n\terr = nilfs_ifile_create_inode(root->ifile, &ino, &ii->i_bh);\n\tif (unlikely(err))\n\t\tgoto failed_ifile_create_inode;\n\t/* reference count of i_bh inherits from nilfs_mdt_read_block() */\n\n\tatomic64_inc(&root->inodes_count);\n\tinode_init_owner(&init_user_ns, inode, dir, mode);\n\tinode->i_ino = ino;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\n\tif (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, NULL);\n\t\tif (err < 0)\n\t\t\tgoto failed_after_creation;\n\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\n\tii->i_flags = nilfs_mask_flags(\n\t\tmode, NILFS_I(dir)->i_flags & NILFS_FL_INHERITED);\n\n\t/* ii->i_file_acl = 0; */\n\t/* ii->i_dir_acl = 0; */\n\tii->i_dir_start_lookup = 0;\n\tnilfs_set_inode_flags(inode);\n\tspin_lock(&nilfs->ns_next_gen_lock);\n\tinode->i_generation = nilfs->ns_next_generation++;\n\tspin_unlock(&nilfs->ns_next_gen_lock);\n\tif (nilfs_insert_inode_locked(inode, root, ino) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed_after_creation;\n\t}\n\n\terr = nilfs_init_acl(inode, dir);\n\tif (unlikely(err))\n\t\t/*\n\t\t * Never occur.  When supporting nilfs_init_acl(),\n\t\t * proper cancellation of above jobs should be considered.\n\t\t */\n\t\tgoto failed_after_creation;\n\n\treturn inode;\n\n failed_after_creation:\n\tclear_nlink(inode);\n\tif (inode->i_state & I_NEW)\n\t\tunlock_new_inode(inode);\n\tiput(inode);  /*\n\t\t       * raw_inode will be deleted through\n\t\t       * nilfs_evict_inode().\n\t\t       */\n\tgoto failed;\n\n failed_ifile_create_inode:\n\tmake_bad_inode(inode);\n\tiput(inode);\n failed:\n\treturn ERR_PTR(err);\n}\n",
      "line_statements": [
        [
          346,
          "\terr = nilfs_ifile_create_inode(root->ifile, &ino, &ii->i_bh);\n"
        ]
      ],
      "statements": [
        [
          346,
          "err = nilfs_ifile_create_inode(root->ifile, &ino, &ii->i_bh);"
        ]
      ],
      "cve": "CVE-2022-3649"
    },
    {
      "commit_id": "3ed749263abe3d69fa3626d142a5789dcb5a5684",
      "filepath": "src/lib/Libdis/disrsi_.c",
      "project": "torque",
      "project_repo_path": "symbol_backend_projects/torque",
      "is_vulnerable": false,
      "func_name": "disrsi_",
      "func_body": "int disrsi_(\n\n  int       stream,\n  int      *negate,\n  unsigned *value,\n  unsigned  count)\n\n  {\n  int  c;\n  unsigned locval;\n  unsigned ndigs;\n  char  *cp;\n  char  scratch[DIS_BUFSIZ+1];\n\n  assert(negate != NULL);\n  assert(value != NULL);\n  assert(count);\n  assert(stream >= 0);\n  assert(dis_getc != NULL);\n  assert(dis_gets != NULL);\n\n  memset(scratch, 0, DIS_BUFSIZ+1);\n  if (dis_umaxd == 0)\n    disiui_();\n\n  if (count >= dis_umaxd)\n    {\n    if (count > dis_umaxd)\n      goto overflow;\n\n    if (memcmp(scratch, dis_umax, dis_umaxd) > 0)\n      goto overflow;\n    }\n\n  switch (c = (*dis_getc)(stream))\n    {\n\n    case '-':\n\n    case '+':\n\n      *negate = c == '-';\n\n      if ((*dis_gets)(stream, scratch, count) != (int)count)\n        {\n        return(DIS_EOD);\n        }\n\n      if (count >= dis_umaxd)\n        {\n        if (count > dis_umaxd)\n          goto overflow;\n\n        if (memcmp(scratch, dis_umax, dis_umaxd) > 0)\n          goto overflow;\n        }\n\n      cp = scratch;\n\n      locval = 0;\n\n      do\n        {\n        if (((c = *cp++) < '0') || (c > '9'))\n          {\n          return(DIS_NONDIGIT);\n          }\n\n        locval = 10 * locval + c - '0';\n        }\n      while (--count);\n\n      *value = locval;\n\n      return (DIS_SUCCESS);\n\n      break;\n\n    case '0':\n\n      return (DIS_LEADZRO);\n\n      break;\n\n    case '1':\n\n    case '2':\n\n    case '3':\n\n    case '4':\n\n    case '5':\n\n    case '6':\n\n    case '7':\n\n    case '8':\n\n    case '9':\n\n      ndigs = c - '0';\n\n      if (count > 1)\n        {\n        if ((*dis_gets)(stream, scratch + 1, count - 1) != (int)count - 1)\n          {\n          return(DIS_EOD);\n          }\n\n        cp = scratch;\n\n        if (count >= dis_umaxd)\n          {\n          if (count > dis_umaxd)\n            break;\n\n          *cp = c;\n\n          if (memcmp(scratch, dis_umax, dis_umaxd) > 0)\n            break;\n          }\n\n        while (--count)\n          {\n          if (((c = *++cp) < '0') || (c > '9'))\n            {\n            return(DIS_NONDIGIT);\n            }\n\n          ndigs = 10 * ndigs + c - '0';\n          }\n        }    /* END if (count > 1) */\n\n      return(disrsi_(stream, negate, value, ndigs));\n\n      /*NOTREACHED*/\n\n      break;\n\n    case - 1:\n\n      return(DIS_EOD);\n\n      /*NOTREACHED*/\n\n      break;\n\n    case -2:\n\n      return(DIS_EOF);\n\n      /*NOTREACHED*/\n\n      break;\n\n    default:\n\n      return(DIS_NONDIGIT);\n\n      /*NOTREACHED*/\n\n      break;\n    }\n\n  *negate = FALSE;\n\noverflow:\n\n  *value = UINT_MAX;\n\n  return(DIS_OVERFLOW);\n  }  /* END disrsi_() */",
      "line_statements": [
        [
          115,
          "  if (count >= dis_umaxd)"
        ],
        [
          116,
          "    {"
        ],
        [
          117,
          "    if (count > dis_umaxd)"
        ],
        [
          118,
          "      goto overflow;"
        ],
        [
          119,
          ""
        ],
        [
          120,
          "    if (memcmp(scratch, dis_umax, dis_umaxd) > 0)"
        ],
        [
          121,
          "      goto overflow;"
        ],
        [
          122,
          "    }"
        ],
        [
          123,
          ""
        ]
      ],
      "statements": [
        [
          115,
          "if (count >= dis_umaxd)"
        ],
        [
          116,
          "    {\n"
        ],
        [
          117,
          "if (count > dis_umaxd)"
        ],
        [
          118,
          "goto overflow;"
        ],
        [
          119,
          "\n"
        ],
        [
          120,
          "if (memcmp(scratch, dis_umax, dis_umaxd) > 0)"
        ],
        [
          121,
          "goto overflow;"
        ],
        [
          122,
          "    }\n"
        ],
        [
          123,
          "\n"
        ]
      ],
      "cve": "CVE-2014-0749"
    },
    {
      "commit_id": "954e3d2e7113e9ac06632aee3c69b8d818cc8952",
      "filepath": "lib/commonio.c",
      "project": "shadow",
      "project_repo_path": "symbol_backend_projects/shadow",
      "is_vulnerable": true,
      "func_name": "commonio_sort",
      "func_body": "commonio_sort (struct commonio_db *db, int (*cmp) (const void *, const void *))\n{\n\tstruct commonio_entry **entries, *ptr;\n\tsize_t n = 0, i;\n#if KEEP_NIS_AT_END\n\tstruct commonio_entry *nis = NULL;\n#endif\n\n\tfor (ptr = db->head;\n\t        (NULL != ptr)\n#if KEEP_NIS_AT_END\n\t     && (NULL != ptr->line)\n\t     && (   ('+' != ptr->line[0])\n\t         && ('-' != ptr->line[0]))\n#endif\n\t     ;\n\t     ptr = ptr->next) {\n\t\tn++;\n\t}\n#if KEEP_NIS_AT_END\n\tif ((NULL != ptr) && (NULL != ptr->line)) {\n\t\tnis = ptr;\n\t}\n#endif\n\n\tif (n <= 1) {\n\t\treturn 0;\n\t}\n\n\tentries = malloc (n * sizeof (struct commonio_entry *));\n\tif (entries == NULL) {\n\t\treturn -1;\n\t}\n\n\tn = 0;\n\tfor (ptr = db->head;\n#if KEEP_NIS_AT_END\n\t     nis != ptr;\n#else\n\t     NULL != ptr;\n#endif\n/*@ -nullderef @*/\n\t     ptr = ptr->next\n/*@ +nullderef @*/\n\t    ) {\n\t\tentries[n] = ptr;\n\t\tn++;\n\t}\n\tqsort (entries, n, sizeof (struct commonio_entry *), cmp);\n\n\t/* Take care of the head and tail separately */\n\tdb->head = entries[0];\n\tn--;\n#if KEEP_NIS_AT_END\n\tif (NULL == nis)\n#endif\n\t{\n\t\tdb->tail = entries[n];\n\t}\n\tdb->head->prev = NULL;\n\tdb->head->next = entries[1];\n\tentries[n]->prev = entries[n - 1];\n#if KEEP_NIS_AT_END\n\tentries[n]->next = nis;\n#else\n\tentries[n]->next = NULL;\n#endif\n\n\t/* Now other elements have prev and next entries */\n\tfor (i = 1; i < n; i++) {\n\t\tentries[i]->prev = entries[i - 1];\n\t\tentries[i]->next = entries[i + 1];\n\t}\n\n\tfree (entries);\n\tdb->changed = true;\n\n\treturn 0;\n}",
      "line_statements": [
        [
          754,
          "\t     && (NULL != ptr->line)"
        ],
        [
          755,
          "\t     && (   ('+' != ptr->line[0])"
        ],
        [
          756,
          "\t         && ('-' != ptr->line[0]))"
        ],
        [
          763,
          "\tif ((NULL != ptr) && (NULL != ptr->line)) {"
        ]
      ],
      "statements": [
        [
          751,
          "for (ptr = db->head;\n\t        (NULL != ptr)\n#if KEEP_NIS_AT_END\n\t     && (NULL != ptr->line)\n\t     && (   ('+' != ptr->line[0])\n\t         && ('-' != ptr->line[0]))\n#endif\n\t     ;\n\t     ptr = ptr->next)"
        ],
        [
          763,
          "if ((NULL != ptr) && (NULL != ptr->line))"
        ]
      ],
      "cve": "CVE-2017-12424"
    },
    {
      "commit_id": "72794dc3523bbd5bb370de3c5857cb736c387e18",
      "filepath": "libr/bin/p/bin_bflt.c",
      "project": "radare2",
      "project_repo_path": "symbol_backend_projects/radare2",
      "is_vulnerable": false,
      "func_name": "search_old_relocation",
      "func_body": "static int search_old_relocation (struct reloc_struct_t *reloc_table,\n\t\t\t\t  ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
      "line_statements": [
        [
          53,
          "static int search_old_relocation (struct reloc_struct_t *reloc_table,"
        ],
        [
          54,
          "\t\t\t\t  ut32 addr_to_patch, int n_reloc) {"
        ]
      ],
      "statements": [
        [
          53,
          "static int search_old_relocation (struct reloc_struct_t *reloc_table,\n\t\t\t\t  ut32 addr_to_patch, int n_reloc) {"
        ]
      ],
      "cve": "CVE-2017-6194"
    },
    {
      "commit_id": "8aa4bc53206c2430bbf0c8f4b642f59a379ee649",
      "filepath": "common/rfb/CSecurityTLS.cxx",
      "project": "tigervnc",
      "project_repo_path": "symbol_backend_projects/tigervnc",
      "is_vulnerable": false,
      "func_name": "CSecurityTLS::CSecurityTLS",
      "func_body": "CSecurityTLS::CSecurityTLS(bool _anon) : session(0), anon_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  cafile = X509CA.getData();\n  crlfile = X509CRL.getData();\n\n  if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_global_init failed\");\n}",
      "line_statements": [
        [
          75,
          ""
        ],
        [
          76,
          "  if (gnutls_global_init() != GNUTLS_E_SUCCESS)"
        ],
        [
          77,
          "    throw AuthFailureException(\"gnutls_global_init failed\");"
        ]
      ],
      "statements": [
        [
          75,
          "\n"
        ],
        [
          76,
          "if (gnutls_global_init() != GNUTLS_E_SUCCESS)"
        ],
        [
          77,
          "throw AuthFailureException(\"gnutls_global_init failed\");"
        ]
      ],
      "cve": "CVE-2016-10207"
    },
    {
      "commit_id": "c85ce65ecac078ab1a1835c87c4a6319cf74660a",
      "filepath": "drivers/net/wireless/b43/dma.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "dma_rx",
      "func_body": "static void dma_rx(struct b43_dmaring *ring, int *slot)\n{\n\tconst struct b43_dma_ops *ops = ring->ops;\n\tstruct b43_dmadesc_generic *desc;\n\tstruct b43_dmadesc_meta *meta;\n\tstruct b43_rxhdr_fw4 *rxhdr;\n\tstruct sk_buff *skb;\n\tu16 len;\n\tint err;\n\tdma_addr_t dmaaddr;\n\n\tdesc = ops->idx2desc(ring, *slot, &meta);\n\n\tsync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);\n\tskb = meta->skb;\n\n\trxhdr = (struct b43_rxhdr_fw4 *)skb->data;\n\tlen = le16_to_cpu(rxhdr->frame_len);\n\tif (len == 0) {\n\t\tint i = 0;\n\n\t\tdo {\n\t\t\tudelay(2);\n\t\t\tbarrier();\n\t\t\tlen = le16_to_cpu(rxhdr->frame_len);\n\t\t} while (len == 0 && i++ < 5);\n\t\tif (unlikely(len == 0)) {\n\t\t\tdmaaddr = meta->dmaaddr;\n\t\t\tgoto drop_recycle_buffer;\n\t\t}\n\t}\n\tif (unlikely(b43_rx_buffer_is_poisoned(ring, skb))) {\n\t\t/* Something went wrong with the DMA.\n\t\t * The device did not touch the buffer and did not overwrite the poison. */\n\t\tb43dbg(ring->dev->wl, \"DMA RX: Dropping poisoned buffer.\\n\");\n\t\tdmaaddr = meta->dmaaddr;\n\t\tgoto drop_recycle_buffer;\n\t}\n\tif (unlikely(len + ring->frameoffset > ring->rx_buffersize)) {\n\t\t/* The data did not fit into one descriptor buffer\n\t\t * and is split over multiple buffers.\n\t\t * This should never happen, as we try to allocate buffers\n\t\t * big enough. So simply ignore this packet.\n\t\t */\n\t\tint cnt = 0;\n\t\ts32 tmp = len;\n\n\t\twhile (1) {\n\t\t\tdesc = ops->idx2desc(ring, *slot, &meta);\n\t\t\t/* recycle the descriptor buffer. */\n\t\t\tb43_poison_rx_buffer(ring, meta->skb);\n\t\t\tsync_descbuffer_for_device(ring, meta->dmaaddr,\n\t\t\t\t\t\t   ring->rx_buffersize);\n\t\t\t*slot = next_slot(ring, *slot);\n\t\t\tcnt++;\n\t\t\ttmp -= ring->rx_buffersize;\n\t\t\tif (tmp <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tb43err(ring->dev->wl, \"DMA RX buffer too small \"\n\t\t       \"(len: %u, buffer: %u, nr-dropped: %d)\\n\",\n\t\t       len, ring->rx_buffersize, cnt);\n\t\tgoto drop;\n\t}\n\n\tdmaaddr = meta->dmaaddr;\n\terr = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tb43dbg(ring->dev->wl, \"DMA RX: setup_rx_descbuffer() failed\\n\");\n\t\tgoto drop_recycle_buffer;\n\t}\n\n\tunmap_descbuffer(ring, dmaaddr, ring->rx_buffersize, 0);\n\tskb_put(skb, len + ring->frameoffset);\n\tskb_pull(skb, ring->frameoffset);\n\n\tb43_rx(ring->dev, skb, rxhdr);\ndrop:\n\treturn;\n\ndrop_recycle_buffer:\n\t/* Poison and recycle the RX buffer. */\n\tb43_poison_rx_buffer(ring, skb);\n\tsync_descbuffer_for_device(ring, dmaaddr, ring->rx_buffersize);\n}\n",
      "line_statements": [
        [
          1539,
          "\tif (unlikely(len + ring->frameoffset > ring->rx_buffersize)) {\n"
        ]
      ],
      "statements": [
        [
          1539,
          "if (unlikely(len + ring->frameoffset > ring->rx_buffersize))"
        ]
      ],
      "cve": "CVE-2011-3359"
    },
    {
      "commit_id": "b589096f907052b3a4da2b9ccc9b0e2e888dfc18",
      "filepath": "src/network.c",
      "project": "collectd",
      "project_repo_path": "symbol_backend_projects/collectd",
      "is_vulnerable": false,
      "func_name": "parse_packet",
      "func_body": "static int parse_packet (sockent_t *se, /* {{{ */\n\t\tvoid *buffer, size_t buffer_size, int flags,\n\t\tconst char *username)\n{\n\tint status;\n\n\tvalue_list_t vl = VALUE_LIST_INIT;\n\tnotification_t n;\n\n#if HAVE_LIBGCRYPT\n\tint packet_was_signed = (flags & PP_SIGNED);\n        int packet_was_encrypted = (flags & PP_ENCRYPTED);\n\tint printed_ignore_warning = 0;\n#endif /* HAVE_LIBGCRYPT */\n\n\n\tmemset (&vl, '\\0', sizeof (vl));\n\tmemset (&n, '\\0', sizeof (n));\n\tstatus = 0;\n\n\twhile ((status == 0) && (0 < buffer_size)\n\t\t\t&& ((unsigned int) buffer_size > sizeof (part_header_t)))\n\t{\n\t\tuint16_t pkg_length;\n\t\tuint16_t pkg_type;\n\n\t\tmemcpy ((void *) &pkg_type,\n\t\t\t\t(void *) buffer,\n\t\t\t\tsizeof (pkg_type));\n\t\tmemcpy ((void *) &pkg_length,\n\t\t\t\t(void *) (buffer + sizeof (pkg_type)),\n\t\t\t\tsizeof (pkg_length));\n\n\t\tpkg_length = ntohs (pkg_length);\n\t\tpkg_type = ntohs (pkg_type);\n\n\t\tif (pkg_length > buffer_size)\n\t\t\tbreak;\n\t\t/* Ensure that this loop terminates eventually */\n\t\tif (pkg_length < (2 * sizeof (uint16_t)))\n\t\t\tbreak;\n\n\t\tif (pkg_type == TYPE_ENCR_AES256)\n\t\t{\n\t\t\tstatus = parse_part_encr_aes256 (se,\n\t\t\t\t\t&buffer, &buffer_size, flags);\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Decrypting AES256 \"\n\t\t\t\t\t\t\"part failed \"\n\t\t\t\t\t\t\"with status %i.\", status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if HAVE_LIBGCRYPT\n\t\telse if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT)\n\t\t\t\t&& (packet_was_encrypted == 0))\n\t\t{\n\t\t\tif (printed_ignore_warning == 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: Unencrypted packet or \"\n\t\t\t\t\t\t\"part has been ignored.\");\n\t\t\t\tprinted_ignore_warning = 1;\n\t\t\t}\n\t\t\tbuffer = ((char *) buffer) + pkg_length;\n\t\t\tbuffer_size -= (size_t) pkg_length;\n\t\t\tcontinue;\n\t\t}\n#endif /* HAVE_LIBGCRYPT */\n\t\telse if (pkg_type == TYPE_SIGN_SHA256)\n\t\t{\n\t\t\tstatus = parse_part_sign_sha256 (se,\n                                        &buffer, &buffer_size, flags);\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Verifying HMAC-SHA-256 \"\n\t\t\t\t\t\t\"signature failed \"\n\t\t\t\t\t\t\"with status %i.\", status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if HAVE_LIBGCRYPT\n\t\telse if ((se->data.server.security_level == SECURITY_LEVEL_SIGN)\n\t\t\t\t&& (packet_was_encrypted == 0)\n\t\t\t\t&& (packet_was_signed == 0))\n\t\t{\n\t\t\tif (printed_ignore_warning == 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: Unsigned packet or \"\n\t\t\t\t\t\t\"part has been ignored.\");\n\t\t\t\tprinted_ignore_warning = 1;\n\t\t\t}\n\t\t\tbuffer = ((char *) buffer) + pkg_length;\n\t\t\tbuffer_size -= (size_t) pkg_length;\n\t\t\tcontinue;\n\t\t}\n#endif /* HAVE_LIBGCRYPT */\n\t\telse if (pkg_type == TYPE_VALUES)\n\t\t{\n\t\t\tstatus = parse_part_values (&buffer, &buffer_size,\n\t\t\t\t\t&vl.values, &vl.values_len);\n\t\t\tif (status != 0)\n\t\t\t\tbreak;\n\n\t\t\tnetwork_dispatch_values (&vl, username);\n\n\t\t\tsfree (vl.values);\n\t\t}\n\t\telse if (pkg_type == TYPE_TIME)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t{\n\t\t\t\tvl.time = TIME_T_TO_CDTIME_T (tmp);\n\t\t\t\tn.time  = TIME_T_TO_CDTIME_T (tmp);\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_TIME_HR)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t{\n\t\t\t\tvl.time = (cdtime_t) tmp;\n\t\t\t\tn.time  = (cdtime_t) tmp;\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_INTERVAL)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tvl.interval = TIME_T_TO_CDTIME_T (tmp);\n\t\t}\n\t\telse if (pkg_type == TYPE_INTERVAL_HR)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tvl.interval = (cdtime_t) tmp;\n\t\t}\n\t\telse if (pkg_type == TYPE_HOST)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.host, sizeof (vl.host));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.host, vl.host, sizeof (n.host));\n\t\t}\n\t\telse if (pkg_type == TYPE_PLUGIN)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.plugin, sizeof (vl.plugin));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.plugin, vl.plugin,\n\t\t\t\t\t\tsizeof (n.plugin));\n\t\t}\n\t\telse if (pkg_type == TYPE_PLUGIN_INSTANCE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.plugin_instance,\n\t\t\t\t\tsizeof (vl.plugin_instance));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.plugin_instance,\n\t\t\t\t\t\tvl.plugin_instance,\n\t\t\t\t\t\tsizeof (n.plugin_instance));\n\t\t}\n\t\telse if (pkg_type == TYPE_TYPE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.type, sizeof (vl.type));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.type, vl.type, sizeof (n.type));\n\t\t}\n\t\telse if (pkg_type == TYPE_TYPE_INSTANCE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.type_instance,\n\t\t\t\t\tsizeof (vl.type_instance));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.type_instance, vl.type_instance,\n\t\t\t\t\t\tsizeof (n.type_instance));\n\t\t}\n\t\telse if (pkg_type == TYPE_MESSAGE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tn.message, sizeof (n.message));\n\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\t/* do nothing */\n\t\t\t}\n\t\t\telse if ((n.severity != NOTIF_FAILURE)\n\t\t\t\t\t&& (n.severity != NOTIF_WARNING)\n\t\t\t\t\t&& (n.severity != NOTIF_OKAY))\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"unknown severity %i.\",\n\t\t\t\t\t\tn.severity);\n\t\t\t}\n\t\t\telse if (n.time <= 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"time == 0.\");\n\t\t\t}\n\t\t\telse if (strlen (n.message) <= 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"an empty message.\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnetwork_dispatch_notification (&n);\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_SEVERITY)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tn.severity = (int) tmp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDEBUG (\"network plugin: parse_packet: Unknown part\"\n\t\t\t\t\t\" type: 0x%04hx\", pkg_type);\n\t\t\tbuffer = ((char *) buffer) + pkg_length;\n\t\t\tbuffer_size -= (size_t) pkg_length;\n\t\t}\n\t} /* while (buffer_size > sizeof (part_header_t)) */\n\n\tif (status == 0 && buffer_size > 0)\n\t\tWARNING (\"network plugin: parse_packet: Received truncated \"\n\t\t\t\t\"packet, try increasing `MaxPacketSize'\");\n\n\treturn (status);\n} /* }}} int parse_packet */",
      "line_statements": [
        [
          1438,
          "\t\t\tbuffer_size -= (size_t) pkg_length;"
        ],
        [
          1466,
          "\t\t\tbuffer_size -= (size_t) pkg_length;"
        ],
        [
          1608,
          "\t\t\tbuffer_size -= (size_t) pkg_length;"
        ]
      ],
      "statements": [
        [
          1438,
          "buffer_size -= (size_t) pkg_length;"
        ],
        [
          1466,
          "buffer_size -= (size_t) pkg_length;"
        ],
        [
          1608,
          "buffer_size -= (size_t) pkg_length;"
        ]
      ],
      "cve": "CVE-2016-6254"
    },
    {
      "commit_id": "54d83fc74aa9ec72794373cb47432c5f7fb1a309",
      "filepath": "net/ipv4/netfilter/arp_tables.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "unconditional",
      "func_body": "static inline bool unconditional(const struct arpt_arp *arp)\n{\n\tstatic const struct arpt_arp uncond;\n\n\treturn memcmp(arp, &uncond, sizeof(uncond)) == 0;\n}",
      "line_statements": [
        [
          362,
          "static inline bool unconditional(const struct arpt_arp *arp)"
        ],
        [
          366,
          "\treturn memcmp(arp, &uncond, sizeof(uncond)) == 0;"
        ]
      ],
      "statements": [
        [
          362,
          "static inline bool unconditional(const struct arpt_arp *arp)"
        ],
        [
          366,
          "return memcmp(arp, &uncond, sizeof(uncond)) == 0;"
        ]
      ],
      "cve": "CVE-2016-3134"
    }
  ],
  "CWE-20": [
    {
      "commit_id": "9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad",
      "filepath": "libavformat/mxfdec.c",
      "project": "FFmpeg",
      "project_repo_path": "symbol_backend_projects/FFmpeg",
      "is_vulnerable": true,
      "func_name": "mxf_read_primer_pack",
      "func_body": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}",
      "line_statements": [
        [
          503,
          "    if (item_num > 65536) {"
        ]
      ],
      "statements": [
        [
          503,
          "if (item_num > 65536)"
        ]
      ],
      "cve": "CVE-2017-14169"
    },
    {
      "commit_id": "8e75437a7e43d4c55e861691f74892e666e29b0b",
      "filepath": "src/xmpp/message.c",
      "project": "profanity",
      "project_repo_path": "symbol_backend_projects/profanity",
      "is_vulnerable": false,
      "func_name": "_handle_carbons",
      "func_body": "_handle_carbons(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);\n    if (!carbons) {\n        return FALSE;\n    }\n\n    const char *name = xmpp_stanza_get_name(carbons);\n    if (!name) {\n        log_error(\"Unable to retrieve stanza name for Carbon\");\n        return TRUE;\n    }\n\n    if (g_strcmp0(name, \"private\") == 0) {\n        log_info(\"Carbon received with private element.\");\n        return FALSE;\n    }\n\n    if ((g_strcmp0(name, \"received\") != 0) && (g_strcmp0(name, \"sent\") != 0)) {\n        log_warning(\"Carbon received with unrecognised stanza name: %s\", name);\n        return TRUE;\n    }\n\n    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);\n    if (!forwarded) {\n        log_warning(\"Carbon received with no forwarded element\");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\"Carbon received with no message element\");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\"Carbon received with no message.\");\n        return TRUE;\n    }\n\n    Jid *my_jid = jid_create(connection_get_fulljid());\n    const char *const stanza_from = xmpp_stanza_get_from(stanza);\n    Jid *msg_jid = jid_create(stanza_from);\n    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {\n        log_warning(\"Invalid carbon received, from: %s\", stanza_from);\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {\n        sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);\n\n    // else treat as a sent message\n    } else {\n        sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message_txt);\n    xmpp_free(ctx, enc_message);\n\n    jid_destroy(jid_from);\n    jid_destroy(jid_to);\n    jid_destroy(my_jid);\n\n    return TRUE;\n}",
      "line_statements": [
        [
          717,
          "    Jid *my_jid = jid_create(connection_get_fulljid());"
        ],
        [
          718,
          "    const char *const stanza_from = xmpp_stanza_get_from(stanza);"
        ],
        [
          719,
          "    Jid *msg_jid = jid_create(stanza_from);"
        ],
        [
          720,
          "    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {"
        ],
        [
          721,
          "        log_warning(\"Invalid carbon received, from: %s\", stanza_from);"
        ],
        [
          722,
          "        return TRUE;"
        ],
        [
          723,
          "    }"
        ],
        [
          724,
          ""
        ]
      ],
      "statements": [
        [
          717,
          "Jid *my_jid = jid_create(connection_get_fulljid());"
        ],
        [
          718,
          "const char *const stanza_from = xmpp_stanza_get_from(stanza);"
        ],
        [
          719,
          "Jid *msg_jid = jid_create(stanza_from);"
        ],
        [
          720,
          "if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0)"
        ],
        [
          721,
          "log_warning(\"Invalid carbon received, from: %s\", stanza_from);"
        ],
        [
          722,
          "return TRUE;"
        ],
        [
          723,
          "    }\n"
        ],
        [
          724,
          "\n"
        ]
      ],
      "cve": "CVE-2017-5592"
    },
    {
      "commit_id": "241e8f486134793cb0f4a5b0e5817a97883401f5",
      "filepath": "lookup.c",
      "project": "libidn2",
      "project_repo_path": "symbol_backend_projects/libidn2",
      "is_vulnerable": true,
      "func_name": "label",
      "func_body": "label (const uint8_t * src, size_t srclen, uint8_t * dst, size_t * dstlen,\n       int flags)\n{\n  size_t plen;\n  uint32_t *p;\n  int rc;\n  size_t tmpl;\n\n  if (_idn2_ascii_p (src, srclen))\n    {\n      if (flags & IDN2_ALABEL_ROUNDTRIP)\n\t/* FIXME implement this MAY:\n\n\t   If the input to this procedure appears to be an A-label\n\t   (i.e., it starts in \"xn--\", interpreted\n\t   case-insensitively), the lookup application MAY attempt to\n\t   convert it to a U-label, first ensuring that the A-label is\n\t   entirely in lowercase (converting it to lowercase if\n\t   necessary), and apply the tests of Section 5.4 and the\n\t   conversion of Section 5.5 to that form. */\n\treturn IDN2_INVALID_FLAGS;\n\n      if (srclen > IDN2_LABEL_MAX_LENGTH)\n\treturn IDN2_TOO_BIG_LABEL;\n      if (srclen > *dstlen)\n\treturn IDN2_TOO_BIG_DOMAIN;\n\n      memcpy (dst, src, srclen);\n      *dstlen = srclen;\n      return IDN2_OK;\n    }\n\n  rc = _idn2_u8_to_u32_nfc (src, srclen, &p, &plen, flags & IDN2_NFC_INPUT);\n  if (rc != IDN2_OK)\n    return rc;\n\n  if (!(flags & IDN2_TRANSITIONAL))\n    {\n      rc = _idn2_label_test(\n\tTEST_NFC |\n\tTEST_2HYPHEN |\n\tTEST_LEADING_COMBINING |\n\tTEST_DISALLOWED |\n\tTEST_CONTEXTJ_RULE |\n\tTEST_CONTEXTO_WITH_RULE |\n\tTEST_UNASSIGNED | TEST_BIDI |\n\t((flags & IDN2_NONTRANSITIONAL) ? TEST_NONTRANSITIONAL : 0) |\n\t((flags & IDN2_USE_STD3_ASCII_RULES) ? 0 : TEST_ALLOW_STD3_DISALLOWED),\n\tp, plen);\n\n      if (rc != IDN2_OK)\n\t{\n\t  free(p);\n\t  return rc;\n\t}\n    }\n\n  dst[0] = 'x';\n  dst[1] = 'n';\n  dst[2] = '-';\n  dst[3] = '-';\n\n  tmpl = *dstlen - 4;\n  rc = _idn2_punycode_encode (plen, p, &tmpl, (char *) dst + 4);\n  free (p);\n  if (rc != IDN2_OK)\n    return rc;\n\n  *dstlen = 4 + tmpl;\n\n  return IDN2_OK;\n}",
      "line_statements": [
        [
          66,
          "  int rc;"
        ],
        [
          67,
          "  size_t tmpl;"
        ],
        [
          68,
          ""
        ],
        [
          69,
          "  if (_idn2_ascii_p (src, srclen))"
        ],
        [
          70,
          "    {"
        ],
        [
          71,
          "      if (flags & IDN2_ALABEL_ROUNDTRIP)"
        ],
        [
          73,
          ""
        ],
        [
          74,
          "\t   If the input to this procedure appears to be an A-label"
        ],
        [
          75,
          "\t   (i.e., it starts in \"xn--\", interpreted"
        ],
        [
          76,
          "\t   case-insensitively), the lookup application MAY attempt to"
        ],
        [
          77,
          "\t   convert it to a U-label, first ensuring that the A-label is"
        ],
        [
          78,
          "\t   entirely in lowercase (converting it to lowercase if"
        ],
        [
          79,
          "\t   necessary), and apply the tests of Section 5.4 and the"
        ],
        [
          81,
          "\treturn IDN2_INVALID_FLAGS;"
        ],
        [
          95,
          "    return rc;"
        ],
        [
          113,
          "\t  free(p);"
        ],
        [
          114,
          "\t  return rc;"
        ],
        [
          127,
          "    return rc;"
        ],
        [
          131,
          "  return IDN2_OK;"
        ]
      ],
      "statements": [
        [
          61,
          "label (const uint8_t * src, size_t srclen, uint8_t * dst, size_t * dstlen,\n       int flags)\n{\n  size_t plen;\n  uint32_t *p;\n  int rc;\n  size_t tmpl;\n\n  if (_idn2_ascii_p (src, srclen))\n    {\n      if (flags & IDN2_ALABEL_ROUNDTRIP)\n\t/* FIXME implement this MAY:\n\n\t   If the input to this procedure appears to be an A-label\n\t   (i.e., it starts in \"xn--\", interpreted\n\t   case-insensitively), the lookup application MAY attempt to\n\t   convert it to a U-label, first ensuring that the A-label is\n\t   entirely in lowercase (converting it to lowercase if\n\t   necessary), and apply the tests of Section 5.4 and the\n\t   conversion of Section 5.5 to that form. */\n\treturn IDN2_INVALID_FLAGS;\n\n      if (srclen > IDN2_LABEL_MAX_LENGTH)\n\treturn IDN2_TOO_BIG_LABEL;\n      if (srclen > *dstlen)\n\treturn IDN2_TOO_BIG_DOMAIN;\n\n      memcpy (dst, src, srclen);\n      *dstlen = srclen;\n      return IDN2_OK;\n    }\n\n  rc = _idn2_u8_to_u32_nfc (src, srclen, &p, &plen, flags & IDN2_NFC_INPUT);\n  if (rc != IDN2_OK)\n    return rc;\n\n  if (!(flags & IDN2_TRANSITIONAL))\n    {\n      rc = _idn2_label_test(\n\tTEST_NFC |\n\tTEST_2HYPHEN |\n\tTEST_LEADING_COMBINING |\n\tTEST_DISALLOWED |\n\tTEST_CONTEXTJ_RULE |\n\tTEST_CONTEXTO_WITH_RULE |\n\tTEST_UNASSIGNED | TEST_BIDI |\n\t((flags & IDN2_NONTRANSITIONAL) ? TEST_NONTRANSITIONAL : 0) |\n\t((flags & IDN2_USE_STD3_ASCII_RULES) ? 0 : TEST_ALLOW_STD3_DISALLOWED),\n\tp, plen);\n\n      if (rc != IDN2_OK)\n\t{\n\t  free(p);\n\t  return rc;\n\t}\n    }\n\n  dst[0] = 'x';\n  dst[1] = 'n';\n  dst[2] = '-';\n  dst[3] = '-';\n\n  tmpl = *dstlen - 4;\n  rc = _idn2_punycode_encode (plen, p, &tmpl, (char *) dst + 4);\n  free (p);\n  if (rc != IDN2_OK)\n    return rc;\n\n  *dstlen = 4 + tmpl;\n\n  return IDN2_OK;\n}"
        ],
        [
          66,
          "int rc;"
        ],
        [
          67,
          "size_t tmpl;"
        ],
        [
          69,
          "if (_idn2_ascii_p (src, srclen))"
        ],
        [
          70,
          "    {\n"
        ],
        [
          71,
          "if (flags & IDN2_ALABEL_ROUNDTRIP)\n\t/* FIXME implement this MAY:\n\n\t   If the input to this procedure appears to be an A-label\n\t   (i.e., it starts in \"xn--\", interpreted\n\t   case-insensitively), the lookup application MAY attempt to\n\t   convert it to a U-label, first ensuring that the A-label is\n\t   entirely in lowercase (converting it to lowercase if\n\t   necessary), and apply the tests of Section 5.4 and the\n\t   conversion of Section 5.5 to that form. */"
        ],
        [
          72,
          "/* FIXME implement this MAY:\n\n\t   If the input to this procedure appears to be an A-label\n\t   (i.e., it starts in \"xn--\", interpreted\n\t   case-insensitively), the lookup application MAY attempt to\n\t   convert it to a U-label, first ensuring that the A-label is\n\t   entirely in lowercase (converting it to lowercase if\n\t   necessary), and apply the tests of Section 5.4 and the\n\t   conversion of Section 5.5 to that form. */"
        ],
        [
          81,
          "return IDN2_INVALID_FLAGS;"
        ],
        [
          95,
          "return rc;"
        ],
        [
          113,
          "free(p);"
        ],
        [
          114,
          "return rc;"
        ],
        [
          127,
          "return rc;"
        ],
        [
          131,
          "return IDN2_OK;"
        ]
      ],
      "cve": "CVE-2019-12290"
    },
    {
      "commit_id": "d9cd01ede97f4145af9781d448c62a3318952719",
      "filepath": "memcached.c",
      "project": "memcached",
      "project_repo_path": "symbol_backend_projects/memcached",
      "is_vulnerable": false,
      "func_name": "try_read_command",
      "func_body": "static int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                int ii;\n                fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n                for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                    if (ii % 4 == 0) {\n                        fprintf(stderr, \"\\n<%d   \", c->sfd);\n                    }\n                    fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid magic:  %x\\n\",\n                            c->binary_header.request.magic);\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont;\n\n        if (c->rbytes == 0)\n            return 0;\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                    ++ptr;\n                }\n\n                if (ptr - c->rcurr > 100 ||\n                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n\n                    conn_set_state(c, conn_closing);\n                    return 1;\n                }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        process_command(c, c->rcurr);\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}",
      "line_statements": [
        [
          3151,
          "                if (ptr - c->rcurr > 100 ||"
        ],
        [
          3152,
          "                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {"
        ],
        [
          3153,
          ""
        ]
      ],
      "statements": [
        [
          3151,
          "if (ptr - c->rcurr > 100 ||\n                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5)))"
        ],
        [
          3153,
          "\n"
        ]
      ],
      "cve": "CVE-2010-1152"
    },
    {
      "commit_id": "6058483d9fbc1b904d5ae7cfea47bfcde5c5b559",
      "filepath": "src/dns.cpp",
      "project": "inspircd",
      "project_repo_path": "symbol_backend_projects/inspircd",
      "is_vulnerable": false,
      "func_name": "DNS::GetResult",
      "func_body": "DNSResult DNS::GetResult()\n{\n\t/* Fetch dns query response and decide where it belongs */\n\tDNSHeader header;\n\tDNSRequest *req;\n\tunsigned char buffer[sizeof(DNSHeader)];\n\tirc::sockets::sockaddrs from;\n\tmemset(&from, 0, sizeof(from));\n\tsocklen_t x = sizeof(from);\n\n\tint length = ServerInstance->SE->RecvFrom(this, (char*)buffer, sizeof(DNSHeader), 0, &from.sa, &x);\n\n\t/* Did we get the whole header? */\n\tif (length < 12)\n\t{\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"GetResult didn't get a full packet (len=%d)\", length);\n\t\t/* Nope - something screwed up. */\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\n\t/* Check wether the reply came from a different DNS\n\t * server to the one we sent it to, or the source-port\n\t * is not 53.\n\t * A user could in theory still spoof dns packets anyway\n\t * but this is less trivial than just sending garbage\n\t * to the server, which is possible without this check.\n\t *\n\t * -- Thanks jilles for pointing this one out.\n\t */\n\tif (from != myserver)\n\t{\n\t\tstd::string server1 = from.str();\n\t\tstd::string server2 = myserver.str();\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Got a result from the wrong server! Bad NAT or DNS forging attempt? '%s' != '%s'\",\n\t\t\tserver1.c_str(), server2.c_str());\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\n\t/* Put the read header info into a header class */\n\tDNS::FillHeader(&header,buffer,length - 12);\n\n\t/* Get the id of this request.\n\t * Its a 16 bit value stored in two char's,\n\t * so we use logic shifts to create the value.\n\t */\n\tunsigned long this_id = header.id[1] + (header.id[0] << 8);\n\n\t/* Do we have a pending request matching this id? */\n\tif (!requests[this_id])\n\t{\n\t\t/* Somehow we got a DNS response for a request we never made... */\n\t\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Hmm, got a result that we didn't ask for (id=%lx). Ignoring.\", this_id);\n\t\treturn DNSResult(-1,\"\",0,\"\");\n\t}\n\telse\n\t{\n\t\t/* Remove the query from the list of pending queries */\n\t\treq = requests[this_id];\n\t\trequests[this_id] = NULL;\n\t}\n\n\t/* Inform the DNSRequest class that it has a result to be read.\n\t * When its finished it will return a DNSInfo which is a pair of\n\t * unsigned char* resource record data, and an error message.\n\t */\n\tDNSInfo data = req->ResultIsReady(header, length);\n\tstd::string resultstr;\n\n\t/* Check if we got a result, if we didnt, its an error */\n\tif (data.first == NULL)\n\t{\n\t\t/* An error.\n\t\t * Mask the ID with the value of ERROR_MASK, so that\n\t\t * the dns_deal_with_classes() function knows that its\n\t\t * an error response and needs to be treated uniquely.\n\t\t * Put the error message in the second field.\n\t\t */\n\t\tstd::string ro = req->orig;\n\t\tdelete req;\n\t\treturn DNSResult(this_id | ERROR_MASK, data.second, 0, ro);\n\t}\n\telse\n\t{\n\t\tunsigned long ttl = req->ttl;\n\t\tchar formatted[128];\n\n\t\t/* Forward lookups come back as binary data. We must format them into ascii */\n\t\tswitch (req->type)\n\t\t{\n\t\t\tcase DNS_QUERY_A:\n\t\t\t\tsnprintf(formatted,16,\"%u.%u.%u.%u\",data.first[0],data.first[1],data.first[2],data.first[3]);\n\t\t\t\tresultstr = formatted;\n\t\t\tbreak;\n\n\t\t\tcase DNS_QUERY_AAAA:\n\t\t\t{\n\t\t\t\tif (!inet_ntop(AF_INET6, data.first, formatted, sizeof(formatted)))\n\t\t\t\t{\n\t\t\t\t\tstd::string ro = req->orig;\n\t\t\t\t\tdelete req;\n\t\t\t\t\treturn DNSResult(this_id | ERROR_MASK, \"inet_ntop() failed\", 0, ro);\n\t\t\t\t}\n\n\t\t\t\tresultstr = formatted;\n\n\t\t\t\t/* Special case. Sending ::1 around between servers\n\t\t\t\t * and to clients is dangerous, because the : on the\n\t\t\t\t * start makes the client or server interpret the IP\n\t\t\t\t * as the last parameter on the line with a value \":1\".\n\t\t\t\t */\n\t\t\t\tif (*formatted == ':')\n\t\t\t\t\tresultstr.insert(0, \"0\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase DNS_QUERY_CNAME:\n\t\t\t\t/* Identical handling to PTR */\n\n\t\t\tcase DNS_QUERY_PTR:\n\t\t\t{\n\t\t\t\t/* Reverse lookups just come back as char* */\n\t\t\t\tresultstr = std::string((const char*)data.first);\n\t\t\t\tif (resultstr.find_first_not_of(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-\") != std::string::npos)\n\t\t\t\t{\n\t\t\t\t\tstd::string ro = req->orig;\n\t\t\t\t\tdelete req;\n\t\t\t\t\treturn DNSResult(this_id | ERROR_MASK, \"Invalid char(s) in reply\", 0, ro);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Build the reply with the id and hostname/ip in it */\n\t\tstd::string ro = req->orig;\n\t\tDNSResult result = DNSResult(this_id,resultstr,ttl,ro,req->type);\n\t\tdelete req;\n\t\treturn result;\n\t}\n}",
      "line_statements": [
        [
          703,
          "\t\t\t{"
        ],
        [
          706,
          "\t\t\t\tif (resultstr.find_first_not_of(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-\") != std::string::npos)"
        ],
        [
          707,
          "\t\t\t\t{"
        ],
        [
          708,
          "\t\t\t\t\tstd::string ro = req->orig;"
        ],
        [
          709,
          "\t\t\t\t\tdelete req;"
        ],
        [
          710,
          "\t\t\t\t\treturn DNSResult(this_id | ERROR_MASK, \"Invalid char(s) in reply\", 0, ro);"
        ],
        [
          711,
          "\t\t\t\t}"
        ],
        [
          712,
          "\t\t\t}"
        ]
      ],
      "statements": [
        [
          703,
          "\t\t\t{\n"
        ],
        [
          706,
          "if (resultstr.find_first_not_of(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-\") != std::string::npos)"
        ],
        [
          707,
          "\t\t\t\t{\n"
        ],
        [
          708,
          "std::string ro = req->orig;"
        ],
        [
          709,
          "delete req;"
        ],
        [
          710,
          "return DNSResult(this_id | ERROR_MASK, \"Invalid char(s) in reply\", 0, ro);"
        ],
        [
          711,
          "\t\t\t\t}\n"
        ],
        [
          712,
          "\t\t\t}\n"
        ]
      ],
      "cve": "CVE-2015-8702"
    },
    {
      "commit_id": "445c8fb0ebff85195be94cd9f7e1df89cade5c7f",
      "filepath": "src/readelf.c",
      "project": "file",
      "project_repo_path": "symbol_backend_projects/file",
      "is_vulnerable": true,
      "func_name": "dophn_exec",
      "func_body": "dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int *flags, int sh_num)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tconst char *linking_style = \"statically\";\n\tconst char *interp = \"\";\n\tunsigned char nbuf[BUFSIZ];\n\tchar ibuf[BUFSIZ];\n\tssize_t bufsize;\n\tsize_t offset, align, len;\n\t\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n  \tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff += size;\n\t\tbufsize = 0;\n\t\talign = 4;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_DYNAMIC:\n\t\t\tlinking_style = \"dynamically\";\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\tif (sh_num)\t/* Did this through section headers */\n\t\t\t\tcontinue;\n\t\t\tif (((align = xph_align) & 0x80000000UL) != 0 ||\n\t\t\t    align < 4) {\n\t\t\t\tif (file_printf(ms, \n\t\t\t\t    \", invalid note alignment 0x%lx\",\n\t\t\t\t    (unsigned long)align) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\talign = 4;\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tcase PT_INTERP:\n\t\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz\n\t\t\t    : sizeof(nbuf);\n\t\t\tbufsize = pread(fd, nbuf, len, xph_offset);\n\t\t\tif (bufsize == -1) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t\t/* Maybe warn here? */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_INTERP:\n\t\t\tif (bufsize && nbuf[0]) {\n\t\t\t\tnbuf[bufsize - 1] = '\\0';\n\t\t\t\tinterp = (const char *)nbuf;\n\t\t\t} else\n\t\t\t\tinterp = \"*empty*\";\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\t/*\n\t\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t\t * in the section.\n\t\t\t */\n\t\t\toffset = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\t\tbreak;\n\t\t\t\toffset = donote(ms, nbuf, offset,\n\t\t\t\t    (size_t)bufsize, clazz, swap, align,\n\t\t\t\t    flags);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (file_printf(ms, \", %s linked\", linking_style)\n\t    == -1)\n\t\treturn -1;\n\tif (interp[0])\n\t\tif (file_printf(ms, \", interpreter %s\",\n\t\t    file_printable(ibuf, sizeof(ibuf), interp)) == -1)\n\t\t\treturn -1;\n\treturn 0;\n}",
      "line_statements": [
        [
          1181,
          "\t\tif (pread(fd, xph_addr, xph_sizeof, off) == -1) {"
        ]
      ],
      "statements": [
        [
          1181,
          "if (pread(fd, xph_addr, xph_sizeof, off) == -1)"
        ]
      ],
      "cve": "CVE-2014-9653"
    },
    {
      "commit_id": "d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7",
      "filepath": "libarchive/archive_read_support_format_zip.c",
      "project": "libarchive",
      "project_repo_path": "symbol_backend_projects/libarchive",
      "is_vulnerable": false,
      "func_name": "zip_read_mac_metadata",
      "func_body": "zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,\n    struct zip_entry *rsrc)\n{\n\tstruct zip *zip = (struct zip *)a->format->data;\n\tunsigned char *metadata, *mp;\n\tint64_t offset = archive_filter_bytes(&a->archive, 0);\n\tsize_t remaining_bytes, metadata_bytes;\n\tssize_t hsize;\n\tint ret = ARCHIVE_OK, eof;\n\n\tswitch(rsrc->compression) {\n\tcase 0:  /* No compression. */\n\t\tif (rsrc->uncompressed_size != rsrc->compressed_size) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Malformed OS X metadata entry: inconsistent size\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n#ifdef HAVE_ZLIB_H\n\tcase 8: /* Deflate compression. */\n#endif\n\t\tbreak;\n\tdefault: /* Unsupported compression. */\n\t\t/* Return a warning. */\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unsupported ZIP compression method (%s)\",\n\t\t    compression_name(rsrc->compression));\n\t\t/* We can't decompress this entry, but we will\n\t\t * be able to skip() it and try the next entry. */\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tif (rsrc->uncompressed_size > (4 * 1024 * 1024)) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Mac metadata is too large: %jd > 4M bytes\",\n\t\t    (intmax_t)rsrc->uncompressed_size);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tif (rsrc->compressed_size > (4 * 1024 * 1024)) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Mac metadata is too large: %jd > 4M bytes\",\n\t\t    (intmax_t)rsrc->compressed_size);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tmetadata = malloc((size_t)rsrc->uncompressed_size);\n\tif (metadata == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for Mac metadata\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (offset < rsrc->local_header_offset)\n\t\t__archive_read_consume(a, rsrc->local_header_offset - offset);\n\telse if (offset != rsrc->local_header_offset) {\n\t\t__archive_read_seek(a, rsrc->local_header_offset, SEEK_SET);\n\t}\n\n\thsize = zip_get_local_file_header_size(a, 0);\n\t__archive_read_consume(a, hsize);\n\n\tremaining_bytes = (size_t)rsrc->compressed_size;\n\tmetadata_bytes = (size_t)rsrc->uncompressed_size;\n\tmp = metadata;\n\teof = 0;\n\twhile (!eof && remaining_bytes) {\n\t\tconst unsigned char *p;\n\t\tssize_t bytes_avail;\n\t\tsize_t bytes_used;\n\n\t\tp = __archive_read_ahead(a, 1, &bytes_avail);\n\t\tif (p == NULL) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated ZIP file header\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t\tgoto exit_mac_metadata;\n\t\t}\n\t\tif ((size_t)bytes_avail > remaining_bytes)\n\t\t\tbytes_avail = remaining_bytes;\n\t\tswitch(rsrc->compression) {\n\t\tcase 0:  /* No compression. */\n\t\t\tif ((size_t)bytes_avail > metadata_bytes)\n\t\t\t\tbytes_avail = metadata_bytes;\n\t\t\tmemcpy(mp, p, bytes_avail);\n\t\t\tbytes_used = (size_t)bytes_avail;\n\t\t\tmetadata_bytes -= bytes_used;\n\t\t\tmp += bytes_used;\n\t\t\tif (metadata_bytes == 0)\n\t\t\t\teof = 1;\n\t\t\tbreak;\n#ifdef HAVE_ZLIB_H\n\t\tcase 8: /* Deflate compression. */\n\t\t{\n\t\t\tint r;\n\n\t\t\tret = zip_deflate_init(a, zip);\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\tgoto exit_mac_metadata;\n\t\t\tzip->stream.next_in =\n\t\t\t    (Bytef *)(uintptr_t)(const void *)p;\n\t\t\tzip->stream.avail_in = (uInt)bytes_avail;\n\t\t\tzip->stream.total_in = 0;\n\t\t\tzip->stream.next_out = mp;\n\t\t\tzip->stream.avail_out = (uInt)metadata_bytes;\n\t\t\tzip->stream.total_out = 0;\n\n\t\t\tr = inflate(&zip->stream, 0);\n\t\t\tswitch (r) {\n\t\t\tcase Z_OK:\n\t\t\t\tbreak;\n\t\t\tcase Z_STREAM_END:\n\t\t\t\teof = 1;\n\t\t\t\tbreak;\n\t\t\tcase Z_MEM_ERROR:\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Out of memory for ZIP decompression\");\n\t\t\t\tret = ARCHIVE_FATAL;\n\t\t\t\tgoto exit_mac_metadata;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"ZIP decompression failed (%d)\", r);\n\t\t\t\tret = ARCHIVE_FATAL;\n\t\t\t\tgoto exit_mac_metadata;\n\t\t\t}\n\t\t\tbytes_used = zip->stream.total_in;\n\t\t\tmetadata_bytes -= zip->stream.total_out;\n\t\t\tmp += zip->stream.total_out;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbytes_used = 0;\n\t\t\tbreak;\n\t\t}\n\t\t__archive_read_consume(a, bytes_used);\n\t\tremaining_bytes -= bytes_used;\n\t}\n\tarchive_entry_copy_mac_metadata(entry, metadata,\n\t    (size_t)rsrc->uncompressed_size - metadata_bytes);\n\nexit_mac_metadata:\n\t__archive_read_seek(a, offset, SEEK_SET);\n\tzip->decompress_init = 0;\n\tfree(metadata);\n\treturn (ret);\n}",
      "line_statements": [
        [
          2781,
          "\t\tif (rsrc->uncompressed_size != rsrc->compressed_size) {"
        ],
        [
          2782,
          "\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"
        ],
        [
          2783,
          "\t\t\t    \"Malformed OS X metadata entry: inconsistent size\");"
        ],
        [
          2784,
          "\t\t\treturn (ARCHIVE_FATAL);"
        ],
        [
          2785,
          "\t\t}"
        ],
        [
          2806,
          "\tif (rsrc->compressed_size > (4 * 1024 * 1024)) {"
        ],
        [
          2807,
          "\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"
        ],
        [
          2808,
          "\t\t    \"Mac metadata is too large: %jd > 4M bytes\","
        ],
        [
          2809,
          "\t\t    (intmax_t)rsrc->compressed_size);"
        ],
        [
          2810,
          "\t\treturn (ARCHIVE_WARN);"
        ],
        [
          2811,
          "\t}"
        ],
        [
          2850,
          "\t\t\tif ((size_t)bytes_avail > metadata_bytes)"
        ],
        [
          2851,
          "\t\t\t\tbytes_avail = metadata_bytes;"
        ]
      ],
      "statements": [
        [
          2781,
          "if (rsrc->uncompressed_size != rsrc->compressed_size)"
        ],
        [
          2782,
          "archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Malformed OS X metadata entry: inconsistent size\");"
        ],
        [
          2784,
          "return (ARCHIVE_FATAL);"
        ],
        [
          2785,
          "\t\t}\n"
        ],
        [
          2806,
          "if (rsrc->compressed_size > (4 * 1024 * 1024))"
        ],
        [
          2807,
          "archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Mac metadata is too large: %jd > 4M bytes\",\n\t\t    (intmax_t)rsrc->compressed_size);"
        ],
        [
          2810,
          "return (ARCHIVE_WARN);"
        ],
        [
          2811,
          "\t}\n"
        ],
        [
          2850,
          "if ((size_t)bytes_avail > metadata_bytes)"
        ],
        [
          2851,
          "bytes_avail = metadata_bytes;"
        ]
      ],
      "cve": "CVE-2016-1541"
    },
    {
      "commit_id": "71bb99a02b32b4cc4265118e85f6035ca72923f0",
      "filepath": "net/bluetooth/bnep/core.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "bnep_add_connection",
      "func_body": "int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)\n{\n\tstruct net_device *dev;\n\tstruct bnep_session *s, *ss;\n\tu8 dst[ETH_ALEN], src[ETH_ALEN];\n\tint err;\n\n\tBT_DBG(\"\");\n\n\tbaswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);\n\tbaswap((void *) src, &l2cap_pi(sock->sk)->chan->src);\n\n\t/* session struct allocated as private part of net_device */\n\tdev = alloc_netdev(sizeof(struct bnep_session),\n\t\t\t   (*req->device) ? req->device : \"bnep%d\",\n\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t   bnep_net_setup);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdown_write(&bnep_session_sem);\n\n\tss = __bnep_get_session(dst);\n\tif (ss && ss->state == BT_CONNECTED) {\n\t\terr = -EEXIST;\n\t\tgoto failed;\n\t}\n\n\ts = netdev_priv(dev);\n\n\t/* This is rx header therefore addresses are swapped.\n\t * ie. eh.h_dest is our local address. */\n\tmemcpy(s->eh.h_dest,   &src, ETH_ALEN);\n\tmemcpy(s->eh.h_source, &dst, ETH_ALEN);\n\tmemcpy(dev->dev_addr, s->eh.h_dest, ETH_ALEN);\n\n\ts->dev   = dev;\n\ts->sock  = sock;\n\ts->role  = req->role;\n\ts->state = BT_CONNECTED;\n\n\ts->msg.msg_flags = MSG_NOSIGNAL;\n\n// #ifdef CONFIG_BT_BNEP_MC_FILTER\n\t/* Set default mc filter */\n\tset_bit(bnep_mc_hash(dev->broadcast), (ulong *) &s->mc_filter);\n#endif\n\n// #ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\t/* Set default protocol filter */\n\tbnep_set_default_proto_filter(s);\n#endif\n\n\tSET_NETDEV_DEV(dev, bnep_get_device(s));\n\tSET_NETDEV_DEVTYPE(dev, &bnep_type);\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto failed;\n\n\t__bnep_link_session(s);\n\n\t__module_get(THIS_MODULE);\n\ts->task = kthread_run(bnep_session, s, \"kbnepd %s\", dev->name);\n\tif (IS_ERR(s->task)) {\n\t\t/* Session thread start failed, gotta cleanup. */\n\t\tmodule_put(THIS_MODULE);\n\t\tunregister_netdev(dev);\n\t\t__bnep_unlink_session(s);\n\t\terr = PTR_ERR(s->task);\n\t\tgoto failed;\n\t}\n\n\tup_write(&bnep_session_sem);\n\tstrcpy(req->device, dev->name);\n\treturn 0;\n\nfailed:\n\tup_write(&bnep_session_sem);\n\tfree_netdev(dev);\n\treturn err;\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2017-15868"
    },
    {
      "commit_id": "f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
      "filepath": "crypto/algif_hash.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "hash_recvmsg",
      "func_body": "static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\tint err;\n\n\tif (len > ds)\n\t\tlen = ds;\n\telse if (len < ds)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\tlock_sock(sk);\n\tif (ctx->more) {\n\t\tctx->more = 0;\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = memcpy_toiovec(msg->msg_iov, ctx->result, len);\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: len;\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2013-7270"
    },
    {
      "commit_id": "eb178619f930fa2ba2348de332a1ff1c66a31424",
      "filepath": "fs/xfs/xfs_buf.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "_xfs_buf_find",
      "func_body": "xfs_buf_t *\n_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent;\n\txfs_buf_t\t\t*bp;\n\txfs_daddr_t\t\tblkno = map[0].bm_bn;\n\tint\t\t\tnumblks = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n\tASSERT(!(numbytes < (1 << btp->bt_sshift)));\n\tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));\n\n\t/* get tree root */\n\tpag = xfs_perag_get(btp->bt_mount,\n\t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2013-1819"
    },
    {
      "commit_id": "4e2024624e678f0ebb916e6192bd23c1f9fdf696",
      "filepath": "fs/isofs/rock.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "parse_rock_ridge_inode_internal",
      "func_body": "static int\nparse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int flags)\n{\n\tint symlink_len = 0;\n\tint cnt, sig;\n\tunsigned int reloc_block;\n\tstruct inode *reloc;\n\tstruct rock_ridge *rr;\n\tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\n\tif (flags & RR_REGARD_XA) {\n\t\trs.chr += 14;\n\t\trs.len -= 14;\n\t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n// #ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\t/* Invalid length of ER tag id? */\n\t\t\tif (rr->u.ER.len_id + offsetof(struct rock_ridge, u.ER.data) > rr->len)\n\t\t\t\tgoto out;\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n\t\t\t\t\t\"relocated directory\\n\");\n\t\t\tgoto out;\n\t\tcase SIG('C', 'L'):\n\t\t\tif (flags & RR_RELOC_DE) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n\t\t\t\t       \"is not supported\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\treloc_block = isonum_733(rr->u.CL.location);\n\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Directory relocation points to \"\n\t\t\t\t       \"itself\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n\t\t\tif (IS_ERR(reloc)) {\n\t\t\t\tret = PTR_ERR(reloc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n// #ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n",
      "line_statements": [
        [
          365,
          "\t\t\t/* Invalid length of ER tag id? */\n"
        ],
        [
          366,
          "\t\t\tif (rr->u.ER.len_id + offsetof(struct rock_ridge, u.ER.data) > rr->len)\n"
        ],
        [
          367,
          "\t\t\t\tgoto out;\n"
        ]
      ],
      "statements": [
        [
          365,
          "/* Invalid length of ER tag id? */"
        ],
        [
          366,
          "if (rr->u.ER.len_id + offsetof(struct rock_ridge, u.ER.data) > rr->len)"
        ],
        [
          367,
          "goto out;"
        ]
      ],
      "cve": "CVE-2014-9584"
    },
    {
      "commit_id": "11f3710417d026ea2f4fcf362d866342c5274185",
      "filepath": "fs/overlayfs/dir.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "ovl_rename2",
      "func_body": "static int ovl_rename2(struct inode *olddir, struct dentry *old,\n\t\t       struct inode *newdir, struct dentry *new,\n\t\t       unsigned int flags)\n{\n\tint err;\n\tenum ovl_path_type old_type;\n\tenum ovl_path_type new_type;\n\tstruct dentry *old_upperdir;\n\tstruct dentry *new_upperdir;\n\tstruct dentry *olddentry;\n\tstruct dentry *newdentry;\n\tstruct dentry *trap;\n\tbool old_opaque;\n\tbool new_opaque;\n\tbool new_create = false;\n\tbool cleanup_whiteout = false;\n\tbool overwrite = !(flags & RENAME_EXCHANGE);\n\tbool is_dir = d_is_dir(old);\n\tbool new_is_dir = false;\n\tstruct dentry *opaquedir = NULL;\n\tconst struct cred *old_cred = NULL;\n\tstruct cred *override_cred = NULL;\n\n\terr = -EINVAL;\n\tif (flags & ~(RENAME_EXCHANGE | RENAME_NOREPLACE))\n\t\tgoto out;\n\n\tflags &= ~RENAME_NOREPLACE;\n\n\terr = ovl_check_sticky(old);\n\tif (err)\n\t\tgoto out;\n\n\t/* Don't copy up directory trees */\n\told_type = ovl_path_type(old);\n\terr = -EXDEV;\n\tif (OVL_TYPE_MERGE_OR_LOWER(old_type) && is_dir)\n\t\tgoto out;\n\n\tif (new->d_inode) {\n\t\terr = ovl_check_sticky(new);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (d_is_dir(new))\n\t\t\tnew_is_dir = true;\n\n\t\tnew_type = ovl_path_type(new);\n\t\terr = -EXDEV;\n\t\tif (!overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir)\n\t\t\tgoto out;\n\n\t\terr = 0;\n\t\tif (!OVL_TYPE_UPPER(new_type) && !OVL_TYPE_UPPER(old_type)) {\n\t\t\tif (ovl_dentry_lower(old)->d_inode ==\n\t\t\t    ovl_dentry_lower(new)->d_inode)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (OVL_TYPE_UPPER(new_type) && OVL_TYPE_UPPER(old_type)) {\n\t\t\tif (ovl_dentry_upper(old)->d_inode ==\n\t\t\t    ovl_dentry_upper(new)->d_inode)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (ovl_dentry_is_opaque(new))\n\t\t\tnew_type = __OVL_PATH_UPPER;\n\t\telse\n\t\t\tnew_type = __OVL_PATH_UPPER | __OVL_PATH_PURE;\n\t}\n\n\terr = ovl_want_write(old);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\terr = ovl_copy_up(new->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\tif (!overwrite) {\n\t\terr = ovl_copy_up(new);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\t}\n\n\told_opaque = !OVL_TYPE_PURE_UPPER(old_type);\n\tnew_opaque = !OVL_TYPE_PURE_UPPER(new_type);\n\n\tif (old_opaque || new_opaque) {\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\t}\n\n\tif (overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir) {\n\t\topaquedir = ovl_check_empty_and_clear(new);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir)) {\n\t\t\topaquedir = NULL;\n\t\t\tgoto out_revert_creds;\n\t\t}\n\t}\n\n\tif (overwrite) {\n\t\tif (old_opaque) {\n\t\t\tif (new->d_inode || !new_opaque) {\n\t\t\t\t/* Whiteout source */\n\t\t\t\tflags |= RENAME_WHITEOUT;\n\t\t\t} else {\n\t\t\t\t/* Switch whiteouts */\n\t\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\t}\n\t\t} else if (is_dir && !new->d_inode && new_opaque) {\n\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\tcleanup_whiteout = true;\n\t\t}\n\t}\n\n\told_upperdir = ovl_dentry_upper(old->d_parent);\n\tnew_upperdir = ovl_dentry_upper(new->d_parent);\n\n\ttrap = lock_rename(new_upperdir, old_upperdir);\n\n\n\tolddentry = lookup_one_len(old->d_name.name, old_upperdir,\n\t\t\t\t   old->d_name.len);\n\terr = PTR_ERR(olddentry);\n\tif (IS_ERR(olddentry))\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (olddentry != ovl_dentry_upper(old))\n\t\tgoto out_dput_old;\n\n\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,\n\t\t\t\t   new->d_name.len);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_dput_old;\n\n\terr = -ESTALE;\n\tif (ovl_dentry_upper(new)) {\n\t\tif (opaquedir) {\n\t\t\tif (newdentry != opaquedir)\n\t\t\t\tgoto out_dput;\n\t\t} else {\n\t\t\tif (newdentry != ovl_dentry_upper(new))\n\t\t\t\tgoto out_dput;\n\t\t}\n\t} else {\n\t\tnew_create = true;\n\t\tif (!d_is_negative(newdentry) &&\n\t\t    (!new_opaque || !ovl_is_whiteout(newdentry)))\n\t\t\tgoto out_dput;\n\t}\n\n\tif (olddentry == trap)\n\t\tgoto out_dput;\n\tif (newdentry == trap)\n\t\tgoto out_dput;\n\n\tif (is_dir && !old_opaque && new_opaque) {\n\t\terr = ovl_set_opaque(olddentry);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\tif (!overwrite && new_is_dir && old_opaque && !new_opaque) {\n\t\terr = ovl_set_opaque(newdentry);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\n\tif (old_opaque || new_opaque) {\n\t\terr = ovl_do_rename(old_upperdir->d_inode, olddentry,\n\t\t\t\t    new_upperdir->d_inode, newdentry,\n\t\t\t\t    flags);\n\t} else {\n\t\t/* No debug for the plain case */\n\t\tBUG_ON(flags & ~RENAME_EXCHANGE);\n\t\terr = vfs_rename(old_upperdir->d_inode, olddentry,\n\t\t\t\t new_upperdir->d_inode, newdentry,\n\t\t\t\t NULL, flags);\n\t}\n\n\tif (err) {\n\t\tif (is_dir && !old_opaque && new_opaque)\n\t\t\tovl_remove_opaque(olddentry);\n\t\tif (!overwrite && new_is_dir && old_opaque && !new_opaque)\n\t\t\tovl_remove_opaque(newdentry);\n\t\tgoto out_dput;\n\t}\n\n\tif (is_dir && old_opaque && !new_opaque)\n\t\tovl_remove_opaque(olddentry);\n\tif (!overwrite && new_is_dir && !old_opaque && new_opaque)\n\t\tovl_remove_opaque(newdentry);\n\n\t/*\n\t * Old dentry now lives in different location. Dentries in\n\t * lowerstack are stale. We cannot drop them here because\n\t * access to them is lockless. This could be only pure upper\n\t * or opaque directory - numlower is zero. Or upper non-dir\n\t * entry - its pureness is tracked by flag opaque.\n\t */\n\tif (old_opaque != new_opaque) {\n\t\tovl_dentry_set_opaque(old, new_opaque);\n\t\tif (!overwrite)\n\t\t\tovl_dentry_set_opaque(new, old_opaque);\n\t}\n\n\tif (cleanup_whiteout)\n\t\tovl_cleanup(old_upperdir->d_inode, newdentry);\n\n\tovl_dentry_version_inc(old->d_parent);\n\tovl_dentry_version_inc(new->d_parent);\n\nout_dput:\n\tdput(newdentry);\nout_dput_old:\n\tdput(olddentry);\nout_unlock:\n\tunlock_rename(new_upperdir, old_upperdir);\nout_revert_creds:\n\tif (old_opaque || new_opaque) {\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(old);\nout:\n\tdput(opaquedir);\n\treturn err;\n}",
      "line_statements": [
        [
          848,
          ""
        ],
        [
          849,
          "\tolddentry = lookup_one_len(old->d_name.name, old_upperdir,"
        ],
        [
          850,
          "\t\t\t\t   old->d_name.len);"
        ],
        [
          851,
          "\terr = PTR_ERR(olddentry);"
        ],
        [
          852,
          "\tif (IS_ERR(olddentry))"
        ],
        [
          853,
          "\t\tgoto out_unlock;"
        ],
        [
          854,
          ""
        ],
        [
          855,
          "\terr = -ESTALE;"
        ],
        [
          856,
          "\tif (olddentry != ovl_dentry_upper(old))"
        ],
        [
          857,
          "\t\tgoto out_dput_old;"
        ],
        [
          858,
          ""
        ],
        [
          859,
          "\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,"
        ],
        [
          860,
          "\t\t\t\t   new->d_name.len);"
        ],
        [
          861,
          "\terr = PTR_ERR(newdentry);"
        ],
        [
          862,
          "\tif (IS_ERR(newdentry))"
        ],
        [
          863,
          "\t\tgoto out_dput_old;"
        ],
        [
          864,
          ""
        ],
        [
          865,
          "\terr = -ESTALE;"
        ],
        [
          866,
          "\tif (ovl_dentry_upper(new)) {"
        ],
        [
          868,
          "\t\t\tif (newdentry != opaquedir)"
        ],
        [
          869,
          "\t\t\t\tgoto out_dput;"
        ],
        [
          871,
          "\t\t\tif (newdentry != ovl_dentry_upper(new))"
        ],
        [
          872,
          "\t\t\t\tgoto out_dput;"
        ],
        [
          876,
          "\t\tif (!d_is_negative(newdentry) &&"
        ],
        [
          877,
          "\t\t    (!new_opaque || !ovl_is_whiteout(newdentry)))"
        ],
        [
          878,
          "\t\t\tgoto out_dput;"
        ],
        [
          943,
          "out_dput_old:"
        ],
        [
          944,
          "\tdput(olddentry);"
        ]
      ],
      "statements": [
        [
          848,
          "\n"
        ],
        [
          849,
          "olddentry = lookup_one_len(old->d_name.name, old_upperdir,\n\t\t\t\t   old->d_name.len);"
        ],
        [
          851,
          "err = PTR_ERR(olddentry);"
        ],
        [
          852,
          "if (IS_ERR(olddentry))"
        ],
        [
          853,
          "goto out_unlock;"
        ],
        [
          854,
          "\n"
        ],
        [
          855,
          "err = -ESTALE;"
        ],
        [
          856,
          "if (olddentry != ovl_dentry_upper(old))"
        ],
        [
          857,
          "goto out_dput_old;"
        ],
        [
          858,
          "\n"
        ],
        [
          859,
          "newdentry = lookup_one_len(new->d_name.name, new_upperdir,\n\t\t\t\t   new->d_name.len);"
        ],
        [
          861,
          "err = PTR_ERR(newdentry);"
        ],
        [
          862,
          "if (IS_ERR(newdentry))"
        ],
        [
          863,
          "goto out_dput_old;"
        ],
        [
          864,
          "\n"
        ],
        [
          865,
          "err = -ESTALE;"
        ],
        [
          866,
          "if (ovl_dentry_upper(new))"
        ],
        [
          868,
          "if (newdentry != opaquedir)"
        ],
        [
          869,
          "goto out_dput;"
        ],
        [
          871,
          "if (newdentry != ovl_dentry_upper(new))"
        ],
        [
          872,
          "goto out_dput;"
        ],
        [
          876,
          "if (!d_is_negative(newdentry) &&\n\t\t    (!new_opaque || !ovl_is_whiteout(newdentry)))"
        ],
        [
          878,
          "goto out_dput;"
        ],
        [
          943,
          "out_dput_old:"
        ],
        [
          944,
          "dput(olddentry);"
        ]
      ],
      "cve": "CVE-2016-6197"
    },
    {
      "commit_id": "2def2ef2ae5f3990aabdbe8a755911902707d268",
      "filepath": "net/compat.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "compat_sys_recvmmsg",
      "func_body": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}\n",
      "line_statements": [
        [
          783,
          "\tif (COMPAT_USE_64BIT_TIME)\n"
        ],
        [
          784,
          "\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n"
        ],
        [
          785,
          "\t\t\t\t      flags | MSG_CMSG_COMPAT,\n"
        ],
        [
          786,
          "\t\t\t\t      (struct timespec *) timeout);\n"
        ],
        [
          787,
          "\n"
        ],
        [
          792,
          "\tif (get_compat_timespec(&ktspec, timeout))\n"
        ],
        [
          797,
          "\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n"
        ]
      ],
      "statements": [
        [
          783,
          "if (COMPAT_USE_64BIT_TIME)"
        ],
        [
          784,
          "return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);"
        ],
        [
          787,
          "\n"
        ],
        [
          792,
          "if (get_compat_timespec(&ktspec, timeout))"
        ],
        [
          797,
          "if (datagrams > 0 && put_compat_timespec(&ktspec, timeout))"
        ]
      ],
      "cve": "CVE-2014-0038"
    },
    {
      "commit_id": "fcd135c9df440bcd2d5870405ad3311743d78d97",
      "filepath": "auth-passwd.c",
      "project": "openssh-portable",
      "project_repo_path": "symbol_backend_projects/openssh-portable",
      "is_vulnerable": false,
      "func_name": "auth_password",
      "func_body": "auth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}",
      "line_statements": [
        [
          92,
          "\tif (strlen(password) > MAX_PASSWORD_LEN)"
        ],
        [
          93,
          "\t\treturn 0;"
        ],
        [
          94,
          ""
        ]
      ],
      "statements": [
        [
          92,
          "if (strlen(password) > MAX_PASSWORD_LEN)"
        ],
        [
          93,
          "return 0;"
        ],
        [
          94,
          "\n"
        ]
      ],
      "cve": "CVE-2016-6515"
    },
    {
      "commit_id": "0c5b1e430a83ef793a7334bbbee408cf3c628699",
      "filepath": "coders/dds.c",
      "project": "ImageMagick",
      "project_repo_path": "symbol_backend_projects/ImageMagick",
      "is_vulnerable": true,
      "func_name": "ReadDDSImage",
      "func_body": "static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status,\n    cubemap = MagickFalse,\n    volume = MagickFalse;\n\n  CompressionType\n    compression;\n\n  DDSInfo\n    dds_info;\n  \n  DDSDecoder\n    *decoder;\n  \n  PixelTrait\n    alpha_trait;\n  \n  size_t\n    n,\n    num_images;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  \n  /*\n    Initialize image structure.\n  */\n  if (ReadDDSInfo(image, &dds_info) != MagickTrue) {\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  \n  if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)\n    cubemap = MagickTrue;\n  \n  if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)\n    volume = MagickTrue;\n  \n  (void) SeekBlob(image, 128, SEEK_SET);\n\n  /*\n    Determine pixel format\n  */\n  if (dds_info.pixelformat.flags & DDPF_RGB)\n    {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          alpha_trait = BlendPixelTrait;\n          decoder = ReadUncompressedRGBA;\n        }\n      else\n        {\n          alpha_trait = UndefinedPixelTrait;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_LUMINANCE)\n   {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          /* Not sure how to handle this */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      else\n        {\n          alpha_trait = UndefinedPixelTrait;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_FOURCC)\n    {\n      switch (dds_info.pixelformat.fourcc)\n      {\n        case FOURCC_DXT1:\n        {\n          alpha_trait = UndefinedPixelTrait;\n          compression = DXT1Compression;\n          decoder = ReadDXT1;\n          break;\n        }\n        case FOURCC_DXT3:\n        {\n          alpha_trait = BlendPixelTrait;\n          compression = DXT3Compression;\n          decoder = ReadDXT3;\n          break;\n        }\n        case FOURCC_DXT5:\n        {\n          alpha_trait = BlendPixelTrait;\n          compression = DXT5Compression;\n          decoder = ReadDXT5;\n          break;\n        }\n        default:\n        {\n          /* Unknown FOURCC */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      }\n    }\n  else\n    {\n      /* Neither compressed nor uncompressed... thus unsupported */\n      ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n    }\n  \n  num_images = 1;\n  if (cubemap)\n    {\n      /*\n        Determine number of faces defined in the cubemap\n      */\n      num_images = 0;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;\n    }\n  \n  if (volume)\n    num_images = dds_info.depth;\n  \n  for (n = 0; n < num_images; n++)\n  {\n    if (n != 0)\n      {\n        /* Start a new image */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          return(DestroyImageList(image));\n        image=SyncNextImageInList(image);\n      }\n    \n    image->alpha_trait=alpha_trait;\n    image->compression = compression;\n    image->columns = dds_info.width;\n    image->rows = dds_info.height;\n    image->storage_class = DirectClass;\n    image->endian = LSBEndian;\n    image->depth = 8;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if ((decoder)(image, &dds_info, exception) != MagickTrue)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
      "line_statements": [
        [
          1680,
          "  if (ReadDDSInfo(image, &dds_info) != MagickTrue) {"
        ],
        [
          1682,
          "  }"
        ],
        [
          1683,
          ""
        ],
        [
          1686,
          ""
        ],
        [
          1689,
          ""
        ],
        [
          1778,
          ""
        ]
      ],
      "statements": [
        [
          1680,
          "if (ReadDDSInfo(image, &dds_info) != MagickTrue)"
        ],
        [
          1682,
          "  }\n"
        ],
        [
          1683,
          "  \n"
        ],
        [
          1686,
          "  \n"
        ],
        [
          1689,
          "  \n"
        ],
        [
          1778,
          "  \n"
        ]
      ],
      "cve": "CVE-2017-9141"
    }
  ],
  "CWE-362": [
    {
      "commit_id": "5c17c861a357e9458001f021a7afa7aab9937439",
      "filepath": "drivers/tty/tty_io.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "tty_ioctl",
      "func_body": "long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct tty_struct *tty = file_tty(file);\n\tstruct tty_struct *real_tty;\n\tvoid __user *p = (void __user *)arg;\n\tint retval;\n\tstruct tty_ldisc *ld;\n\n\tif (tty_paranoia_check(tty, file_inode(file), \"tty_ioctl\"))\n\t\treturn -EINVAL;\n\n\treal_tty = tty_pair_get_tty(tty);\n\n\t/*\n\t * Factor out some common prep work\n\t */\n\tswitch (cmd) {\n\tcase TIOCSETD:\n\tcase TIOCSBRK:\n\tcase TIOCCBRK:\n\tcase TCSBRK:\n\tcase TCSBRKP:\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tif (cmd != TIOCCBRK) {\n\t\t\ttty_wait_until_sent(tty, 0);\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t *\tNow do the stuff.\n\t */\n\tswitch (cmd) {\n\tcase TIOCSTI:\n\t\treturn tiocsti(tty, p);\n\tcase TIOCGWINSZ:\n\t\treturn tiocgwinsz(real_tty, p);\n\tcase TIOCSWINSZ:\n\t\treturn tiocswinsz(real_tty, p);\n\tcase TIOCCONS:\n\t\treturn real_tty != tty ? -EINVAL : tioccons(file);\n\tcase FIONBIO:\n\t\treturn fionbio(file, p);\n\tcase TIOCEXCL:\n\t\tset_bit(TTY_EXCLUSIVE, &tty->flags);\n\t\treturn 0;\n\tcase TIOCNXCL:\n\t\tclear_bit(TTY_EXCLUSIVE, &tty->flags);\n\t\treturn 0;\n\tcase TIOCGEXCL:\n\t{\n\t\tint excl = test_bit(TTY_EXCLUSIVE, &tty->flags);\n\t\treturn put_user(excl, (int __user *)p);\n\t}\n\tcase TIOCNOTTY:\n\t\tif (current->signal->tty != tty)\n\t\t\treturn -ENOTTY;\n\t\tno_tty();\n\t\treturn 0;\n\tcase TIOCSCTTY:\n\t\treturn tiocsctty(real_tty, file, arg);\n\tcase TIOCGPGRP:\n\t\treturn tiocgpgrp(tty, real_tty, p);\n\tcase TIOCSPGRP:\n\t\treturn tiocspgrp(tty, real_tty, p);\n\tcase TIOCGSID:\n\t\treturn tiocgsid(tty, real_tty, p);\n\tcase TIOCGETD:\n\t\treturn put_user(tty->ldisc->ops->num, (int __user *)p);\n\tcase TIOCSETD:\n\t\treturn tiocsetd(tty, p);\n\tcase TIOCVHANGUP:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\ttty_vhangup(tty);\n\t\treturn 0;\n\tcase TIOCGDEV:\n\t{\n\t\tunsigned int ret = new_encode_dev(tty_devnum(real_tty));\n\t\treturn put_user(ret, (unsigned int __user *)p);\n\t}\n\t/*\n\t * Break handling\n\t */\n\tcase TIOCSBRK:\t/* Turn break on, unconditionally */\n\t\tif (tty->ops->break_ctl)\n\t\t\treturn tty->ops->break_ctl(tty, -1);\n\t\treturn 0;\n\tcase TIOCCBRK:\t/* Turn break off, unconditionally */\n\t\tif (tty->ops->break_ctl)\n\t\t\treturn tty->ops->break_ctl(tty, 0);\n\t\treturn 0;\n\tcase TCSBRK:   /* SVID version: non-zero arg --> no break */\n\t\t/* non-zero arg means wait for all output data\n\t\t * to be sent (performed above) but don't send break.\n\t\t * This is used by the tcdrain() termios function.\n\t\t */\n\t\tif (!arg)\n\t\t\treturn send_break(tty, 250);\n\t\treturn 0;\n\tcase TCSBRKP:\t/* support for POSIX tcsendbreak() */\n\t\treturn send_break(tty, arg ? arg*100 : 250);\n\n\tcase TIOCMGET:\n\t\treturn tty_tiocmget(tty, p);\n\tcase TIOCMSET:\n\tcase TIOCMBIC:\n\tcase TIOCMBIS:\n\t\treturn tty_tiocmset(tty, cmd, p);\n\tcase TIOCGICOUNT:\n\t\tretval = tty_tiocgicount(tty, p);\n\t\t/* For the moment allow fall through to the old method */\n        \tif (retval != -EINVAL)\n\t\t\treturn retval;\n\t\tbreak;\n\tcase TCFLSH:\n\t\tswitch (arg) {\n\t\tcase TCIFLUSH:\n\t\tcase TCIOFLUSH:\n\t\t/* flush tty buffer and allow ldisc to process ioctl */\n\t\t\ttty_buffer_flush(tty, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TIOCSSERIAL:\n\t\ttty_warn_deprecated_flags(p);\n\t\tbreak;\n\t}\n\tif (tty->ops->ioctl) {\n\t\tretval = tty->ops->ioctl(tty, cmd, arg);\n\t\tif (retval != -ENOIOCTLCMD)\n\t\t\treturn retval;\n\t}\n\tld = tty_ldisc_ref_wait(tty);\n\tretval = -EINVAL;\n\tif (ld->ops->ioctl) {\n\t\tretval = ld->ops->ioctl(tty, file, cmd, arg);\n\t\tif (retval == -ENOIOCTLCMD)\n\t\t\tretval = -ENOTTY;\n\t}\n\ttty_ldisc_deref(ld);\n\treturn retval;\n}\n",
      "line_statements": [
        [
          2887,
          "\t\treturn put_user(tty->ldisc->ops->num, (int __user *)p);\n"
        ]
      ],
      "statements": [
        [
          2887,
          "return put_user(tty->ldisc->ops->num, (int __user *)p);"
        ]
      ],
      "cve": "CVE-2016-0723"
    },
    {
      "commit_id": "fd4d9c7d0c71866ec0c2825189ebd2ce35bd95b8",
      "filepath": "mm/slub.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "kmem_cache_alloc_bulk",
      "func_body": "int kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,\n\t\t\t  void **p)\n{\n\tstruct kmem_cache_cpu *c;\n\tint i;\n\n\t/* memcg and kmem_cache debug support */\n\ts = slab_pre_alloc_hook(s, flags);\n\tif (unlikely(!s))\n\t\treturn false;\n\t/*\n\t * Drain objects in the per cpu slab, while disabling local\n\t * IRQs, which protects against PREEMPT and interrupts\n\t * handlers invoking normal fastpath.\n\t */\n\tlocal_irq_disable();\n\tc = this_cpu_ptr(s->cpu_slab);\n\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = c->freelist;\n\n\t\tif (unlikely(!object)) {\n\t\t\t/*\n\t\t\t * Invoking slow path likely have side-effect\n\t\t\t * of re-populating per CPU c->freelist\n\t\t\t */\n\t\t\tp[i] = ___slab_alloc(s, flags, NUMA_NO_NODE,\n\t\t\t\t\t    _RET_IP_, c);\n\t\t\tif (unlikely(!p[i]))\n\t\t\t\tgoto error;\n\n\t\t\tc = this_cpu_ptr(s->cpu_slab);\n\t\t\tmaybe_wipe_obj_freeptr(s, p[i]);\n\n\t\t\tcontinue; /* goto for-loop */\n\t\t}\n\t\tc->freelist = get_freepointer(s, object);\n\t\tp[i] = object;\n\t\tmaybe_wipe_obj_freeptr(s, p[i]);\n\t}\n\tc->tid = next_tid(c->tid);\n\tlocal_irq_enable();\n\n\t/* Clear memory outside IRQ disabled fastpath loop */\n\tif (unlikely(slab_want_init_on_alloc(flags, s))) {\n\t\tint j;\n\n\t\tfor (j = 0; j < i; j++)\n\t\t\tmemset(p[j], 0, s->object_size);\n\t}\n\n\t/* memcg and kmem_cache debug support */\n\tslab_post_alloc_hook(s, flags, size, p);\n\treturn i;\nerror:\n\tlocal_irq_enable();\n\tslab_post_alloc_hook(s, flags, i, p);\n\t__kmem_cache_free_bulk(s, i, p);\n\treturn 0;\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2020-29370"
    },
    {
      "commit_id": "49d31c2f389acfe83417083e1208422b4091cd9e",
      "filepath": "fs/debugfs/inode.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "debugfs_rename",
      "func_body": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tstruct name_snapshot old_name;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\t/* Source or destination directories don't exist? */\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\t/* Source does not exist, cyclic rename, or mountpoint? */\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\t/* Lookup failed, cyclic rename or target exists? */\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\n\ttake_dentry_name_snapshot(&old_name, old_dentry);\n\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\trelease_dentry_name_snapshot(&old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name.name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\trelease_dentry_name_snapshot(&old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}\n",
      "line_statements": [
        [
          769,
          "\tstruct name_snapshot old_name;\n"
        ],
        [
          784,
          "\ttake_dentry_name_snapshot(&old_name, old_dentry);\n"
        ],
        [
          789,
          "\t\trelease_dentry_name_snapshot(&old_name);\n"
        ],
        [
          793,
          "\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name.name,\n"
        ],
        [
          796,
          "\trelease_dentry_name_snapshot(&old_name);\n"
        ]
      ],
      "statements": [
        [
          769,
          "struct name_snapshot old_name;"
        ],
        [
          784,
          "take_dentry_name_snapshot(&old_name, old_dentry);"
        ],
        [
          789,
          "release_dentry_name_snapshot(&old_name);"
        ],
        [
          793,
          "fsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name.name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);"
        ],
        [
          796,
          "release_dentry_name_snapshot(&old_name);"
        ]
      ],
      "cve": "CVE-2017-7533"
    },
    {
      "commit_id": "d15d662e89fc667b90cd294b0eb45694e33144da",
      "filepath": "sound/core/seq/seq_clientmgr.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "snd_seq_write",
      "func_body": "static ssize_t snd_seq_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *offset)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tint written = 0, len;\n\tint err;\n\tstruct snd_seq_event event;\n\n\tif (!(snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_OUTPUT))\n\t\treturn -ENXIO;\n\n\t/* check client structures are in place */\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\t\t\n\tif (!client->accept_output || client->pool == NULL)\n\t\treturn -ENXIO;\n\n\t/* allocate the pool now if the pool is not allocated yet */ \n\tif (client->pool->size > 0 && !snd_seq_write_pool_allocated(client)) {\n\t\tmutex_lock(&client->ioctl_mutex);\n\t\terr = snd_seq_pool_init(client->pool);\n\t\tmutex_unlock(&client->ioctl_mutex);\n\t\tif (err < 0)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* only process whole events */\n\terr = -EINVAL;\n\twhile (count >= sizeof(struct snd_seq_event)) {\n\t\t/* Read in the event header from the user */\n\t\tlen = sizeof(event);\n\t\tif (copy_from_user(&event, buf, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tevent.source.client = client->number;\t/* fill in client number */\n\t\t/* Check for extension data length */\n\t\tif (check_event_type_and_length(&event)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check for special events */\n\t\tif (event.type == SNDRV_SEQ_EVENT_NONE)\n\t\t\tgoto __skip_event;\n\t\telse if (snd_seq_ev_is_reserved(&event)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (snd_seq_ev_is_variable(&event)) {\n\t\t\tint extlen = event.data.ext.len & ~SNDRV_SEQ_EXT_MASK;\n\t\t\tif ((size_t)(extlen + len) > count) {\n\t\t\t\t/* back out, will get an error this time or next */\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* set user space pointer */\n\t\t\tevent.data.ext.len = extlen | SNDRV_SEQ_EXT_USRPTR;\n\t\t\tevent.data.ext.ptr = (char __force *)buf\n\t\t\t\t\t\t+ sizeof(struct snd_seq_event);\n\t\t\tlen += extlen; /* increment data length */\n\t\t} else {\n// #ifdef CONFIG_COMPAT\n\t\t\tif (client->convert32 && snd_seq_ev_is_varusr(&event)) {\n\t\t\t\tvoid *ptr = (void __force *)compat_ptr(event.data.raw32.d[1]);\n\t\t\t\tevent.data.ext.ptr = ptr;\n\t\t\t}\n#endif\n\t\t}\n\n\t\t/* ok, enqueue it */\n\t\terr = snd_seq_client_enqueue_event(client, &event, file,\n\t\t\t\t\t\t   !(file->f_flags & O_NONBLOCK),\n\t\t\t\t\t\t   0, 0);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t__skip_event:\n\t\t/* Update pointers and counts */\n\t\tcount -= len;\n\t\tbuf += len;\n\t\twritten += len;\n\t}\n\n\treturn written ? written : err;\n}\n",
      "line_statements": [
        [
          1006,
          "\tint err;\n"
        ],
        [
          1021,
          "\t\tmutex_lock(&client->ioctl_mutex);\n"
        ],
        [
          1022,
          "\t\terr = snd_seq_pool_init(client->pool);\n"
        ],
        [
          1023,
          "\t\tmutex_unlock(&client->ioctl_mutex);\n"
        ],
        [
          1024,
          "\t\tif (err < 0)\n"
        ],
        [
          1029,
          "\terr = -EINVAL;\n"
        ]
      ],
      "statements": [
        [
          1006,
          "int err;"
        ],
        [
          1021,
          "mutex_lock(&client->ioctl_mutex);"
        ],
        [
          1022,
          "err = snd_seq_pool_init(client->pool);"
        ],
        [
          1023,
          "mutex_unlock(&client->ioctl_mutex);"
        ],
        [
          1024,
          "if (err < 0)"
        ],
        [
          1029,
          "err = -EINVAL;"
        ]
      ],
      "cve": "CVE-2018-7566"
    },
    {
      "commit_id": "d5f9023fa61ee8b94f37a93f08e94b136cf1e463",
      "filepath": "net/can/bcm.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "bcm_release",
      "func_body": "static int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\n\t/* remove bcm_ops, timer, rx_unregister(), etc. */\n\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\n\tlock_sock(sk);\n\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\t/*\n\t\t * Don't care if we're bound or not (due to netdev problems)\n\t\t * can_rx_unregister() is always a save thing to do here.\n\t\t */\n\t\tif (op->ifindex) {\n\t\t\t/*\n\t\t\t * Only remove subscriptions that had not\n\t\t\t * been removed due to NETDEV_UNREGISTER\n\t\t\t * in bcm_notifier()\n\t\t\t */\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list)\n\t\tbcm_remove_op(op);\n\n#if IS_ENABLED(CONFIG_PROC_FS)\n\t/* remove procfs entry */\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif /* CONFIG_PROC_FS */\n\n\t/* remove device reference */\n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}",
      "line_statements": [
        [
          1539,
          "\tsynchronize_rcu();"
        ],
        [
          1540,
          ""
        ],
        [
          1541,
          "\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list)"
        ],
        [
          1542,
          "\t\tbcm_remove_op(op);"
        ],
        [
          1543,
          ""
        ]
      ],
      "statements": [
        [
          1539,
          "synchronize_rcu();"
        ],
        [
          1540,
          "\n"
        ],
        [
          1541,
          "list_for_each_entry_safe(op, next, &bo->rx_ops, list)"
        ],
        [
          1542,
          "bcm_remove_op(op);"
        ],
        [
          1543,
          "\n"
        ]
      ],
      "cve": "CVE-2021-3609"
    },
    {
      "commit_id": "2d45a02d0166caf2627fe91897c6ffc3b19514c4",
      "filepath": "net/sctp/socket.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "sctp_sock_migrate",
      "func_body": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_bind_hashbucket *head;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tsctp_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\thead = &sctp_port_hashtable[sctp_phashfn(sock_net(oldsk),\n\t\t\t\t\t\t inet_sk(oldsk)->inet_num)];\n\tlocal_bh_disable();\n\tspin_lock(&head->lock);\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->inet_num = inet_sk(oldsk)->inet_num;\n\tspin_unlock(&head->lock);\n\tlocal_bh_enable();\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tsctp_bind_addr_dup(&newsp->ep->base.bind_addr,\n\t\t\t\t&oldsp->ep->base.bind_addr, GFP_KERNEL);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tatomic_set(&sctp_sk(newsk)->pd_mode, assoc->ulpq.pd_mode);\n\n\tif (atomic_read(&sctp_sk(oldsk)->pd_mode)) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk, NULL);\n\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t *\n\t * The caller has just allocated newsk so we can guarantee that other\n\t * paths won't try to lock it and then oldsk.\n\t */\n\tlock_sock_nested(newsk, SINGLE_DEPTH_NESTING);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\trelease_sock(newsk);\n}",
      "line_statements": [
        [
          7246,
          "\tsctp_copy_descendant(newsk, oldsk);"
        ]
      ],
      "statements": [
        [
          7246,
          "sctp_copy_descendant(newsk, oldsk);"
        ]
      ],
      "cve": "CVE-2015-3212"
    },
    {
      "commit_id": "15b7a03205b31bc5623378c190d22b7ff60026f1",
      "filepath": "sound/usb/line6/driver.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "line6_data_received",
      "func_body": "static void line6_data_received(struct urb *urb)\n{\n\tstruct usb_line6 *line6 = (struct usb_line6 *)urb->context;\n\tstruct midi_buffer *mb = &line6->line6midi->midibuf_in;\n\tunsigned long flags;\n\tint done;\n\n\tif (urb->status == -ESHUTDOWN)\n\t\treturn;\n\n\tif (line6->properties->capabilities & LINE6_CAP_CONTROL_MIDI) {\n\t\tspin_lock_irqsave(&line6->line6midi->lock, flags);\n\t\tdone =\n\t\t\tline6_midibuf_write(mb, urb->transfer_buffer, urb->actual_length);\n\n\t\tif (done < urb->actual_length) {\n\t\t\tline6_midibuf_ignore(mb, done);\n\t\t\tdev_dbg(line6->ifcdev, \"%d %d buffer overflow - message skipped\\n\",\n\t\t\t\tdone, urb->actual_length);\n\t\t}\n\t\tspin_unlock_irqrestore(&line6->line6midi->lock, flags);\n\n\t\tfor (;;) {\n\t\t\tspin_lock_irqsave(&line6->line6midi->lock, flags);\n\t\t\tdone =\n\t\t\t\tline6_midibuf_read(mb, line6->buffer_message,\n\t\t\t\t\t\t   LINE6_MIDI_MESSAGE_MAXLEN,\n\t\t\t\t\t\t   LINE6_MIDIBUF_READ_RX);\n\t\t\tspin_unlock_irqrestore(&line6->line6midi->lock, flags);\n\n\t\t\tif (done <= 0)\n\t\t\t\tbreak;\n\n\t\t\tline6->message_length = done;\n\t\t\tline6_midi_receive(line6, line6->buffer_message, done);\n\n\t\t\tif (line6->process_message)\n\t\t\t\tline6->process_message(line6);\n\t\t}\n\t} else {\n\t\tline6->buffer_message = urb->transfer_buffer;\n\t\tline6->message_length = urb->actual_length;\n\t\tif (line6->process_message)\n\t\t\tline6->process_message(line6);\n\t\tline6->buffer_message = NULL;\n\t}\n\n\tline6_start_listen(line6);\n}\n",
      "line_statements": [
        [
          289,
          "\tunsigned long flags;\n"
        ],
        [
          296,
          "\t\tspin_lock_irqsave(&line6->line6midi->lock, flags);\n"
        ],
        [
          305,
          "\t\tspin_unlock_irqrestore(&line6->line6midi->lock, flags);\n"
        ],
        [
          308,
          "\t\t\tspin_lock_irqsave(&line6->line6midi->lock, flags);\n"
        ],
        [
          313,
          "\t\t\tspin_unlock_irqrestore(&line6->line6midi->lock, flags);\n"
        ]
      ],
      "statements": [
        [
          289,
          "unsigned long flags;"
        ],
        [
          296,
          "spin_lock_irqsave(&line6->line6midi->lock, flags);"
        ],
        [
          305,
          "spin_unlock_irqrestore(&line6->line6midi->lock, flags);"
        ],
        [
          308,
          "spin_lock_irqsave(&line6->line6midi->lock, flags);"
        ],
        [
          313,
          "spin_unlock_irqrestore(&line6->line6midi->lock, flags);"
        ]
      ],
      "cve": "CVE-2024-44954"
    },
    {
      "commit_id": "172e422ffea20a89bfdc672741c1aad6fbb5044e",
      "filepath": "fs/notify/fsnotify.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "__fsnotify_parent",
      "func_body": "int __fsnotify_parent(struct dentry *dentry, __u32 mask, const void *data,\n\t\t      int data_type)\n{\n\tconst struct path *path = fsnotify_data_path(data, data_type);\n\t__u32 mnt_mask = path ? real_mount(path->mnt)->mnt_fsnotify_mask : 0;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct dentry *parent;\n\tbool parent_watched = dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED;\n\tbool parent_needed, parent_interested;\n\t__u32 p_mask;\n\tstruct inode *p_inode = NULL;\n\tstruct name_snapshot name;\n\tstruct qstr *file_name = NULL;\n\tint ret = 0;\n\n\t/* Optimize the likely case of nobody watching this path */\n\tif (likely(!parent_watched &&\n\t\t   !fsnotify_object_watched(inode, mnt_mask, mask)))\n\t\treturn 0;\n\n\tparent = NULL;\n\tparent_needed = fsnotify_event_needs_parent(inode, mnt_mask, mask);\n\tif (!parent_watched && !parent_needed)\n\t\tgoto notify;\n\n\t/* Does parent inode care about events on children? */\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\tp_mask = fsnotify_inode_watches_children(p_inode);\n\tif (unlikely(parent_watched && !p_mask))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\n\t/*\n\t * Include parent/name in notification either if some notification\n\t * groups require parent info or the parent is interested in this event.\n\t */\n\tparent_interested = mask & p_mask & ALL_FSNOTIFY_EVENTS;\n\tif (parent_needed || parent_interested) {\n\t\t/* When notifying parent, child should be passed as data */\n\t\tWARN_ON_ONCE(inode != fsnotify_data_inode(data, data_type));\n\n\t\t/* Notify both parent and child with child name info */\n\t\ttake_dentry_name_snapshot(&name, dentry);\n\t\tfile_name = &name.name;\n\t\tif (parent_interested)\n\t\t\tmask |= FS_EVENT_ON_CHILD;\n\t}\n\nnotify:\n\tret = fsnotify(mask, data, data_type, p_inode, file_name, inode, 0);\n\n\tif (file_name)\n\t\trelease_dentry_name_snapshot(&name);\n\tdput(parent);\n\n\treturn ret;\n}\n",
      "line_statements": [
        [
          231,
          "\t\t__fsnotify_update_child_dentry_flags(p_inode);\n"
        ]
      ],
      "statements": [
        [
          231,
          "__fsnotify_update_child_dentry_flags(p_inode);"
        ]
      ],
      "cve": "CVE-2024-47660"
    },
    {
      "commit_id": "04197b341f23b908193308b8d63d17ff23232598",
      "filepath": "fs/xfs/xfs_aops.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "__xfs_get_blocks",
      "func_body": "STATIC int\n__xfs_get_blocks(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate,\n\tbool\t\t\tdirect,\n\tbool\t\t\tdax_fault)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tlockmode = 0;\n\tstruct xfs_bmbt_irec\timap;\n\tint\t\t\tnimaps = 1;\n\txfs_off_t\t\toffset;\n\tssize_t\t\t\tsize;\n\tint\t\t\tnew = 0;\n\tbool\t\t\tis_cow = false;\n\tbool\t\t\tneed_alloc = false;\n\n\tBUG_ON(create && !direct);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\toffset = (xfs_off_t)iblock << inode->i_blkbits;\n\tASSERT(bh_result->b_size >= (1 << inode->i_blkbits));\n\tsize = bh_result->b_size;\n\n\tif (!create && offset >= i_size_read(inode))\n\t\treturn 0;\n\n\t/*\n\t * Direct I/O is usually done on preallocated files, so try getting\n\t * a block mapping without an exclusive lock first.\n\t */\n\tlockmode = xfs_ilock_data_map_shared(ip);\n\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\tif (offset + size > mp->m_super->s_maxbytes)\n\t\tsize = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + size);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\n\tif (create && direct && xfs_is_reflink_inode(ip))\n\t\tis_cow = xfs_reflink_find_cow_mapping(ip, offset, &imap,\n\t\t\t\t\t&need_alloc);\n\tif (!is_cow) {\n\t\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\t\t&imap, &nimaps, XFS_BMAPI_ENTIRE);\n\t\t/*\n\t\t * Truncate an overwrite extent if there's a pending CoW\n\t\t * reservation before the end of this extent.  This\n\t\t * forces us to come back to get_blocks to take care of\n\t\t * the CoW.\n\t\t */\n\t\tif (create && direct && nimaps &&\n\t\t    imap.br_startblock != HOLESTARTBLOCK &&\n\t\t    imap.br_startblock != DELAYSTARTBLOCK &&\n\t\t    !ISUNWRITTEN(&imap))\n\t\t\txfs_reflink_trim_irec_to_next_cow(ip, offset_fsb,\n\t\t\t\t\t&imap);\n\t}\n\tASSERT(!need_alloc);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * The only time we can ever safely find delalloc blocks on direct I/O\n\t * is a dio write to post-eof speculative preallocation. All other\n\t * scenarios are indicative of a problem or misuse (such as mixing\n\t * direct and mapped I/O).\n\t *\n\t * The file may be unmapped by the time we get here so we cannot\n\t * reliably fail the I/O based on mapping. Instead, fail the I/O if this\n\t * is a read or a write within eof. Otherwise, carry on but warn as a\n\t * precuation if the file happens to be mapped.\n\t */\n\tif (direct && imap.br_startblock == DELAYSTARTBLOCK) {\n\t\tif (!create || offset < i_size_read(VFS_I(ip))) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\terror = -EIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tWARN_ON_ONCE(mapping_mapped(VFS_I(ip)->i_mapping));\n\t}\n\n\t/* for DAX, we convert unwritten extents directly */\n\tif (create &&\n\t    (!nimaps ||\n\t     (imap.br_startblock == HOLESTARTBLOCK ||\n\t      imap.br_startblock == DELAYSTARTBLOCK) ||\n\t     (IS_DAX(inode) && ISUNWRITTEN(&imap)))) {\n\t\t/*\n\t\t * xfs_iomap_write_direct() expects the shared lock. It\n\t\t * is unlocked on return.\n\t\t */\n\t\tif (lockmode == XFS_ILOCK_EXCL)\n\t\t\txfs_ilock_demote(ip, lockmode);\n\n\t\terror = xfs_iomap_write_direct(ip, offset, size,\n\t\t\t\t\t       &imap, nimaps);\n\t\tif (error)\n\t\t\treturn error;\n\t\tnew = 1;\n\n\t\ttrace_xfs_get_blocks_alloc(ip, offset, size,\n\t\t\t\tISUNWRITTEN(&imap) ? XFS_IO_UNWRITTEN\n\t\t\t\t\t\t   : XFS_IO_DELALLOC, &imap);\n\t} else if (nimaps) {\n\t\ttrace_xfs_get_blocks_found(ip, offset, size,\n\t\t\t\tISUNWRITTEN(&imap) ? XFS_IO_UNWRITTEN\n\t\t\t\t\t\t   : XFS_IO_OVERWRITE, &imap);\n\t\txfs_iunlock(ip, lockmode);\n\t} else {\n\t\ttrace_xfs_get_blocks_notfound(ip, offset, size);\n\t\tgoto out_unlock;\n\t}\n\n\tif (IS_DAX(inode) && create) {\n\t\tASSERT(!ISUNWRITTEN(&imap));\n\t\t/* zeroing is not needed at a higher layer */\n\t\tnew = 0;\n\t}\n\n\t/* trim mapping down to size requested */\n\txfs_map_trim_size(inode, iblock, bh_result, &imap, offset, size);\n\n\t/*\n\t * For unwritten extents do not report a disk address in the buffered\n\t * read case (treat as if we're reading into a hole).\n\t */\n\tif (imap.br_startblock != HOLESTARTBLOCK &&\n\t    imap.br_startblock != DELAYSTARTBLOCK &&\n\t    (create || !ISUNWRITTEN(&imap))) {\n\t\tif (create && direct && !is_cow) {\n\t\t\terror = xfs_bounce_unaligned_dio_write(ip, offset_fsb,\n\t\t\t\t\t&imap);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\txfs_map_buffer(inode, bh_result, &imap, offset);\n\t\tif (ISUNWRITTEN(&imap))\n\t\t\tset_buffer_unwritten(bh_result);\n\t\t/* direct IO needs special help */\n\t\tif (create) {\n\t\t\tif (dax_fault)\n\t\t\t\tASSERT(!ISUNWRITTEN(&imap));\n\t\t\telse\n\t\t\t\txfs_map_direct(inode, bh_result, &imap, offset,\n\t\t\t\t\t\tis_cow);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a realtime file, data may be on a different device.\n\t * to that pointed to from the buffer_head b_bdev currently.\n\t */\n\tbh_result->b_bdev = xfs_find_bdev_for_inode(inode);\n\n\t/*\n\t * If we previously allocated a block out beyond eof and we are now\n\t * coming back to use it then we will need to flag it as new even if it\n\t * has a disk address.\n\t *\n\t * With sub-block writes into unwritten extents we also need to mark\n\t * the buffer as new so that the unwritten parts of the buffer gets\n\t * correctly zeroed.\n\t */\n\tif (create &&\n\t    ((!buffer_mapped(bh_result) && !buffer_uptodate(bh_result)) ||\n\t     (offset >= i_size_read(inode)) ||\n\t     (new || ISUNWRITTEN(&imap))))\n\t\tset_buffer_new(bh_result);\n\n\treturn 0;\n\nout_unlock:\n\txfs_iunlock(ip, lockmode);\n\treturn error;\n}\n",
      "line_statements": [
        [
          1364,
          "\t/*\n"
        ],
        [
          1365,
          "\t * The only time we can ever safely find delalloc blocks on direct I/O\n"
        ],
        [
          1366,
          "\t * is a dio write to post-eof speculative preallocation. All other\n"
        ],
        [
          1367,
          "\t * scenarios are indicative of a problem or misuse (such as mixing\n"
        ],
        [
          1368,
          "\t * direct and mapped I/O).\n"
        ],
        [
          1369,
          "\t *\n"
        ],
        [
          1370,
          "\t * The file may be unmapped by the time we get here so we cannot\n"
        ],
        [
          1371,
          "\t * reliably fail the I/O based on mapping. Instead, fail the I/O if this\n"
        ],
        [
          1372,
          "\t * is a read or a write within eof. Otherwise, carry on but warn as a\n"
        ],
        [
          1373,
          "\t * precuation if the file happens to be mapped.\n"
        ],
        [
          1374,
          "\t */\n"
        ],
        [
          1375,
          "\tif (direct && imap.br_startblock == DELAYSTARTBLOCK) {\n"
        ],
        [
          1376,
          "\t\tif (!create || offset < i_size_read(VFS_I(ip))) {\n"
        ],
        [
          1377,
          "\t\t\tWARN_ON_ONCE(1);\n"
        ],
        [
          1378,
          "\t\t\terror = -EIO;\n"
        ],
        [
          1379,
          "\t\t\tgoto out_unlock;\n"
        ],
        [
          1380,
          "\t\t}\n"
        ],
        [
          1381,
          "\t\tWARN_ON_ONCE(mapping_mapped(VFS_I(ip)->i_mapping));\n"
        ],
        [
          1382,
          "\t}\n"
        ],
        [
          1383,
          "\n"
        ]
      ],
      "statements": [
        [
          1364,
          "/*\n\t * The only time we can ever safely find delalloc blocks on direct I/O\n\t * is a dio write to post-eof speculative preallocation. All other\n\t * scenarios are indicative of a problem or misuse (such as mixing\n\t * direct and mapped I/O).\n\t *\n\t * The file may be unmapped by the time we get here so we cannot\n\t * reliably fail the I/O based on mapping. Instead, fail the I/O if this\n\t * is a read or a write within eof. Otherwise, carry on but warn as a\n\t * precuation if the file happens to be mapped.\n\t */"
        ],
        [
          1375,
          "if (direct && imap.br_startblock == DELAYSTARTBLOCK)"
        ],
        [
          1376,
          "if (!create || offset < i_size_read(VFS_I(ip)))"
        ],
        [
          1377,
          "WARN_ON_ONCE(1);"
        ],
        [
          1378,
          "error = -EIO;"
        ],
        [
          1379,
          "goto out_unlock;"
        ],
        [
          1380,
          "\t\t}\n"
        ],
        [
          1381,
          "WARN_ON_ONCE(mapping_mapped(VFS_I(ip)->i_mapping));"
        ],
        [
          1382,
          "\t}\n"
        ],
        [
          1383,
          "\n"
        ]
      ],
      "cve": "CVE-2016-10741"
    },
    {
      "commit_id": "8f659a03a0ba9289b9aeb9b4470e6fb263d6f483",
      "filepath": "net/ipv4/raw.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "raw_sendmsg",
      "func_body": "static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\tint free = 0;\n\t__be32 daddr;\n\t__be32 saddr;\n\tu8  tos;\n\tint err;\n\tstruct ip_options_data opt_copy;\n\tstruct raw_frag_vec rfv;\n\n\terr = -EMSGSIZE;\n\tif (len > 0xFFFF)\n\t\tgoto out;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t/* Mirror BSD error message */\n\t\tgoto out;               /* compatibility */\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_namelen) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tpr_info_once(\"%s: %s forgot to set AF_INET. Fix it!\\n\",\n\t\t\t\t     __func__, current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* ANK: I did not forget to get protocol from port field.\n\t\t * I just do not know, who uses this weirdness.\n\t\t * IP_HDRINCL is much more convenient.\n\t\t */\n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipc.sockc.tsflags = sk->sk_tsflags;\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tipc.ttl = 0;\n\tipc.tos = -1;\n\tipc.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sk, msg, &ipc, false);\n\t\tif (unlikely(err)) {\n\t\t\tkfree(ipc.opt);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = daddr;\n\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (ipc.opt) {\n\t\terr = -EINVAL;\n\t\t/* Linux does not mangle headers on raw sockets,\n\t\t * so that IP options + IP_HDRINCL is non-sense.\n\t\t */\n\t\tif (inet->hdrincl)\n\t\t\tgoto done;\n\t\tif (ipc.opt->opt.srr) {\n\t\t\tif (!daddr)\n\t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->opt.faddr;\n\t\t}\n\t}\n\ttos = get_rtconn_flags(&ipc, sk);\n\tif (msg->msg_flags & MSG_DONTROUTE)\n\t\ttos |= RTO_ONLINK;\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t} else if (!ipc.oif)\n\t\tipc.oif = inet->uc_index;\n\n\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n\t\t\t   inet_sk_flowi_flags(sk) |\n\t\t\t    (inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),\n\t\t\t   daddr, saddr, 0, 0, sk->sk_uid);\n\n\tif (!inet->hdrincl) {\n\t\trfv.msg = msg;\n\t\trfv.hlen = 0;\n\n\t\terr = raw_probe_proto_opt(&rfv, &fl4);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto done;\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (inet->hdrincl)\n\t\terr = raw_send_hdrinc(sk, &fl4, msg, len,\n\t\t\t\t      &rt, msg->msg_flags, &ipc.sockc);\n\n\t else {\n\t\tsock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);\n\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = fl4.daddr;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, &fl4, raw_getfrag,\n\t\t\t\t     &rfv, len, 0,\n\t\t\t\t     &ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk, &fl4);\n\t\t\tif (err == -ENOBUFS && !inet->recverr)\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(&rt->dst, &fl4.daddr);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n",
      "line_statements": [
        [
          596,
          "\t\tif (inet->hdrincl)\n"
        ],
        [
          618,
          "\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n"
        ],
        [
          620,
          "\t\t\t    (inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),\n"
        ],
        [
          623,
          "\tif (!inet->hdrincl) {\n"
        ],
        [
          648,
          "\tif (inet->hdrincl)\n"
        ]
      ],
      "statements": [
        [
          596,
          "if (inet->hdrincl)"
        ],
        [
          616,
          "flowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n\t\t\t   inet_sk_flowi_flags(sk) |\n\t\t\t    (inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),\n\t\t\t   daddr, saddr, 0, 0, sk->sk_uid);"
        ],
        [
          623,
          "if (!inet->hdrincl)"
        ],
        [
          648,
          "if (inet->hdrincl)"
        ]
      ],
      "cve": "CVE-2017-17712"
    },
    {
      "commit_id": "d78d867dcea69c328db30df665be5be7d0148484",
      "filepath": "net/netfilter/nf_tables_api.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "nft_obj_type_get",
      "func_body": "static const struct nft_object_type *\nnft_obj_type_get(struct net *net, u32 objtype, u8 family)\n{\n\tconst struct nft_object_type *type;\n\n\ttype = __nft_obj_type_get(objtype, family);\n\tif (type != NULL && try_module_get(type->owner))\n\t\treturn type;\n\n\tlockdep_nfnl_nft_mutex_not_held();\n// #ifdef CONFIG_MODULES\n\tif (type == NULL) {\n\t\tif (nft_request_module(net, \"nft-obj-%u\", objtype) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n",
      "line_statements": [
        [
          7631,
          "\tif (type != NULL && try_module_get(type->owner))\n"
        ]
      ],
      "statements": [
        [
          7631,
          "if (type != NULL && try_module_get(type->owner))"
        ]
      ],
      "cve": "CVE-2024-27019"
    },
    {
      "commit_id": "5eeb2ca02a2f6084fc57ae5c244a38baab07033a",
      "filepath": "drivers/android/binder.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "binder_thread_release",
      "func_body": "static int binder_thread_release(struct binder_proc *proc,\n\t\t\t\t struct binder_thread *thread)\n{\n\tstruct binder_transaction *t;\n\tstruct binder_transaction *send_reply = NULL;\n\tint active_transactions = 0;\n\tstruct binder_transaction *last_t = NULL;\n\n\tbinder_inner_proc_lock(thread->proc);\n\t/*\n\t * take a ref on the proc so it survives\n\t * after we remove this thread from proc->threads.\n\t * The corresponding dec is when we actually\n\t * free the thread in binder_free_thread()\n\t */\n\tproc->tmp_ref++;\n\t/*\n\t * take a ref on this thread to ensure it\n\t * survives while we are releasing it\n\t */\n\tatomic_inc(&thread->tmp_ref);\n\trb_erase(&thread->rb_node, &proc->threads);\n\tt = thread->transaction_stack;\n\tif (t) {\n\t\tspin_lock(&t->lock);\n\t\tif (t->to_thread == thread)\n\t\t\tsend_reply = t;\n\t}\n\tthread->is_dead = true;\n\n\twhile (t) {\n\t\tlast_t = t;\n\t\tactive_transactions++;\n\t\tbinder_debug(BINDER_DEBUG_DEAD_TRANSACTION,\n\t\t\t     \"release %d:%d transaction %d %s, still active\\n\",\n\t\t\t      proc->pid, thread->pid,\n\t\t\t     t->debug_id,\n\t\t\t     (t->to_thread == thread) ? \"in\" : \"out\");\n\n\t\tif (t->to_thread == thread) {\n\t\t\tt->to_proc = NULL;\n\t\t\tt->to_thread = NULL;\n\t\t\tif (t->buffer) {\n\t\t\t\tt->buffer->transaction = NULL;\n\t\t\t\tt->buffer = NULL;\n\t\t\t}\n\t\t\tt = t->to_parent;\n\t\t} else if (t->from == thread) {\n\t\t\tt->from = NULL;\n\t\t\tt = t->from_parent;\n\t\t} else\n\t\t\tBUG();\n\t\tspin_unlock(&last_t->lock);\n\t\tif (t)\n\t\t\tspin_lock(&t->lock);\n\t}\n\n\t/*\n\t * If this thread used poll, make sure we remove the waitqueue\n\t * from any epoll data structures holding it with POLLFREE.\n\t * waitqueue_active() is safe to use here because we're holding\n\t * the inner lock.\n\t */\n\tif ((thread->looper & BINDER_LOOPER_STATE_POLL) &&\n\t    waitqueue_active(&thread->wait)) {\n\t\twake_up_poll(&thread->wait, EPOLLHUP | POLLFREE);\n\t}\n\n\tbinder_inner_proc_unlock(thread->proc);\n\n\tif (send_reply)\n\t\tbinder_send_failed_reply(send_reply, BR_DEAD_REPLY);\n\tbinder_release_work(proc, &thread->todo);\n\tbinder_thread_dec_tmpref(thread);\n\treturn active_transactions;\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2020-0030"
    },
    {
      "commit_id": "6d8c50dcb029872b298eea68cc6209c866fd3e14",
      "filepath": "net/socket.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "sock_close",
      "func_body": "static int sock_close(struct inode *inode, struct file *filp)\n{\n\t__sock_release(SOCKET_I(inode), inode);\n\treturn 0;\n}\n",
      "line_statements": [
        [
          1186,
          "\t__sock_release(SOCKET_I(inode), inode);\n"
        ]
      ],
      "statements": [
        [
          1186,
          "__sock_release(SOCKET_I(inode), inode);"
        ]
      ],
      "cve": "CVE-2018-12232"
    }
  ],
  "CWE-190": [
    {
      "commit_id": "f76275d4a91b28d687250525d3a0c5509bbd666f",
      "filepath": "src/UriQuery.c",
      "project": "uriparser",
      "project_repo_path": "symbol_backend_projects/uriparser",
      "is_vulnerable": false,
      "func_name": "URI_FUNC( ComposeQueryEngine)",
      "func_body": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tint keyRequiredChars;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tint valueRequiredChars;\n\n\t\tif ((keyLen >= INT_MAX / worstCase) || (valueLen >= INT_MAX / worstCase)) {\n\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t}\n\t\tkeyRequiredChars = worstCase * keyLen;\n\t\tvalueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\n\t\t\t/* Copy key */\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}",
      "line_statements": [
        [
          208,
          "\t\tint keyRequiredChars;"
        ],
        [
          210,
          "\t\tint valueRequiredChars;"
        ],
        [
          211,
          ""
        ],
        [
          212,
          "\t\tif ((keyLen >= INT_MAX / worstCase) || (valueLen >= INT_MAX / worstCase)) {"
        ],
        [
          213,
          "\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;"
        ],
        [
          214,
          "\t\t}"
        ],
        [
          215,
          "\t\tkeyRequiredChars = worstCase * keyLen;"
        ],
        [
          216,
          "\t\tvalueRequiredChars = worstCase * valueLen;"
        ]
      ],
      "statements": [
        [
          208,
          "int keyRequiredChars;"
        ],
        [
          210,
          "int valueRequiredChars;"
        ],
        [
          211,
          "\n"
        ],
        [
          212,
          "if ((keyLen >= INT_MAX / worstCase) || (valueLen >= INT_MAX / worstCase))"
        ],
        [
          213,
          "return URI_ERROR_OUTPUT_TOO_LARGE;"
        ],
        [
          214,
          "\t\t}\n"
        ],
        [
          215,
          "keyRequiredChars = worstCase * keyLen;"
        ],
        [
          216,
          "valueRequiredChars = worstCase * valueLen;"
        ]
      ],
      "cve": "CVE-2018-19199"
    },
    {
      "commit_id": "1eb08bcd4634ae42ec45e8284923ac048beaa4c3",
      "filepath": "deps/lua/src/lua_struct.c",
      "project": "redis",
      "project_repo_path": "symbol_backend_projects/redis",
      "is_vulnerable": true,
      "func_name": "b_unpack",
      "func_body": "static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n  defaultoptions(&h);\n  lua_settop(L, 2);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n    luaL_checkstack(L, 1, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res);\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f);\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d);\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (!lua_isnumber(L, -1))\n            luaL_error(L, \"format `c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1);\n          luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size);\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1);\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);\n  return lua_gettop(L) - 2;\n}",
      "line_statements": [
        [
          300,
          "  lua_settop(L, 2);"
        ],
        [
          306,
          "    luaL_checkstack(L, 1, \"too many results\");"
        ],
        [
          312,
          "        lua_pushnumber(L, res);"
        ],
        [
          322,
          "        lua_pushnumber(L, f);"
        ],
        [
          329,
          "        lua_pushnumber(L, d);"
        ],
        [
          334,
          "          if (!lua_isnumber(L, -1))"
        ],
        [
          335,
          "            luaL_error(L, \"format `c0' needs a previous size\");"
        ],
        [
          337,
          "          lua_pop(L, 1);"
        ],
        [
          338,
          "          luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");"
        ],
        [
          340,
          "        lua_pushlstring(L, data+pos, size);"
        ],
        [
          348,
          "        lua_pushlstring(L, data+pos, size - 1);"
        ],
        [
          355,
          "  lua_pushinteger(L, pos + 1);"
        ],
        [
          356,
          "  return lua_gettop(L) - 2;"
        ]
      ],
      "statements": [
        [
          300,
          "lua_settop(L, 2);"
        ],
        [
          306,
          "luaL_checkstack(L, 1, \"too many results\");"
        ],
        [
          312,
          "lua_pushnumber(L, res);"
        ],
        [
          322,
          "lua_pushnumber(L, f);"
        ],
        [
          329,
          "lua_pushnumber(L, d);"
        ],
        [
          334,
          "if (!lua_isnumber(L, -1))"
        ],
        [
          335,
          "luaL_error(L, \"format `c0' needs a previous size\");"
        ],
        [
          337,
          "lua_pop(L, 1);"
        ],
        [
          338,
          "luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");"
        ],
        [
          340,
          "lua_pushlstring(L, data+pos, size);"
        ],
        [
          348,
          "lua_pushlstring(L, data+pos, size - 1);"
        ],
        [
          355,
          "lua_pushinteger(L, pos + 1);"
        ],
        [
          356,
          "return lua_gettop(L) - 2;"
        ]
      ],
      "cve": "CVE-2018-11219"
    },
    {
      "commit_id": "fcd18ce3101f245b083b30655c27b239dc72221e",
      "filepath": "tensorflow/core/grappler/costs/op_level_cost_estimator.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": true,
      "func_name": "tensorflow::grappler::OpLevelCostEstimator::CalculateTensorSize",
      "func_body": "int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \"Count: \" << count << \" DataTypeSize: \" << size;\n  return count * size;\n}",
      "line_statements": [
        [
          1558,
          "  return count * size;"
        ]
      ],
      "statements": [
        [
          1558,
          "return count * size;"
        ]
      ],
      "cve": "CVE-2022-23575"
    },
    {
      "commit_id": "bcf86c01ca4676316557dd482c8416ece8c2e143",
      "filepath": "kernel/trace/tracing_map.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "get_free_elt",
      "func_body": "static struct tracing_map_elt *get_free_elt(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt = NULL;\n\tint idx;\n\n\tidx = atomic_inc_return(&map->next_elt);\n\tif (idx < map->max_elts) {\n\t\telt = *(TRACING_MAP_ELT(map->elts, idx));\n\t\tif (map->ops && map->ops->elt_init)\n\t\t\tmap->ops->elt_init(elt);\n\t}\n\n\treturn elt;\n}\n",
      "line_statements": [
        [
          457,
          "\tidx = atomic_inc_return(&map->next_elt);\n"
        ]
      ],
      "statements": [
        [
          457,
          "idx = atomic_inc_return(&map->next_elt);"
        ]
      ],
      "cve": "CVE-2024-43890"
    },
    {
      "commit_id": "47338393f1f79558f6144213409f09f81d7c4837",
      "filepath": "queue.c",
      "project": "FreeRTOS-Kernel",
      "project_repo_path": "symbol_backend_projects/FreeRTOS-Kernel",
      "is_vulnerable": false,
      "func_name": "xQueueGenericCreate",
      "func_body": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\r\n                                       const UBaseType_t uxItemSize,\r\n                                       const uint8_t ucQueueType )\r\n    {\r\n        Queue_t * pxNewQueue;\r\n        size_t xQueueSizeInBytes;\r\n        uint8_t * pucQueueStorage;\r\n\r\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\r\n\r\n        /* Allocate enough space to hold the maximum number of items that\r\n         * can be in the queue at any time.  It is valid for uxItemSize to be\r\n         * zero in the case the queue is used as a semaphore. */\r\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\r\n\r\n        /* Check for multiplication overflow. */\r\n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\r\n\r\n        /* Check for addition overflow. */\r\n        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );\r\n\r\n        /* Allocate the queue and storage area.  Justification for MISRA\r\n         * deviation as follows:  pvPortMalloc() always ensures returned memory\r\n         * blocks are aligned per the requirements of the MCU stack.  In this case\r\n         * pvPortMalloc() must return a pointer that is guaranteed to meet the\r\n         * alignment requirements of the Queue_t structure - which in this case\r\n         * is an int8_t *.  Therefore, whenever the stack alignment requirements\r\n         * are greater than or equal to the pointer to char requirements the cast\r\n         * is safe.  In other cases alignment requirements are not strict (one or\r\n         * two bytes). */\r\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\r\n\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            /* Jump past the queue structure to find the location of the queue\r\n             * storage area. */\r\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\r\n            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n\r\n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n                {\r\n                    /* Queues can be created either statically or dynamically, so\r\n                     * note this task was created dynamically in case it is later\r\n                     * deleted. */\r\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\r\n                }\r\n            #endif /* configSUPPORT_STATIC_ALLOCATION */\r\n\r\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_CREATE_FAILED( ucQueueType );\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return pxNewQueue;\r\n    }\r",
      "line_statements": [
        [
          401,
          "        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );"
        ],
        [
          402,
          ""
        ]
      ],
      "statements": [
        [
          401,
          "configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );"
        ],
        [
          402,
          "\r\n"
        ]
      ],
      "cve": "CVE-2021-31571"
    },
    {
      "commit_id": "a1e1511dde36b3f8aa27a6ec630838e7ea40e091",
      "filepath": "tensorflow/lite/c/common.c",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "TfLiteIntArrayGetSizeInBytes",
      "func_body": "size_t TfLiteIntArrayGetSizeInBytes(int size) {\n  static TfLiteIntArray dummy;\n\n  size_t computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;\n#if defined(_MSC_VER)\n  // Context for why this is needed is in http://b/189926408#comment21\n  computed_size -= sizeof(dummy.data[0]);\n#endif\n  return computed_size;\n}",
      "line_statements": [
        [
          24,
          "size_t TfLiteIntArrayGetSizeInBytes(int size) {"
        ],
        [
          27,
          "  size_t computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;"
        ]
      ],
      "statements": [
        [
          24,
          "size_t TfLiteIntArrayGetSizeInBytes(int size) {"
        ],
        [
          27,
          "size_t computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;"
        ]
      ],
      "cve": "CVE-2022-23558"
    },
    {
      "commit_id": "1de49725a5fc4e48f1a3b902ec3599ee99283043",
      "filepath": "tensorflow/lite/kernels/embedding_lookup_sparse.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tflite::ops::builtin::Eval",
      "func_body": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));\n  const TfLiteTensor* dense_shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &dense_shape));\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));\n\n  const int lookup_rank = SizeOfDimension(indices, 1);\n  const int embedding_rank = NumDimensions(value);\n  const int num_lookups = SizeOfDimension(ids, 0);\n  const int num_rows = SizeOfDimension(value, 0);\n\n  // The last dimension gets replaced by the embedding.\n  const int output_rank = (lookup_rank - 1) + (embedding_rank - 1);\n\n  // Make sure that the actual dense shape of the sparse tensor represented by\n  // (loopkup, indices, dense_shape) is consistent.\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank);\n\n  // Resize output tensor.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);\n  TF_LITE_ENSURE(context, output_shape != nullptr);\n  int k = 0;\n  size_t embedding_size = 1;\n  size_t lookup_size = 1;\n  for (int i = 0; i < lookup_rank - 1; i++, k++) {\n    const size_t dim = dense_shape->data.i32[i];\n    TF_LITE_ENSURE_MSG(\n        context,\n        MultiplyAndCheckOverflow(lookup_size, dim, &lookup_size) == kTfLiteOk,\n        \"Lookup size overflowed.\");\n    output_shape->data[k] = dim;\n  }\n  for (int i = 1; i < embedding_rank; i++, k++) {\n    const size_t dim = SizeOfDimension(value, i);\n    TF_LITE_ENSURE_MSG(context,\n                       MultiplyAndCheckOverflow(embedding_size, dim,\n                                                &embedding_size) == kTfLiteOk,\n                       \"Embedding size overflowed.\");\n    output_shape->data[k] = dim;\n  }\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));\n  const size_t output_size = lookup_size * embedding_size;\n  TfLiteTensorRealloc(output_size * sizeof(float), output);\n\n  float* output_ptr = GetTensorData<float>(output);\n  const float* weights_ptr = GetTensorData<float>(weights);\n  const float* value_ptr = GetTensorData<float>(value);\n  // Makes sure reallocation was successful.\n  TF_LITE_ENSURE(context, output_ptr != nullptr);\n\n  std::fill_n(output_ptr, output_size, 0.0f);\n\n  // Keep track of the current bucket for aggregation/combination.\n  int current_output_offset = 0;\n  float current_total_weight = 0.0;\n  float current_squares_weight = 0.0;\n  int num_elements = 0;\n\n  for (int i = 0; i < num_lookups; i++) {\n    int idx = ids->data.i32[i];\n    if (idx >= num_rows || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup Sparse: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, num_rows - 1);\n      return kTfLiteError;\n    }\n\n    // Check where we need to aggregate.\n    const int example_indices_offset = i * lookup_rank;\n    int output_bucket = 0;\n    int stride = 1;\n    for (int k = (lookup_rank - 1) - 1; k >= 0; k--) {\n      output_bucket += indices->data.i32[example_indices_offset + k] * stride;\n      stride *= dense_shape->data.i32[k];\n    }\n    const int output_offset = output_bucket * embedding_size;\n\n    // If we are in a new aggregation bucket and the combiner is not the sum,\n    // go back and finalize the result of the previous bucket.\n    if (output_offset != current_output_offset) {\n      FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                          current_squares_weight, embedding_size,\n                          &output_ptr[current_output_offset]);\n\n      // Track next bucket.\n      num_elements = 0;\n      current_total_weight = 0.0;\n      current_squares_weight = 0.0;\n      current_output_offset = output_offset;\n    }\n\n    // Add element to aggregation.\n    ++num_elements;\n    const int example_embedding_offset = idx * embedding_size;\n    const float w = weights_ptr[i];\n    current_squares_weight += w * w;\n    current_total_weight += w;\n    for (int k = 0; k < embedding_size; k++) {\n      output_ptr[current_output_offset + k] +=\n          value_ptr[example_embedding_offset + k] * w;\n    }\n  }\n\n  // Finalize last bucket.\n  FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                      current_squares_weight, embedding_size,\n                      &GetTensorData<float>(output)[current_output_offset]);\n\n  return kTfLiteOk;\n}",
      "line_statements": [
        [
          179,
          "  size_t embedding_size = 1;"
        ],
        [
          180,
          "  size_t lookup_size = 1;"
        ],
        [
          182,
          "    const size_t dim = dense_shape->data.i32[i];"
        ],
        [
          183,
          "    TF_LITE_ENSURE_MSG("
        ],
        [
          184,
          "        context,"
        ],
        [
          185,
          "        MultiplyAndCheckOverflow(lookup_size, dim, &lookup_size) == kTfLiteOk,"
        ],
        [
          186,
          "        \"Lookup size overflowed.\");"
        ],
        [
          190,
          "    const size_t dim = SizeOfDimension(value, i);"
        ],
        [
          191,
          "    TF_LITE_ENSURE_MSG(context,"
        ],
        [
          192,
          "                       MultiplyAndCheckOverflow(embedding_size, dim,"
        ],
        [
          193,
          "                                                &embedding_size) == kTfLiteOk,"
        ],
        [
          194,
          "                       \"Embedding size overflowed.\");"
        ],
        [
          198,
          "  const size_t output_size = lookup_size * embedding_size;"
        ],
        [
          205,
          "  TF_LITE_ENSURE(context, output_ptr != nullptr);"
        ]
      ],
      "statements": [
        [
          179,
          "size_t embedding_size = 1;"
        ],
        [
          180,
          "size_t lookup_size = 1;"
        ],
        [
          182,
          "const size_t dim = dense_shape->data.i32[i];"
        ],
        [
          183,
          "TF_LITE_ENSURE_MSG(\n        context,\n        MultiplyAndCheckOverflow(lookup_size, dim, &lookup_size) == kTfLiteOk,\n        \"Lookup size overflowed.\");"
        ],
        [
          190,
          "const size_t dim = SizeOfDimension(value, i);"
        ],
        [
          191,
          "TF_LITE_ENSURE_MSG(context,\n                       MultiplyAndCheckOverflow(embedding_size, dim,\n                                                &embedding_size) == kTfLiteOk,\n                       \"Embedding size overflowed.\");"
        ],
        [
          192,
          "MultiplyAndCheckOverflow(embedding_size, dim,\n                                                &embedding_size) == kTfLiteOk"
        ],
        [
          198,
          "const size_t output_size = lookup_size * embedding_size;"
        ],
        [
          205,
          "TF_LITE_ENSURE(context, output_ptr != nullptr);"
        ]
      ],
      "cve": "CVE-2022-23559"
    },
    {
      "commit_id": "53d8c8f3d181d87a6aa925b449b51c4a2c922a51",
      "filepath": "icu4c/source/i18n/fmtable.cpp",
      "project": "icu",
      "project_repo_path": "symbol_backend_projects/icu",
      "is_vulnerable": true,
      "func_name": "Formattable::internalGetCharString",
      "func_body": "CharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        // No decimal number for the formattable yet.  Which means the value was\n        // set directly by the user as an int, int64 or double.  If the value came\n        // from parsing, or from the user setting a decimal number, fDecimalNum\n        // would already be set.\n        //\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      // Older ICUs called uprv_decNumberToString here, which is not exactly the same as\n      // DecimalQuantity::toScientificString(). The biggest difference is that uprv_decNumberToString does\n      // not print scientific notation for magnitudes greater than -5 and smaller than some amount (+5?).\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}",
      "line_statements": [
        [
          737,
          "      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {"
        ]
      ],
      "statements": [
        [
          737,
          "else if (std::abs(fDecimalQuantity->getMagnitude()) < 5)"
        ]
      ],
      "cve": "CVE-2018-18928"
    },
    {
      "commit_id": "7722455726bec8c53458a32851d2a87982cf0eac",
      "filepath": "ext/gd/libgd/gd_gd2.c",
      "project": "php-src",
      "project_repo_path": "symbol_backend_projects/php-src",
      "is_vulnerable": false,
      "func_name": "_gd2GetHeader",
      "func_body": "static int _gd2GetHeader(gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, int *fmt, int *ncx, int *ncy, t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG(php_gd_error(\"Reading gd2 header info\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC(in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tid[i] = ch;\n\t}\n\tid[4] = 0;\n\n\tGD2_DBG(php_gd_error(\"Got file code: %s\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp(id, GD2_ID) != 0) {\n\t\tGD2_DBG(php_gd_error(\"Not a valid gd2 file\"));\n\t\tgoto fail1;\n\t}\n\n\t/* Version */\n\tif (gdGetWord(vers, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Version: %d\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG(php_gd_error(\"Bad version: %d\", *vers));\n\t\tgoto fail1;\n\t}\n\n\t/* Image Size */\n\tif (!gdGetWord(sx, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get x-size\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord(sy, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get y-size\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Image is %dx%d\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord(cs, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"ChunkSize: %d\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG(php_gd_error(\"Bad chunk size: %d\", *cs));\n\t\tgoto fail1;\n\t}\n\n\t/* Data Format */\n\tif (gdGetWord(fmt, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Format: %d\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) && (*fmt != GD2_FMT_TRUECOLOR_RAW) && (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG(php_gd_error(\"Bad data format: %d\", *fmt));\n\t\tgoto fail1;\n\t}\n\n\t/* # of chunks wide */\n\tif (gdGetWord(ncx, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks Wide\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord(ncy, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks vertically\", *ncy));\n\n\tif (gd2_compressed(*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG(php_gd_error(\"Reading %d chunk index entries\", nc));\n\t\tif (overflow2(sidx, nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof(t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tcidx = gdCalloc(sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt(&cidx[i].offset, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (gdGetInt(&cidx[i].size, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t*chunkIdx = cidx;\n\t}\n\n\tGD2_DBG(php_gd_error(\"gd2 header complete\"));\n\n\treturn 1;\n\nfail1:\n\treturn 0;\n}",
      "line_statements": [
        [
          141,
          "\t\tif (overflow2(sidx, nc)) {"
        ],
        [
          142,
          "\t\t\tgoto fail1;"
        ],
        [
          143,
          "\t\t}"
        ],
        [
          149,
          "\t\tif (cidx == NULL) {"
        ],
        [
          150,
          "\t\t\tgoto fail1;"
        ],
        [
          151,
          "\t\t}"
        ],
        [
          152,
          ""
        ]
      ],
      "statements": [
        [
          141,
          "if (overflow2(sidx, nc))"
        ],
        [
          142,
          "goto fail1;"
        ],
        [
          143,
          "\t\t}\n"
        ],
        [
          149,
          "if (cidx == NULL)"
        ],
        [
          150,
          "goto fail1;"
        ],
        [
          151,
          "\t\t}\n"
        ],
        [
          152,
          "\n"
        ]
      ],
      "cve": "CVE-2016-5766"
    },
    {
      "commit_id": "194f592e205990ea8fce72b6c571c14350aca716",
      "filepath": "dcraw_foveon.c",
      "project": "LibRaw-demosaic-pack-GPL2",
      "project_repo_path": "symbol_backend_projects/LibRaw-demosaic-pack-GPL2",
      "is_vulnerable": false,
      "func_name": "foveon_load_camf",
      "func_body": "void CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[1024], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  type = get4();  get4();  get4();\n  wide = get4();\n  high = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(wide>32767 || high > 32767 || wide*high > 20000000)\n     throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  if (type == 2) {\n    fread (meta_data, 1, meta_length, ifp);\n    for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);\n    merror (meta_data, \"foveon_load_camf()\");\n    foveon_huff (huff);\n    get4();\n    getbits(-1);\n    for (j=row=0; row < high; row++) {\n      for (col=0; col < wide; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse         hpred[col & 1] += diff;\n\tif (col & 1) {\n\t  meta_data[j++] = hpred[0] >> 4;\n\t  meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n\t  meta_data[j++] = hpred[1];\n        }\n      }\n    }\n  } else\n    fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n}",
      "line_statements": [
        [
          349,
          "  ushort huff[1024], vpred[2][2] = {{512,512},{512,512}}, hpred[2];"
        ],
        [
          355,
          "#ifdef LIBRAW_LIBRARY_BUILD"
        ],
        [
          356,
          "  if(wide>32767 || high > 32767 || wide*high > 20000000)"
        ],
        [
          357,
          "     throw LIBRAW_EXCEPTION_IO_CORRUPT;"
        ],
        [
          358,
          "#endif"
        ]
      ],
      "statements": [
        [
          349,
          "ushort huff[1024], vpred[2][2] = {{512,512},{512,512}}, hpred[2];"
        ],
        [
          355,
          "#ifdef LIBRAW_LIBRARY_BUILD\n  if(wide>32767 || high > 32767 || wide*high > 20000000)\n     throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif"
        ],
        [
          356,
          "if(wide>32767 || high > 32767 || wide*high > 20000000)\n     throw"
        ]
      ],
      "cve": "CVE-2017-6889"
    },
    {
      "commit_id": "a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00",
      "filepath": "memcached.c",
      "project": "memcached",
      "project_repo_path": "symbol_backend_projects/memcached",
      "is_vulnerable": false,
      "func_name": "limited_get",
      "func_body": "static inline item* limited_get(char *key, size_t nkey, conn *c) {\n    item *it = item_get(key, nkey, c, DO_UPDATE);\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        item_remove(it);\n        it = NULL;\n    }\n    return it;\n}",
      "line_statements": [
        [
          3253,
          "static inline item* limited_get(char *key, size_t nkey, conn *c) {"
        ],
        [
          3254,
          "    item *it = item_get(key, nkey, c, DO_UPDATE);"
        ],
        [
          3255,
          "    if (it && it->refcount > IT_REFCOUNT_LIMIT) {"
        ],
        [
          3256,
          "        item_remove(it);"
        ],
        [
          3257,
          "        it = NULL;"
        ],
        [
          3258,
          "    }"
        ],
        [
          3259,
          "    return it;"
        ],
        [
          3260,
          "}"
        ]
      ],
      "statements": [
        [
          3253,
          "static inline item* limited_get(char *key, size_t nkey, conn *c) {"
        ],
        [
          3254,
          "item *it = item_get(key, nkey, c, DO_UPDATE);"
        ],
        [
          3255,
          "if (it && it->refcount > IT_REFCOUNT_LIMIT)"
        ],
        [
          3256,
          "item_remove(it);"
        ],
        [
          3257,
          "it = NULL;"
        ],
        [
          3258,
          "    }\n"
        ],
        [
          3259,
          "return it;"
        ],
        [
          3260,
          "}"
        ]
      ],
      "cve": "CVE-2018-1000127"
    },
    {
      "commit_id": "8d2b1a1ec9f559d30b724877da4ce592edc41fdc",
      "filepath": "drivers/net/usb/cdc_ncm.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "cdc_ncm_rx_fixup",
      "func_body": "int cdc_ncm_rx_fixup(struct usbnet *dev, struct sk_buff *skb_in)\n{\n\tstruct sk_buff *skb;\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tunsigned int len;\n\tint nframes;\n\tint x;\n\tunsigned int offset;\n\tunion {\n\t\tstruct usb_cdc_ncm_ndp16 *ndp16;\n\t\tstruct usb_cdc_ncm_ndp32 *ndp32;\n\t} ndp;\n\tunion {\n\t\tstruct usb_cdc_ncm_dpe16 *dpe16;\n\t\tstruct usb_cdc_ncm_dpe32 *dpe32;\n\t} dpe;\n\n\tint ndpoffset;\n\tint loopcount = 50; /* arbitrary max preventing infinite loop */\n\tu32 payload = 0;\n\n\tif (ctx->is_ndp16)\n\t\tndpoffset = cdc_ncm_rx_verify_nth16(ctx, skb_in);\n\telse\n\t\tndpoffset = cdc_ncm_rx_verify_nth32(ctx, skb_in);\n\n\tif (ndpoffset < 0)\n\t\tgoto error;\n\nnext_ndp:\n\tif (ctx->is_ndp16) {\n\t\tnframes = cdc_ncm_rx_verify_ndp16(skb_in, ndpoffset);\n\t\tif (nframes < 0)\n\t\t\tgoto error;\n\n\t\tndp.ndp16 = (struct usb_cdc_ncm_ndp16 *)(skb_in->data + ndpoffset);\n\n\t\tif (ndp.ndp16->dwSignature != cpu_to_le32(USB_CDC_NCM_NDP16_NOCRC_SIGN)) {\n\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t  \"invalid DPT16 signature <%#010x>\\n\",\n\t\t\t\t  le32_to_cpu(ndp.ndp16->dwSignature));\n\t\t\tgoto err_ndp;\n\t\t}\n\t\tdpe.dpe16 = ndp.ndp16->dpe16;\n\t} else {\n\t\tnframes = cdc_ncm_rx_verify_ndp32(skb_in, ndpoffset);\n\t\tif (nframes < 0)\n\t\t\tgoto error;\n\n\t\tndp.ndp32 = (struct usb_cdc_ncm_ndp32 *)(skb_in->data + ndpoffset);\n\n\t\tif (ndp.ndp32->dwSignature != cpu_to_le32(USB_CDC_NCM_NDP32_NOCRC_SIGN)) {\n\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t  \"invalid DPT32 signature <%#010x>\\n\",\n\t\t\t\t  le32_to_cpu(ndp.ndp32->dwSignature));\n\t\t\tgoto err_ndp;\n\t\t}\n\t\tdpe.dpe32 = ndp.ndp32->dpe32;\n\t}\n\n\tfor (x = 0; x < nframes; x++) {\n\t\tif (ctx->is_ndp16) {\n\t\t\toffset = le16_to_cpu(dpe.dpe16->wDatagramIndex);\n\t\t\tlen = le16_to_cpu(dpe.dpe16->wDatagramLength);\n\t\t} else {\n\t\t\toffset = le32_to_cpu(dpe.dpe32->dwDatagramIndex);\n\t\t\tlen = le32_to_cpu(dpe.dpe32->dwDatagramLength);\n\t\t}\n\n\t\t/*\n\t\t * CDC NCM ch. 3.7\n\t\t * All entries after first NULL entry are to be ignored\n\t\t */\n\t\tif ((offset == 0) || (len == 0)) {\n\t\t\tif (!x)\n\t\t\t\tgoto err_ndp; /* empty NTB */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* sanity checking - watch out for integer wrap*/\n\t\tif ((offset > skb_in->len) || (len > skb_in->len - offset) ||\n\t\t\t\t(len > ctx->rx_max) || (len < ETH_HLEN)) {\n\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t  \"invalid frame detected (ignored) offset[%u]=%u, length=%u, skb=%p\\n\",\n\t\t\t\t  x, offset, len, skb_in);\n\t\t\tif (!x)\n\t\t\t\tgoto err_ndp;\n\t\t\tbreak;\n\n\t\t} else {\n\t\t\t/* create a fresh copy to reduce truesize */\n\t\t\tskb = netdev_alloc_skb_ip_align(dev->net,  len);\n\t\t\tif (!skb)\n\t\t\t\tgoto error;\n\t\t\tskb_put_data(skb, skb_in->data + offset, len);\n\t\t\tusbnet_skb_return(dev, skb);\n\t\t\tpayload += len;\t/* count payload bytes in this NTB */\n\t\t}\n\n\t\tif (ctx->is_ndp16)\n\t\t\tdpe.dpe16++;\n\t\telse\n\t\t\tdpe.dpe32++;\n\t}\nerr_ndp:\n\t/* are there more NDPs to process? */\n\tif (ctx->is_ndp16)\n\t\tndpoffset = le16_to_cpu(ndp.ndp16->wNextNdpIndex);\n\telse\n\t\tndpoffset = le32_to_cpu(ndp.ndp32->dwNextNdpIndex);\n\n\tif (ndpoffset && loopcount--)\n\t\tgoto next_ndp;\n\n\t/* update stats */\n\tctx->rx_overhead += skb_in->len - payload;\n\tctx->rx_ntbs++;\n\n\treturn 1;\nerror:\n\treturn 0;\n}\n",
      "line_statements": [
        [
          1718,
          "\tunsigned int len;\n"
        ],
        [
          1721,
          "\tunsigned int offset;\n"
        ],
        [
          1793,
          "\t\t/* sanity checking - watch out for integer wrap*/\n"
        ],
        [
          1794,
          "\t\tif ((offset > skb_in->len) || (len > skb_in->len - offset) ||\n"
        ]
      ],
      "statements": [
        [
          1718,
          "unsigned int len;"
        ],
        [
          1721,
          "unsigned int offset;"
        ],
        [
          1793,
          "/* sanity checking - watch out for integer wrap*/"
        ],
        [
          1794,
          "if ((offset > skb_in->len) || (len > skb_in->len - offset) ||\n\t\t\t\t(len > ctx->rx_max) || (len < ETH_HLEN))"
        ]
      ],
      "cve": "CVE-2022-48938"
    },
    {
      "commit_id": "8e2734bf444767fed787305ccdcb36a2be5301a2",
      "filepath": "drivers/gpu/drm/amd/display/dc/dml/calcs/dcn_calcs.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "dcn_bw_update_from_pplib_fclks",
      "func_body": "void dcn_bw_update_from_pplib_fclks(\n\tstruct dc *dc,\n\tstruct dm_pp_clock_levels_with_voltage *fclks)\n{\n\tunsigned vmin0p65_idx, vmid0p72_idx, vnom0p8_idx, vmax0p9_idx;\n\n\tASSERT(fclks->num_levels);\n\n\tvmin0p65_idx = 0;\n\tvmid0p72_idx = fclks->num_levels -\n\t\t(fclks->num_levels > 2 ? 3 : (fclks->num_levels > 1 ? 2 : 1));\n\tvnom0p8_idx = fclks->num_levels - (fclks->num_levels > 1 ? 2 : 1);\n\tvmax0p9_idx = fclks->num_levels - 1;\n\n\tdc->dcn_soc->fabric_and_dram_bandwidth_vmin0p65 =\n\t\t32 * (fclks->data[vmin0p65_idx].clocks_in_khz / 1000.0) / 1000.0;\n\tdc->dcn_soc->fabric_and_dram_bandwidth_vmid0p72 =\n\t\tdc->dcn_soc->number_of_channels *\n\t\t(fclks->data[vmid0p72_idx].clocks_in_khz / 1000.0)\n\t\t* ddr4_dram_factor_single_Channel / 1000.0;\n\tdc->dcn_soc->fabric_and_dram_bandwidth_vnom0p8 =\n\t\tdc->dcn_soc->number_of_channels *\n\t\t(fclks->data[vnom0p8_idx].clocks_in_khz / 1000.0)\n\t\t* ddr4_dram_factor_single_Channel / 1000.0;\n\tdc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 =\n\t\tdc->dcn_soc->number_of_channels *\n\t\t(fclks->data[vmax0p9_idx].clocks_in_khz / 1000.0)\n\t\t* ddr4_dram_factor_single_Channel / 1000.0;\n}\n",
      "line_statements": [
        [
          1456,
          "\tvmid0p72_idx = fclks->num_levels -\n"
        ],
        [
          1457,
          "\t\t(fclks->num_levels > 2 ? 3 : (fclks->num_levels > 1 ? 2 : 1));\n"
        ],
        [
          1458,
          "\tvnom0p8_idx = fclks->num_levels - (fclks->num_levels > 1 ? 2 : 1);\n"
        ],
        [
          1459,
          "\tvmax0p9_idx = fclks->num_levels - 1;\n"
        ]
      ],
      "statements": [
        [
          1456,
          "vmid0p72_idx = fclks->num_levels -\n\t\t(fclks->num_levels > 2 ? 3 : (fclks->num_levels > 1 ? 2 : 1));"
        ],
        [
          1458,
          "vnom0p8_idx = fclks->num_levels - (fclks->num_levels > 1 ? 2 : 1);"
        ],
        [
          1459,
          "vmax0p9_idx = fclks->num_levels - 1;"
        ]
      ],
      "cve": "CVE-2024-46726"
    }
  ],
  "CWE-200": [
    {
      "commit_id": "5800dc5c19f34e6e03b5adab1282535cb102fafd",
      "filepath": "arch/x86/kernel/paravirt.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "paravirt_patch_jmp",
      "func_body": "unsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (len < 5)\n\t\treturn len;\t/* call too long for patch site */\n\n\tb->opcode = 0xe9;\t/* jmp */\n\tb->delta = delta;\n\n\treturn 5;\n}",
      "line_statements": [
        [
          109,
          "\tif (len < 5)"
        ]
      ],
      "statements": [
        [
          109,
          "if (len < 5)"
        ]
      ],
      "cve": "CVE-2018-15594"
    },
    {
      "commit_id": "681fef8380eb818c0b845fca5d2ab1dcbab114ee",
      "filepath": "drivers/usb/core/devio.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "proc_connectinfo",
      "func_body": "static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_connectinfo ci = {\n\t\t.devnum = ps->dev->devnum,\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n\t};\n\n\tif (copy_to_user(arg, &ci, sizeof(ci)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
      "line_statements": [
        [
          1319,
          "\tstruct usbdevfs_connectinfo ci = {"
        ],
        [
          1320,
          "\t\t.devnum = ps->dev->devnum,"
        ],
        [
          1321,
          "\t\t.slow = ps->dev->speed == USB_SPEED_LOW"
        ],
        [
          1322,
          "\t};"
        ]
      ],
      "statements": [
        [
          1319,
          "struct usbdevfs_connectinfo ci = {\n\t\t.devnum = ps->dev->devnum,\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n\t};"
        ]
      ],
      "cve": "CVE-2016-4482"
    },
    {
      "commit_id": "e0c9c0afd2fc958ffa34b697972721d81df8a56f",
      "filepath": "fs/namespace.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "umount_tree",
      "func_body": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = !(((how & UMOUNT_CONNECTED) &&\n\t\t\t\tmnt_has_parent(p) &&\n\t\t\t\t(p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||\n\t\t\t       IS_MNT_LOCKED_AND_LAZY(p));\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t/* Don't forget about p */\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
      "line_statements": [
        [
          1390,
          "\t\tdisconnect = !(((how & UMOUNT_CONNECTED) &&"
        ],
        [
          1391,
          "\t\t\t\tmnt_has_parent(p) &&"
        ],
        [
          1392,
          "\t\t\t\t(p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||"
        ],
        [
          1393,
          "\t\t\t       IS_MNT_LOCKED_AND_LAZY(p));"
        ]
      ],
      "statements": [
        [
          1390,
          "disconnect = !(((how & UMOUNT_CONNECTED) &&\n\t\t\t\tmnt_has_parent(p) &&\n\t\t\t\t(p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||\n\t\t\t       IS_MNT_LOCKED_AND_LAZY(p));"
        ]
      ],
      "cve": "CVE-2015-4176"
    },
    {
      "commit_id": "06bd3c36a733ac27962fea7d6f47168841376824",
      "filepath": "fs/ext4/inode.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "ext4_map_blocks",
      "func_body": "int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EFSCORRUPTED;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tmap->m_pblk = 0;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    !(status & EXTENT_STATUS_WRITTEN) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * We have to zeroout blocks before inserting them into extent\n\t\t * status tree. Otherwise someone could look them up there and\n\t\t * use them before they are really zeroed.\n\t\t */\n\t\tif (flags & EXT4_GET_BLOCKS_ZERO &&\n\t\t    map->m_flags & EXT4_MAP_MAPPED &&\n\t\t    map->m_flags & EXT4_MAP_NEW) {\n\t\t\tret = ext4_issue_zeroout(inode, map->m_lblk,\n\t\t\t\t\t\t map->m_pblk, map->m_len);\n\t\t\tif (ret) {\n\t\t\t\tretval = ret;\n\t\t\t\tgoto out_sem;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto out_sem;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    !(status & EXTENT_STATUS_WRITTEN) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0) {\n\t\t\tretval = ret;\n\t\t\tgoto out_sem;\n\t\t}\n\t}\n\nout_sem:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * Inodes with freshly allocated blocks where contents will be\n\t\t * visible after transaction commit must be on transaction's\n\t\t * ordered data list.\n\t\t */\n\t\tif (map->m_flags & EXT4_MAP_NEW &&\n\t\t    !(map->m_flags & EXT4_MAP_UNWRITTEN) &&\n\t\t    !(flags & EXT4_GET_BLOCKS_ZERO) &&\n\t\t    !IS_NOQUOTA(inode) &&\n\t\t    ext4_should_order_data(inode)) {\n\t\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn retval;\n}",
      "line_statements": [
        [
          687,
          ""
        ],
        [
          693,
          "\t\tif (map->m_flags & EXT4_MAP_NEW &&"
        ],
        [
          694,
          "\t\t    !(map->m_flags & EXT4_MAP_UNWRITTEN) &&"
        ],
        [
          695,
          "\t\t    !(flags & EXT4_GET_BLOCKS_ZERO) &&"
        ],
        [
          696,
          "\t\t    !IS_NOQUOTA(inode) &&"
        ],
        [
          697,
          "\t\t    ext4_should_order_data(inode)) {"
        ],
        [
          698,
          "\t\t\tret = ext4_jbd2_file_inode(handle, inode);"
        ],
        [
          699,
          "\t\t\tif (ret)"
        ],
        [
          700,
          "\t\t\t\treturn ret;"
        ],
        [
          701,
          "\t\t}"
        ]
      ],
      "statements": [
        [
          687,
          "\n"
        ],
        [
          693,
          "if (map->m_flags & EXT4_MAP_NEW &&\n\t\t    !(map->m_flags & EXT4_MAP_UNWRITTEN) &&\n\t\t    !(flags & EXT4_GET_BLOCKS_ZERO) &&\n\t\t    !IS_NOQUOTA(inode) &&\n\t\t    ext4_should_order_data(inode))"
        ],
        [
          698,
          "ret = ext4_jbd2_file_inode(handle, inode);"
        ],
        [
          699,
          "if (ret)"
        ],
        [
          700,
          "return ret;"
        ],
        [
          701,
          "\t\t}\n"
        ]
      ],
      "cve": "CVE-2017-7495"
    },
    {
      "commit_id": "5233252fce714053f0151680933571a2da9cbfb4",
      "filepath": "net/bluetooth/sco.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "sco_sock_bind",
      "func_body": "static int sco_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tif (addr_len < sizeof(struct sockaddr_sco))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tbacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);\n\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
      "line_statements": [
        [
          529,
          "\tif (addr_len < sizeof(struct sockaddr_sco))"
        ],
        [
          530,
          "\t\treturn -EINVAL;"
        ],
        [
          531,
          ""
        ]
      ],
      "statements": [
        [
          529,
          "if (addr_len < sizeof(struct sockaddr_sco))"
        ],
        [
          530,
          "return -EINVAL;"
        ],
        [
          531,
          "\n"
        ]
      ],
      "cve": "CVE-2015-8575"
    },
    {
      "commit_id": "e4ec8cc8039a7063e24204299b462bd1383184a5",
      "filepath": "sound/core/timer.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "snd_timer_user_tinterrupt",
      "func_body": "static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n\t    tu->last_resolution != resolution) {\n\t\tmemset(&r1, 0, sizeof(r1));\n\t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n\t\tr1.tstamp = tstamp;\n\t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}",
      "line_statements": [
        [
          1269,
          "\t\tmemset(&r1, 0, sizeof(r1));"
        ]
      ],
      "statements": [
        [
          1269,
          "memset(&r1, 0, sizeof(r1));"
        ]
      ],
      "cve": "CVE-2016-4578"
    },
    {
      "commit_id": "48fc8df51d99f9d8ba251219367b3d629cc848e3",
      "filepath": "src/lib/pubkey/dsa/dsa.cpp",
      "project": "botan",
      "project_repo_path": "symbol_backend_projects/botan",
      "is_vulnerable": false,
      "func_name": "Botan::DSA_Signature_Operation::DSA_Signature_Operation",
      "func_body": "      DSA_Signature_Operation(const DSA_PrivateKey& dsa,\n                              const std::string& emsa,\n                              RandomNumberGenerator& rng) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_x(dsa.get_x()),\n         m_mod_q(dsa.group_q())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n\n         m_b = BigInt::random_integer(rng, 2, dsa.group_q());\n         m_b_inv = inverse_mod(m_b, dsa.group_q());\n         }",
      "line_statements": [
        [
          77,
          "      DSA_Signature_Operation(const DSA_PrivateKey& dsa,"
        ],
        [
          78,
          "                              const std::string& emsa,"
        ],
        [
          79,
          "                              RandomNumberGenerator& rng) :"
        ],
        [
          88,
          ""
        ],
        [
          89,
          "         m_b = BigInt::random_integer(rng, 2, dsa.group_q());"
        ],
        [
          90,
          "         m_b_inv = inverse_mod(m_b, dsa.group_q());"
        ]
      ],
      "statements": [
        [
          77,
          "DSA_Signature_Operation(const DSA_PrivateKey& dsa,\n                              const std::string& emsa,\n                              RandomNumberGenerator& rng) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_x(dsa.get_x()),\n         m_mod_q(dsa.group_q())"
        ],
        [
          88,
          "\n"
        ],
        [
          89,
          "m_b = BigInt::random_integer(rng, 2, dsa.group_q());"
        ],
        [
          90,
          "m_b_inv = inverse_mod(m_b, dsa.group_q());"
        ]
      ],
      "cve": "CVE-2018-12435"
    },
    {
      "commit_id": "11d21349a4e7e38a025849479b36ace7c2eec2ee",
      "filepath": "src/openvpn/crypto.c",
      "project": "openvpn",
      "project_repo_path": "symbol_backend_projects/openvpn",
      "is_vulnerable": false,
      "func_name": "openvpn_decrypt",
      "func_body": "openvpn_decrypt (struct buffer *buf, struct buffer work,\n\t\t const struct crypto_options *opt,\n\t\t const struct frame* frame)\n{\n  static const char error_prefix[] = \"Authenticate/Decrypt packet error\";\n  struct gc_arena gc;\n  gc_init (&gc);\n\n  if (buf->len > 0 && opt->key_ctx_bi)\n    {\n      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;\n      struct packet_id_net pin;\n      bool have_pin = false;\n\n      /* Verify the HMAC */\n      if (ctx->hmac)\n\t{\n\t  int hmac_len;\n\t  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */\n\n\t  hmac_ctx_reset(ctx->hmac);\n\n\t  /* Assume the length of the input HMAC */\n\t  hmac_len = hmac_ctx_size (ctx->hmac);\n\n\t  /* Authentication fails if insufficient data in packet for HMAC */\n\t  if (buf->len < hmac_len)\n\t    CRYPT_ERROR (\"missing authentication info\");\n\n\t  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);\n\t  hmac_ctx_final (ctx->hmac, local_hmac);\n\n\t  /* Compare locally computed HMAC with packet HMAC */\n\t  if (memcmp_constant_time (local_hmac, BPTR (buf), hmac_len))\n\t    CRYPT_ERROR (\"packet HMAC authentication failed\");\n\n\t  ASSERT (buf_advance (buf, hmac_len));\n\t}\n\n      /* Decrypt packet ID + payload */\n\n      if (ctx->cipher)\n\t{\n\t  const unsigned int mode = cipher_ctx_mode (ctx->cipher);\n\t  const int iv_size = cipher_ctx_iv_length (ctx->cipher);\n\t  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];\n\t  int outlen;\n\n\t  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */\n\t  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));\n\n\t  /* use IV if user requested it */\n\t  CLEAR (iv_buf);\n\t  if (opt->flags & CO_USE_IV)\n\t    {\n\t      if (buf->len < iv_size)\n\t\tCRYPT_ERROR (\"missing IV info\");\n\t      memcpy (iv_buf, BPTR (buf), iv_size);\n\t      ASSERT (buf_advance (buf, iv_size));\n\t    }\n\n\t  /* show the IV's initial state */\n\t  if (opt->flags & CO_USE_IV)\n\t    dmsg (D_PACKET_CONTENT, \"DECRYPT IV: %s\", format_hex (iv_buf, iv_size, 0, &gc));\n\n\t  if (buf->len < 1)\n\t    CRYPT_ERROR (\"missing payload\");\n\n\t  /* ctx->cipher was already initialized with key & keylen */\n\t  if (!cipher_ctx_reset (ctx->cipher, iv_buf))\n\t    CRYPT_ERROR (\"cipher init failed\");\n\n\t  /* Buffer overflow check (should never happen) */\n\t  if (!buf_safe (&work, buf->len))\n\t    CRYPT_ERROR (\"buffer overflow\");\n\n\t  /* Decrypt packet ID, payload */\n\t  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))\n\t    CRYPT_ERROR (\"cipher update failed\");\n\t  work.len += outlen;\n\n\t  /* Flush the decryption buffer */\n\t  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))\n\t    CRYPT_ERROR (\"cipher final failed\");\n\t  work.len += outlen;\n\n\t  dmsg (D_PACKET_CONTENT, \"DECRYPT TO: %s\",\n\t       format_hex (BPTR (&work), BLEN (&work), 80, &gc));\n\n\t  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */\n\t  {\n\t    if (mode == OPENVPN_MODE_CBC)\n\t      {\n\t\tif (opt->packet_id)\n\t\t  {\n\t\t    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\t      CRYPT_ERROR (\"error reading CBC packet-id\");\n\t\t    have_pin = true;\n\t\t  }\n\t      }\n\t    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)\n\t      {\n\t\tstruct buffer b;\n\n\t\tASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */\n\t\tASSERT (opt->packet_id); /*  for this mode. */\n\n\t\tbuf_set_read (&b, iv_buf, iv_size);\n\t\tif (!packet_id_read (&pin, &b, true))\n\t\t  CRYPT_ERROR (\"error reading CFB/OFB packet-id\");\n\t\thave_pin = true;\n\t      }\n\t    else /* We only support CBC, CFB, or OFB modes right now */\n\t      {\n\t\tASSERT (0);\n\t      }\n\t  }\n\t}\n      else\n\t{\n\t  work = *buf;\n\t  if (opt->packet_id)\n\t    {\n\t      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\tCRYPT_ERROR (\"error reading packet-id\");\n\t      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);\n\t    }\n\t}\n      \n      if (have_pin)\n\t{\n\t  packet_id_reap_test (&opt->packet_id->rec);\n\t  if (packet_id_test (&opt->packet_id->rec, &pin))\n\t    {\n\t      packet_id_add (&opt->packet_id->rec, &pin);\n\t      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))\n\t\tpacket_id_persist_save_obj (opt->pid_persist, opt->packet_id);\n\t    }\n\t  else\n\t    {\n\t      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))\n\t      msg (D_REPLAY_ERRORS, \"%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings\",\n\t\t   error_prefix, packet_id_net_print (&pin, true, &gc));\n\t      goto error_exit;\n\t    }\n\t}\n      *buf = work;\n    }\n\n  gc_free (&gc);\n  return true;\n\n error_exit:\n  crypto_clear_error();\n  buf->len = 0;\n  gc_free (&gc);\n  return false;\n}",
      "line_statements": [
        [
          265,
          "\t  if (memcmp_constant_time (local_hmac, BPTR (buf), hmac_len))"
        ]
      ],
      "statements": [
        [
          265,
          "if (memcmp_constant_time (local_hmac, BPTR (buf), hmac_len))"
        ]
      ],
      "cve": "CVE-2013-2061"
    },
    {
      "commit_id": "3c0c5cfdcd4d69ffc4b9c0907cec99039f30a50a",
      "filepath": "net/atm/pvc.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "pvc_getname",
      "func_body": "static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int *sockaddr_len, int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n\t\treturn -ENOTCONN;\n\t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n\taddr = (struct sockaddr_atmpvc *)sockaddr;\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sap_family = AF_ATMPVC;\n\taddr->sap_addr.itf = vcc->dev->number;\n\taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn 0;\n}",
      "line_statements": [
        [
          98,
          "\tmemset(addr, 0, sizeof(*addr));"
        ]
      ],
      "statements": [
        [
          98,
          "memset(addr, 0, sizeof(*addr));"
        ]
      ],
      "cve": "CVE-2012-6546"
    }
  ],
  "CWE-399": [
    {
      "commit_id": "4a284c89d6ef11aca34da65da7d673050a5ea320",
      "filepath": "src/apprentice.c",
      "project": "file",
      "project_repo_path": "symbol_backend_projects/file",
      "is_vulnerable": true,
      "func_name": "parse",
      "func_body": "parse(struct magic_set *ms, struct magic_entry *me, const char *line,\n    size_t lineno, int action)\n{\n#ifdef ENABLE_CONDITIONALS\n\tstatic uint32_t last_cont_level = 0;\n#endif\n\tsize_t i;\n\tstruct magic *m;\n\tconst char *l = line;\n\tchar *t;\n\tint op;\n\tuint32_t cont_level;\n\tint32_t diff;\n\n\tcont_level = 0;\n\n\t/*\n\t * Parse the offset.\n\t */\n\twhile (*l == '>') {\n\t\t++l;\t\t/* step over */\n\t\tcont_level++; \n\t}\n#ifdef ENABLE_CONDITIONALS\n\tif (cont_level == 0 || cont_level > last_cont_level)\n\t\tif (file_check_mem(ms, cont_level) == -1)\n\t\t\treturn -1;\n\tlast_cont_level = cont_level;\n#endif\n\tif (cont_level != 0) {\n\t\tif (me->mp == NULL) {\n\t\t\tfile_magerror(ms, \"No current entry for continuation\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (me->cont_count == 0) {\n\t\t\tfile_magerror(ms, \"Continuations present with 0 count\");\n\t\t\treturn -1;\n\t\t}\n\t\tm = &me->mp[me->cont_count - 1];\n\t\tdiff = (int32_t)cont_level - (int32_t)m->cont_level;\n\t\tif (diff > 1)\n\t\t\tfile_magwarn(ms, \"New continuation level %u is more \"\n\t\t\t    \"than one larger than current level %u\", cont_level,\n\t\t\t    m->cont_level);\n\t\tif (me->cont_count == me->max_count) {\n\t\t\tstruct magic *nm;\n\t\t\tsize_t cnt = me->max_count + ALLOC_CHUNK;\n\t\t\tif ((nm = CAST(struct magic *, realloc(me->mp,\n\t\t\t    sizeof(*nm) * cnt))) == NULL) {\n\t\t\t\tfile_oomem(ms, sizeof(*nm) * cnt);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tme->mp = m = nm;\n\t\t\tme->max_count = CAST(uint32_t, cnt);\n\t\t}\n\t\tm = &me->mp[me->cont_count++];\n\t\t(void)memset(m, 0, sizeof(*m));\n\t\tm->cont_level = cont_level;\n\t} else {\n\t\tstatic const size_t len = sizeof(*m) * ALLOC_CHUNK;\n\t\tif (me->mp != NULL)\n\t\t\treturn 1;\n\t\tif ((m = CAST(struct magic *, malloc(len))) == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t\tme->mp = m;\n\t\tme->max_count = ALLOC_CHUNK;\n\t\t(void)memset(m, 0, sizeof(*m));\n\t\tm->factor_op = FILE_FACTOR_OP_NONE;\n\t\tm->cont_level = 0;\n\t\tme->cont_count = 1;\n\t}\n\tm->lineno = CAST(uint32_t, lineno);\n\n\tif (*l == '&') {  /* m->cont_level == 0 checked below. */\n                ++l;            /* step over */\n                m->flag |= OFFADD;\n        }\n\tif (*l == '(') {\n\t\t++l;\t\t/* step over */\n\t\tm->flag |= INDIR;\n\t\tif (m->flag & OFFADD)\n\t\t\tm->flag = (m->flag & ~OFFADD) | INDIROFFADD;\n\n\t\tif (*l == '&') {  /* m->cont_level == 0 checked below */\n\t\t\t++l;            /* step over */\n\t\t\tm->flag |= OFFADD;\n\t\t}\n\t}\n\t/* Indirect offsets are not valid at level 0. */\n\tif (m->cont_level == 0 && (m->flag & (OFFADD | INDIROFFADD)))\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"relative offset at level 0\");\n\n\t/* get offset, then skip over it */\n\tm->offset = (uint32_t)strtoul(l, &t, 0);\n        if (l == t)\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"offset `%s' invalid\", l);\n        l = t;\n\n\tif (m->flag & INDIR) {\n\t\tm->in_type = FILE_LONG;\n\t\tm->in_offset = 0;\n\t\t/*\n\t\t * read [.lbs][+-]nnnnn)\n\t\t */\n\t\tif (*l == '.') {\n\t\t\tl++;\n\t\t\tswitch (*l) {\n\t\t\tcase 'l':\n\t\t\t\tm->in_type = FILE_LELONG;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tm->in_type = FILE_BELONG;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tm->in_type = FILE_MELONG;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase 's':\n\t\t\t\tm->in_type = FILE_LESHORT;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\tcase 'S':\n\t\t\t\tm->in_type = FILE_BESHORT;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'b':\n\t\t\tcase 'C':\n\t\t\tcase 'B':\n\t\t\t\tm->in_type = FILE_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\tcase 'f':\n\t\t\tcase 'g':\n\t\t\t\tm->in_type = FILE_LEDOUBLE;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\tcase 'F':\n\t\t\tcase 'G':\n\t\t\t\tm->in_type = FILE_BEDOUBLE;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tm->in_type = FILE_LEID3;\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\tm->in_type = FILE_BEID3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t    \"indirect offset type `%c' invalid\",\n\t\t\t\t\t    *l);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl++;\n\t\t}\n\n\t\tm->in_op = 0;\n\t\tif (*l == '~') {\n\t\t\tm->in_op |= FILE_OPINVERSE;\n\t\t\tl++;\n\t\t}\n\t\tif ((op = get_op(*l)) != -1) {\n\t\t\tm->in_op |= op;\n\t\t\tl++;\n\t\t}\n\t\tif (*l == '(') {\n\t\t\tm->in_op |= FILE_OPINDIRECT;\n\t\t\tl++;\n\t\t}\n\t\tif (isdigit((unsigned char)*l) || *l == '-') {\n\t\t\tm->in_offset = (int32_t)strtol(l, &t, 0);\n\t\t\tif (l == t)\n\t\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t    \"in_offset `%s' invalid\", l);\n\t\t\tl = t;\n\t\t}\n\t\tif (*l++ != ')' || \n\t\t    ((m->in_op & FILE_OPINDIRECT) && *l++ != ')'))\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms,\n\t\t\t\t    \"missing ')' in indirect offset\");\n\t}\n\tEATAB;\n\n#ifdef ENABLE_CONDITIONALS\n\tm->cond = get_cond(l, &l);\n\tif (check_cond(ms, m->cond, cont_level) == -1)\n\t\treturn -1;\n\n\tEATAB;\n#endif\n\n\t/*\n\t * Parse the type.\n\t */\n\tif (*l == 'u') {\n\t\t/*\n\t\t * Try it as a keyword type prefixed by \"u\"; match what\n\t\t * follows the \"u\".  If that fails, try it as an SUS\n\t\t * integer type. \n\t\t */\n\t\tm->type = get_type(type_tbl, l + 1, &l);\n\t\tif (m->type == FILE_INVALID) {\n\t\t\t/*\n\t\t\t * Not a keyword type; parse it as an SUS type,\n\t\t\t * 'u' possibly followed by a number or C/S/L.\n\t\t\t */\n\t\t\tm->type = get_standard_integer_type(l, &l);\n\t\t}\n\t\t/* It's unsigned. */\n\t\tif (m->type != FILE_INVALID)\n\t\t\tm->flag |= UNSIGNED;\n\t} else {\n\t\t/*\n\t\t * Try it as a keyword type.  If that fails, try it as\n\t\t * an SUS integer type if it begins with \"d\" or as an\n\t\t * SUS string type if it begins with \"s\".  In any case,\n\t\t * it's not unsigned.\n\t\t */\n\t\tm->type = get_type(type_tbl, l, &l);\n\t\tif (m->type == FILE_INVALID) {\n\t\t\t/*\n\t\t\t * Not a keyword type; parse it as an SUS type,\n\t\t\t * either 'd' possibly followed by a number or\n\t\t\t * C/S/L, or just 's'.\n\t\t\t */\n\t\t\tif (*l == 'd')\n\t\t\t\tm->type = get_standard_integer_type(l, &l);\n\t\t\telse if (*l == 's' && !isalpha((unsigned char)l[1])) {\n\t\t\t\tm->type = FILE_STRING;\n\t\t\t\t++l;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (m->type == FILE_INVALID) {\n\t\t/* Not found - try it as a special keyword. */\n\t\tm->type = get_type(special_tbl, l, &l);\n\t}\n\t\t\t\n\tif (m->type == FILE_INVALID) {\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"type `%s' invalid\", l);\n\t\treturn -1;\n\t}\n\n\t/* New-style anding: \"0 byte&0x80 =0x80 dynamically linked\" */\n\t/* New and improved: ~ & | ^ + - * / % -- exciting, isn't it? */\n\n\tm->mask_op = 0;\n\tif (*l == '~') {\n\t\tif (!IS_STRING(m->type))\n\t\t\tm->mask_op |= FILE_OPINVERSE;\n\t\telse if (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"'~' invalid for string types\");\n\t\t++l;\n\t}\n\tm->str_range = 0;\n\tm->str_flags = m->type == FILE_PSTRING ? PSTRING_1_LE : 0;\n\tif ((op = get_op(*l)) != -1) {\n\t\tif (!IS_STRING(m->type)) {\n\t\t\tuint64_t val;\n\t\t\t++l;\n\t\t\tm->mask_op |= op;\n\t\t\tval = (uint64_t)strtoull(l, &t, 0);\n\t\t\tl = t;\n\t\t\tm->num_mask = file_signextend(ms, m, val);\n\t\t\teatsize(&l);\n\t\t}\n\t\telse if (op == FILE_OPDIVIDE) {\n\t\t\tint have_range = 0;\n\t\t\twhile (!isspace((unsigned char)*++l)) {\n\t\t\t\tswitch (*l) {\n\t\t\t\tcase '0':  case '1':  case '2':\n\t\t\t\tcase '3':  case '4':  case '5':\n\t\t\t\tcase '6':  case '7':  case '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tif (have_range &&\n\t\t\t\t\t    (ms->flags & MAGIC_CHECK))\n\t\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t\t    \"multiple ranges\");\n\t\t\t\t\thave_range = 1;\n\t\t\t\t\tm->str_range = CAST(uint32_t,\n\t\t\t\t\t    strtoul(l, &t, 0));\n\t\t\t\t\tif (m->str_range == 0)\n\t\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t\t    \"zero range\");\n\t\t\t\t\tl = t - 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_COMPACT_WHITESPACE:\n\t\t\t\t\tm->str_flags |=\n\t\t\t\t\t    STRING_COMPACT_WHITESPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_COMPACT_OPTIONAL_WHITESPACE:\n\t\t\t\t\tm->str_flags |=\n\t\t\t\t\t    STRING_COMPACT_OPTIONAL_WHITESPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_IGNORE_LOWERCASE:\n\t\t\t\t\tm->str_flags |= STRING_IGNORE_LOWERCASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_IGNORE_UPPERCASE:\n\t\t\t\t\tm->str_flags |= STRING_IGNORE_UPPERCASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_REGEX_OFFSET_START:\n\t\t\t\t\tm->str_flags |= REGEX_OFFSET_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_BINTEST:\n\t\t\t\t\tm->str_flags |= STRING_BINTEST;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_TEXTTEST:\n\t\t\t\t\tm->str_flags |= STRING_TEXTTEST;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_TRIM:\n\t\t\t\t\tm->str_flags |= STRING_TRIM;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_1_LE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_1_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_2_BE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_BE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_2_LE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_BE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_BE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_LE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_LENGTH_INCLUDES_ITSELF:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags |= PSTRING_LENGTH_INCLUDES_ITSELF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tbad:\n\t\t\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t\t    \"string extension `%c' \"\n\t\t\t\t\t\t    \"invalid\", *l);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t/* allow multiple '/' for readability */\n\t\t\t\tif (l[1] == '/' &&\n\t\t\t\t    !isspace((unsigned char)l[2]))\n\t\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (string_modifier_check(ms, m) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms, \"invalid string op: %c\", *t);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/*\n\t * We used to set mask to all 1's here, instead let's just not do\n\t * anything if mask = 0 (unless you have a better idea)\n\t */\n\tEATAB;\n  \n\tswitch (*l) {\n\tcase '>':\n\tcase '<':\n  \t\tm->reln = *l;\n  \t\t++l;\n\t\tif (*l == '=') {\n\t\t\tif (ms->flags & MAGIC_CHECK) {\n\t\t\t\tfile_magwarn(ms, \"%c= not supported\",\n\t\t\t\t    m->reln);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t   ++l;\n\t\t}\n\t\tbreak;\n\t/* Old-style anding: \"0 byte &0x80 dynamically linked\" */\n\tcase '&':\n\tcase '^':\n\tcase '=':\n  \t\tm->reln = *l;\n  \t\t++l;\n\t\tif (*l == '=') {\n\t\t   /* HP compat: ignore &= etc. */\n\t\t   ++l;\n\t\t}\n\t\tbreak;\n\tcase '!':\n\t\tm->reln = *l;\n\t\t++l;\n\t\tbreak;\n\tdefault:\n  \t\tm->reln = '=';\t/* the default relation */\n\t\tif (*l == 'x' && ((isascii((unsigned char)l[1]) && \n\t\t    isspace((unsigned char)l[1])) || !l[1])) {\n\t\t\tm->reln = *l;\n\t\t\t++l;\n\t\t}\n\t\tbreak;\n\t}\n\t/*\n\t * Grab the value part, except for an 'x' reln.\n\t */\n\tif (m->reln != 'x' && getvalue(ms, m, &l, action))\n\t\treturn -1;\n\n\t/*\n\t * TODO finish this macro and start using it!\n\t * #define offsetcheck {if (offset > HOWMANY-1) \n\t *\tmagwarn(\"offset too big\"); }\n\t */\n\n\t/*\n\t * Now get last part - the description\n\t */\n\tEATAB;\n\tif (l[0] == '\\b') {\n\t\t++l;\n\t\tm->flag |= NOSPACE;\n\t} else if ((l[0] == '\\\\') && (l[1] == 'b')) {\n\t\t++l;\n\t\t++l;\n\t\tm->flag |= NOSPACE;\n\t}\n\tfor (i = 0; (m->desc[i++] = *l++) != '\\0' && i < sizeof(m->desc); )\n\t\tcontinue;\n\tif (i == sizeof(m->desc)) {\n\t\tm->desc[sizeof(m->desc) - 1] = '\\0';\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"description `%s' truncated\", m->desc);\n\t}\n\n        /*\n\t * We only do this check while compiling, or if any of the magic\n\t * files were not compiled.\n         */\n        if (ms->flags & MAGIC_CHECK) {\n\t\tif (check_format(ms, m) == -1)\n\t\t\treturn -1;\n\t}\n#ifndef COMPILE_ONLY\n\tif (action == FILE_CHECK) {\n\t\tfile_mdump(m);\n\t}\n#endif\n\tm->mimetype[0] = '\\0';\t\t/* initialise MIME type to none */\n\treturn 0;\n}",
      "line_statements": [
        [
          1878,
          "\t\t\t\t\tif (m->type != FILE_PSTRING)"
        ]
      ],
      "statements": [
        [
          1878,
          "if (m->type != FILE_PSTRING)"
        ]
      ],
      "cve": "CVE-2014-3538"
    },
    {
      "commit_id": "b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8",
      "filepath": "src/core/coreuserinputhandler.cpp",
      "project": "quassel",
      "project_repo_path": "symbol_backend_projects/quassel",
      "is_vulnerable": true,
      "func_name": "CoreUserInputHandler::handleMsg",
      "func_body": "void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)\n{\n    Q_UNUSED(bufferInfo);\n    if (!msg.contains(' '))\n        return;\n\n    QString target = msg.section(' ', 0, 0);\n    QByteArray encMsg = userEncode(target, msg.section(' ', 1));\n\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));\n#else\n    putPrivmsg(serverEncode(target), encMsg);\n#endif\n}",
      "line_statements": [
        [
          476,
          "    QByteArray encMsg = userEncode(target, msg.section(' ', 1));"
        ],
        [
          479,
          "    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));"
        ],
        [
          481,
          "    putPrivmsg(serverEncode(target), encMsg);"
        ]
      ],
      "statements": [
        [
          476,
          "QByteArray encMsg = userEncode(target, msg.section(' ', 1));"
        ],
        [
          479,
          "putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));"
        ],
        [
          481,
          "putPrivmsg(serverEncode(target), encMsg);"
        ]
      ],
      "cve": "CVE-2015-2778"
    },
    {
      "commit_id": "78f11a255749d09025f54d4e2df4fbcb031530e2",
      "filepath": "mm/huge_memory.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "khugepaged_scan_mm_slot",
      "func_body": "static unsigned int khugepaged_scan_mm_slot(unsigned int pages,\n\t\t\t\t\t    struct page **hpage)\n{\n\tstruct mm_slot *mm_slot;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tint progress = 0;\n\n\tVM_BUG_ON(!pages);\n\tVM_BUG_ON(!spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_scan.mm_slot)\n\t\tmm_slot = khugepaged_scan.mm_slot;\n\telse {\n\t\tmm_slot = list_entry(khugepaged_scan.mm_head.next,\n\t\t\t\t     struct mm_slot, mm_node);\n\t\tkhugepaged_scan.address = 0;\n\t\tkhugepaged_scan.mm_slot = mm_slot;\n\t}\n\tspin_unlock(&khugepaged_mm_lock);\n\n\tmm = mm_slot->mm;\n\tdown_read(&mm->mmap_sem);\n\tif (unlikely(khugepaged_test_exit(mm)))\n\t\tvma = NULL;\n\telse\n\t\tvma = find_vma(mm, khugepaged_scan.address);\n\n\tprogress++;\n\tfor (; vma; vma = vma->vm_next) {\n\t\tunsigned long hstart, hend;\n\n\t\tcond_resched();\n\t\tif (unlikely(khugepaged_test_exit(mm))) {\n\t\t\tprogress++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((!(vma->vm_flags & VM_HUGEPAGE) &&\n\t\t     !khugepaged_always()) ||\n\t\t    (vma->vm_flags & VM_NOHUGEPAGE)) {\n\t\tskip:\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* VM_PFNMAP vmas may have vm_ops null but vm_file set */\n\t\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n\t\t\tgoto skip;\n\t\tif (is_vma_temporary_stack(vma))\n\t\t\tgoto skip;\n\n\t\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n\n\t\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\t\thend = vma->vm_end & HPAGE_PMD_MASK;\n\t\tif (hstart >= hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address > hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address < hstart)\n\t\t\tkhugepaged_scan.address = hstart;\n\t\tVM_BUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);\n\n\t\twhile (khugepaged_scan.address < hend) {\n\t\t\tint ret;\n\t\t\tcond_resched();\n\t\t\tif (unlikely(khugepaged_test_exit(mm)))\n\t\t\t\tgoto breakouterloop;\n\n\t\t\tVM_BUG_ON(khugepaged_scan.address < hstart ||\n\t\t\t\t  khugepaged_scan.address + HPAGE_PMD_SIZE >\n\t\t\t\t  hend);\n\t\t\tret = khugepaged_scan_pmd(mm, vma,\n\t\t\t\t\t\t  khugepaged_scan.address,\n\t\t\t\t\t\t  hpage);\n\t\t\t/* move to next address */\n\t\t\tkhugepaged_scan.address += HPAGE_PMD_SIZE;\n\t\t\tprogress += HPAGE_PMD_NR;\n\t\t\tif (ret)\n\t\t\t\t/* we released mmap_sem so break loop */\n\t\t\t\tgoto breakouterloop_mmap_sem;\n\t\t\tif (progress >= pages)\n\t\t\t\tgoto breakouterloop;\n\t\t}\n\t}\nbreakouterloop:\n\tup_read(&mm->mmap_sem); /* exit_mmap will destroy ptes after this */\nbreakouterloop_mmap_sem:\n\n\tspin_lock(&khugepaged_mm_lock);\n\tVM_BUG_ON(khugepaged_scan.mm_slot != mm_slot);\n\t/*\n\t * Release the current mm_slot if this mm is about to die, or\n\t * if we scanned all vmas of this mm.\n\t */\n\tif (khugepaged_test_exit(mm) || !vma) {\n\t\t/*\n\t\t * Make sure that if mm_users is reaching zero while\n\t\t * khugepaged runs here, khugepaged_exit will find\n\t\t * mm_slot not pointing to the exiting mm.\n\t\t */\n\t\tif (mm_slot->mm_node.next != &khugepaged_scan.mm_head) {\n\t\t\tkhugepaged_scan.mm_slot = list_entry(\n\t\t\t\tmm_slot->mm_node.next,\n\t\t\t\tstruct mm_slot, mm_node);\n\t\t\tkhugepaged_scan.address = 0;\n\t\t} else {\n\t\t\tkhugepaged_scan.mm_slot = NULL;\n\t\t\tkhugepaged_full_scans++;\n\t\t}\n\n\t\tcollect_mm_slot(mm_slot);\n\t}\n\n\treturn progress;\n}",
      "line_statements": [
        [
          2070,
          "\t\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)"
        ],
        [
          2074,
          ""
        ],
        [
          2075,
          "\t\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));"
        ]
      ],
      "statements": [
        [
          2070,
          "if (!vma->anon_vma || vma->vm_ops || vma->vm_file)"
        ],
        [
          2074,
          "\n"
        ],
        [
          2075,
          "VM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));"
        ]
      ],
      "cve": "CVE-2011-2479"
    },
    {
      "commit_id": "d0de4dc584ec6aa3b26fffea320a8457827768fc",
      "filepath": "fs/notify/inotify/inotify_user.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "inotify_release",
      "func_body": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\tfsnotify_clear_marks_by_group(group);\n\n\t/* free this group, matching get was inotify_init->fsnotify_obtain_group */\n\tfsnotify_put_group(group);\n\n\tatomic_dec(&user->inotify_devs);\n\n\treturn 0;\n}",
      "line_statements": [
        [
          293,
          "\tstruct user_struct *user = group->inotify_data.user;"
        ],
        [
          302,
          "\tatomic_dec(&user->inotify_devs);"
        ],
        [
          303,
          ""
        ]
      ],
      "statements": [
        [
          293,
          "struct user_struct *user = group->inotify_data.user;"
        ],
        [
          302,
          "atomic_dec(&user->inotify_devs);"
        ],
        [
          303,
          "\n"
        ]
      ],
      "cve": "CVE-2011-1479"
    },
    {
      "commit_id": "c03aa9f6e1f938618e6db2e23afef0574efeeb65",
      "filepath": "fs/udf/inode.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "__udf_read_inode",
      "func_body": "static void __udf_read_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\nreread:\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tbrelse(bh);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 1,\n\t\t\t\t\t&ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tmake_bad_inode(inode);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tbrelse(bh);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tif (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tif (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\t\tsizeof(struct fileEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tif (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\treturn;\n\t}\n\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count)\n\t\tlink_count = 1;\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tmake_bad_inode(inode);\n\t}\n\tbrelse(bh);\n}",
      "line_statements": [
        [
          1289,
          "\tunsigned int indirections = 0;"
        ],
        [
          1291,
          "reread:"
        ],
        [
          1335,
          "\t\t\tif (ie->indirectICB.extLength) {"
        ],
        [
          1336,
          "\t\t\t\tbrelse(bh);"
        ],
        [
          1337,
          "\t\t\t\tbrelse(ibh);"
        ],
        [
          1338,
          "\t\t\t\tmemcpy(&iinfo->i_location, &loc,"
        ],
        [
          1339,
          "\t\t\t\t       sizeof(struct kernel_lb_addr));"
        ],
        [
          1340,
          "\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {"
        ],
        [
          1341,
          "\t\t\t\t\tudf_err(inode->i_sb,"
        ],
        [
          1342,
          "\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\""
        ],
        [
          1343,
          "\t\t\t\t\t\t\" (max %d supported)\\n\","
        ],
        [
          1344,
          "\t\t\t\t\t\tUDF_MAX_ICB_NESTING);"
        ],
        [
          1345,
          "\t\t\t\t\tmake_bad_inode(inode);"
        ],
        [
          1348,
          "\t\t\t\tgoto reread;"
        ]
      ],
      "statements": [
        [
          1289,
          "unsigned int indirections = 0;"
        ],
        [
          1291,
          "reread:"
        ],
        [
          1335,
          "if (ie->indirectICB.extLength)"
        ],
        [
          1336,
          "brelse(bh);"
        ],
        [
          1337,
          "brelse(ibh);"
        ],
        [
          1338,
          "memcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));"
        ],
        [
          1340,
          "if (++indirections > UDF_MAX_ICB_NESTING)"
        ],
        [
          1341,
          "udf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);"
        ],
        [
          1345,
          "make_bad_inode(inode);"
        ],
        [
          1348,
          "goto reread;"
        ]
      ],
      "cve": "CVE-2014-6410"
    },
    {
      "commit_id": "dd7633ecd553a5e304d349aa6f8eb8a0417098c5",
      "filepath": "drivers/vhost/net.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "vhost_net_set_backend",
      "func_body": "static long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)\n{\n\tstruct socket *sock, *oldsock;\n\tstruct vhost_virtqueue *vq;\n\tstruct vhost_net_virtqueue *nvq;\n\tstruct vhost_net_ubuf_ref *ubufs, *oldubufs = NULL;\n\tint r;\n\n\tmutex_lock(&n->dev.mutex);\n\tr = vhost_dev_check_owner(&n->dev);\n\tif (r)\n\t\tgoto err;\n\n\tif (index >= VHOST_NET_VQ_MAX) {\n\t\tr = -ENOBUFS;\n\t\tgoto err;\n\t}\n\tvq = &n->vqs[index].vq;\n\tnvq = &n->vqs[index];\n\tmutex_lock(&vq->mutex);\n\n\t/* Verify that ring has been setup correctly. */\n\tif (!vhost_vq_access_ok(vq)) {\n\t\tr = -EFAULT;\n\t\tgoto err_vq;\n\t}\n\tsock = get_socket(fd);\n\tif (IS_ERR(sock)) {\n\t\tr = PTR_ERR(sock);\n\t\tgoto err_vq;\n\t}\n\n\t/* start polling new socket */\n\toldsock = rcu_dereference_protected(vq->private_data,\n\t\t\t\t\t    lockdep_is_held(&vq->mutex));\n\tif (sock != oldsock) {\n\t\tubufs = vhost_net_ubuf_alloc(vq,\n\t\t\t\t\t     sock && vhost_sock_zcopy(sock));\n\t\tif (IS_ERR(ubufs)) {\n\t\t\tr = PTR_ERR(ubufs);\n\t\t\tgoto err_ubufs;\n\t\t}\n\n\t\tvhost_net_disable_vq(n, vq);\n\t\trcu_assign_pointer(vq->private_data, sock);\n\t\tr = vhost_init_used(vq);\n\t\tif (r)\n\t\t\tgoto err_used;\n\t\tr = vhost_net_enable_vq(n, vq);\n\t\tif (r)\n\t\t\tgoto err_used;\n\n\t\toldubufs = nvq->ubufs;\n\t\tnvq->ubufs = ubufs;\n\n\t\tn->tx_packets = 0;\n\t\tn->tx_zcopy_err = 0;\n\t\tn->tx_flush = false;\n\t}\n\n\tmutex_unlock(&vq->mutex);\n\n\tif (oldubufs) {\n\t\tvhost_net_ubuf_put_wait_and_free(oldubufs);\n\t\tmutex_lock(&vq->mutex);\n\t\tvhost_zerocopy_signal_used(n, vq);\n\t\tmutex_unlock(&vq->mutex);\n\t}\n\n\tif (oldsock) {\n\t\tvhost_net_flush_vq(n, index);\n\t\tfput(oldsock->file);\n\t}\n\n\tmutex_unlock(&n->dev.mutex);\n\treturn 0;\n\nerr_used:\n\trcu_assign_pointer(vq->private_data, oldsock);\n\tvhost_net_enable_vq(n, vq);\n\tif (ubufs)\n\t\tvhost_net_ubuf_put_wait_and_free(ubufs);\nerr_ubufs:\n\tfput(sock->file);\nerr_vq:\n\tmutex_unlock(&vq->mutex);\nerr:\n\tmutex_unlock(&n->dev.mutex);\n\treturn r;\n}",
      "line_statements": [
        [
          956,
          "\t\tvhost_net_ubuf_put_wait_and_free(oldubufs);"
        ],
        [
          974,
          "\t\tvhost_net_ubuf_put_wait_and_free(ubufs);"
        ]
      ],
      "statements": [
        [
          956,
          "vhost_net_ubuf_put_wait_and_free(oldubufs);"
        ],
        [
          974,
          "vhost_net_ubuf_put_wait_and_free(ubufs);"
        ]
      ],
      "cve": "CVE-2013-4127"
    }
  ],
  "CWE-120": [
    {
      "commit_id": "d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9",
      "filepath": "src/model/framebuffer/FramebufferModel.cpp",
      "project": "openexr-viewer",
      "project_repo_path": "symbol_backend_projects/openexr-viewer",
      "is_vulnerable": false,
      "func_name": "FramebufferModel::~FramebufferModel",
      "func_body": "FramebufferModel::~FramebufferModel() {}",
      "line_statements": [
        [
          61,
          "FramebufferModel::~FramebufferModel() {}"
        ]
      ],
      "statements": [
        [
          61,
          "FramebufferModel::~FramebufferModel()"
        ]
      ],
      "cve": "CVE-2023-50245"
    },
    {
      "commit_id": "4ef3ede30181eca9add74305ad26dbcb0c3686a0",
      "filepath": "src/interfaces/gtk/ec_gtk_conf.c",
      "project": "ettercap",
      "project_repo_path": "symbol_backend_projects/ettercap",
      "is_vulnerable": true,
      "func_name": "gtkui_conf_read",
      "func_body": "void gtkui_conf_read(void) {\n   FILE *fd;\n   const char *path;\n   char line[100], name[30];\n   short value;\n\n#ifdef OS_WINDOWS\n   path = ec_win_get_user_dir();\n#else\n   /* TODO: get the dopped privs home dir instead of \"/root\" */\n   /* path = g_get_home_dir(); */\n   path = g_get_tmp_dir();\n#endif\n\n   filename = g_build_filename(path, \".ettercap_gtk\", NULL);\n\n   DEBUG_MSG(\"gtkui_conf_read: %s\", filename);\n\n   fd = fopen(filename, \"r\");\n   if(!fd) \n      return;\n\n   while(fgets(line, 100, fd)) {\n      sscanf(line, \"%s = %hd\", name, &value);\n\n      gtkui_conf_set(name, value);\n   }\n   fclose(fd);\n}",
      "line_statements": [
        [
          77,
          "   path = g_get_tmp_dir();"
        ]
      ],
      "statements": [
        [
          77,
          "path = g_get_tmp_dir();"
        ]
      ],
      "cve": "CVE-2010-3844"
    },
    {
      "commit_id": "77ed81c069e10b3861d88f72e1c6be1277ee7eae",
      "filepath": "src/isomedia/stbl_write.c",
      "project": "gpac",
      "project_repo_path": "symbol_backend_projects/gpac",
      "is_vulnerable": true,
      "func_name": "stbl_AddChunkOffset",
      "func_body": "GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples)\n{\n\tGF_SampleTableBox *stbl;\n\tGF_ChunkOffsetBox *stco;\n\tGF_SampleToChunkBox *stsc;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_StscEntry *ent;\n\tu32 i, k, *newOff, new_chunk_idx=0;\n\tu64 *newLarge;\n\ts32 insert_idx = -1;\n\n\tstbl = mdia->information->sampleTable;\n\tstsc = stbl->SampleToChunk;\n\n//\tif (stsc->w_lastSampleNumber + 1 < sampleNumber ) return GF_BAD_PARAM;\n\tif (!nb_pack_samples)\n\t\tnb_pack_samples = 1;\n\n\tif (!stsc->nb_entries || (stsc->nb_entries + 2 >= stsc->alloc_size)) {\n\t\tif (!stsc->alloc_size) stsc->alloc_size = 1;\n\t\tALLOC_INC(stsc->alloc_size);\n\t\tstsc->entries = gf_realloc(stsc->entries, sizeof(GF_StscEntry)*stsc->alloc_size);\n\t\tif (!stsc->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size-stsc->nb_entries) );\n\t}\n\tif (sampleNumber == stsc->w_lastSampleNumber + 1) {\n\t\tent = &stsc->entries[stsc->nb_entries];\n\t\tstsc->w_lastChunkNumber ++;\n\t\tent->firstChunk = stsc->w_lastChunkNumber;\n\t\tif (stsc->nb_entries) stsc->entries[stsc->nb_entries-1].nextChunk = stsc->w_lastChunkNumber;\n\n\t\tnew_chunk_idx = stsc->w_lastChunkNumber;\n\t\tstsc->w_lastSampleNumber = sampleNumber + nb_pack_samples-1;\n\t\tstsc->nb_entries += 1;\n\t} else {\n\t\tu32 cur_samp = 1;\n\t\tu32 samples_in_next_entry = 0;\n\t\tu32 next_entry_first_chunk = 1;\n\t\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\t\tu32 nb_chunks = 1;\n\t\t\tent = &stsc->entries[i];\n\t\t\tif (i+1<stsc->nb_entries) nb_chunks = stsc->entries[i+1].firstChunk - ent->firstChunk;\n\t\t\tfor (k=0; k<nb_chunks; k++) {\n\t\t\t\tif ((cur_samp <= sampleNumber) && (ent->samplesPerChunk + cur_samp > sampleNumber)) {\n\t\t\t\t\tinsert_idx = i;\n\t\t\t\t\t//stsc entry has samples before inserted sample, split\n\t\t\t\t\tif (sampleNumber>cur_samp) {\n\t\t\t\t\t\tsamples_in_next_entry = ent->samplesPerChunk - (sampleNumber-cur_samp);\n\t\t\t\t\t\tent->samplesPerChunk = sampleNumber-cur_samp;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_samp += ent->samplesPerChunk;\n\t\t\t\tnext_entry_first_chunk++;\n\t\t\t}\n\t\t\tif (insert_idx>=0) break;\n\t\t}\n\t\t//we need to split the entry\n\t\tif (samples_in_next_entry) {\n\t\t\tmemmove(&stsc->entries[insert_idx+3], &stsc->entries[insert_idx+1], sizeof(GF_StscEntry)*(stsc->nb_entries - insert_idx - 1));\n\t\t\t//copy over original entry\n\t\t\tent = &stsc->entries[insert_idx];\n\t\t\tstsc->entries[insert_idx+2] = *ent;\n\t\t\tstsc->entries[insert_idx+2].samplesPerChunk = samples_in_next_entry;\n\t\t\tstsc->entries[insert_idx+2].firstChunk = next_entry_first_chunk + 1;\n\n\t\t\t//setup new entry\n\t\t\tent = &stsc->entries[insert_idx+1];\n\t\t\tent->firstChunk = next_entry_first_chunk;\n\n\t\t\tstsc->nb_entries += 2;\n\t\t} else {\n\t\t\tif (insert_idx<0) {\n\t\t\t\tent = &stsc->entries[stsc->nb_entries];\n\t\t\t\tinsert_idx = stsc->nb_entries;\n\t\t\t} else {\n\t\t\t\tmemmove(&stsc->entries[insert_idx+1], &stsc->entries[insert_idx], sizeof(GF_StscEntry)*(stsc->nb_entries+1-insert_idx));\n\t\t\t\tent = &stsc->entries[insert_idx+1];\n\t\t\t}\n\n\t\t\tent->firstChunk = next_entry_first_chunk;\n\t\t\tstsc->nb_entries += 1;\n\t\t}\n\t\tnew_chunk_idx = next_entry_first_chunk;\n\t}\n\tent->isEdited = (Media_IsSelfContained(mdia, StreamDescIndex)) ? 1 : 0;\n\tent->sampleDescriptionIndex = StreamDescIndex;\n\tent->samplesPerChunk = nb_pack_samples;\n\tent->nextChunk = ent->firstChunk+1;\n\n\t//OK, now if we've inserted a chunk, update the sample to chunk info...\n\tif (sampleNumber + nb_pack_samples - 1 == stsc->w_lastSampleNumber) {\n\t\tif (stsc->nb_entries)\n\t\t\tstsc->entries[stsc->nb_entries-1].nextChunk = ent->firstChunk;\n\n\t\tstbl->SampleToChunk->currentIndex = stsc->nb_entries-1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk = sampleNumber;\n\t\t//write - edit mode: sample number = chunk number\n\t\tstbl->SampleToChunk->currentChunk = stsc->w_lastChunkNumber;\n\t\tstbl->SampleToChunk->ghostNumber = 1;\n\t} else {\n\t\t/*offset remaining entries*/\n\t\tfor (i = insert_idx+1; i<stsc->nb_entries+1; i++) {\n\t\t\tstsc->entries[i].firstChunk++;\n\t\t\tif (i+1<stsc->nb_entries)\n\t\t\t\tstsc->entries[i-1].nextChunk = stsc->entries[i].firstChunk;\n\t\t}\n\t}\n\n\t//add the offset to the chunk...\n\t//and we change our offset\n\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t//if the new offset is a large one, we have to rewrite our table entry by entry (32->64 bit conv)...\n\t\tif (offset > 0xFFFFFFFF) {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64);\n\t\t\tif (!co64) return GF_OUT_OF_MEM;\n\t\t\tco64->nb_entries = stco->nb_entries + 1;\n\t\t\tco64->alloc_size = co64->nb_entries;\n\t\t\tco64->offsets = (u64*)gf_malloc(sizeof(u64) * co64->nb_entries);\n\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\tk = 0;\n\t\t\tfor (i=0; i<stco->nb_entries; i++) {\n\t\t\t\tif (i + 1 == new_chunk_idx) {\n\t\t\t\t\tco64->offsets[i] = offset;\n\t\t\t\t\tk = 1;\n\t\t\t\t}\n\t\t\t\tco64->offsets[i+k] = (u64) stco->offsets[i];\n\t\t\t}\n\t\t\tif (!k) co64->offsets[co64->nb_entries - 1] = offset;\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset);\n\t\t\tstbl->ChunkOffset = (GF_Box *) co64;\n\t\t} else {\n\t\t\t//no, we can use this one.\n\t\t\tif (new_chunk_idx > stco->nb_entries) {\n\t\t\t\tif (!stco->alloc_size) stco->alloc_size = stco->nb_entries;\n\t\t\t\tif (stco->nb_entries == stco->alloc_size) {\n\t\t\t\t\tALLOC_INC(stco->alloc_size);\n\t\t\t\t\tstco->offsets = (u32*)gf_realloc(stco->offsets, sizeof(u32) * stco->alloc_size);\n\t\t\t\t\tif (!stco->offsets) return GF_OUT_OF_MEM;\n\t\t\t\t\tmemset(&stco->offsets[stco->nb_entries], 0, sizeof(u32) * (stco->alloc_size-stco->nb_entries) );\n\t\t\t\t}\n\t\t\t\tstco->offsets[stco->nb_entries] = (u32) offset;\n\t\t\t\tstco->nb_entries += 1;\n\t\t\t} else {\n\t\t\t\t//nope. we're inserting\n\t\t\t\tnewOff = (u32*)gf_malloc(sizeof(u32) * (stco->nb_entries + 1));\n\t\t\t\tif (!newOff) return GF_OUT_OF_MEM;\n\t\t\t\tk=0;\n\t\t\t\tfor (i=0; i<stco->nb_entries; i++) {\n\t\t\t\t\tif (i+1 == new_chunk_idx) {\n\t\t\t\t\t\tnewOff[i] = (u32) offset;\n\t\t\t\t\t\tk=1;\n\t\t\t\t\t}\n\t\t\t\t\tnewOff[i+k] = stco->offsets[i];\n\t\t\t\t}\n\t\t\t\tgf_free(stco->offsets);\n\t\t\t\tstco->offsets = newOff;\n\t\t\t\tstco->nb_entries ++;\n\t\t\t\tstco->alloc_size = stco->nb_entries;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t//use large offset...\n\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\tif (sampleNumber > co64->nb_entries) {\n\t\t\tif (!co64->alloc_size) co64->alloc_size = co64->nb_entries;\n\t\t\tif (co64->nb_entries == co64->alloc_size) {\n\t\t\t\tALLOC_INC(co64->alloc_size);\n\t\t\t\tco64->offsets = (u64*)gf_realloc(co64->offsets, sizeof(u64) * co64->alloc_size);\n\t\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\t\tmemset(&co64->offsets[co64->nb_entries], 0, sizeof(u64) * (co64->alloc_size - co64->nb_entries) );\n\t\t\t}\n\t\t\tco64->offsets[co64->nb_entries] = offset;\n\t\t\tco64->nb_entries += 1;\n\t\t} else {\n\t\t\t//nope. we're inserting\n\t\t\tnewLarge = (u64*)gf_malloc(sizeof(u64) * (co64->nb_entries + 1));\n\t\t\tif (!newLarge) return GF_OUT_OF_MEM;\n\t\t\tk=0;\n\t\t\tfor (i=0; i<co64->nb_entries; i++) {\n\t\t\t\tif (i+1 == new_chunk_idx) {\n\t\t\t\t\tnewLarge[i] = offset;\n\t\t\t\t\tk=1;\n\t\t\t\t}\n\t\t\t\tnewLarge[i+k] = co64->offsets[i];\n\t\t\t}\n\t\t\tgf_free(co64->offsets);\n\t\t\tco64->offsets = newLarge;\n\t\t\tco64->nb_entries++;\n\t\t\tco64->alloc_size++;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}",
      "line_statements": [
        [
          701,
          "GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples)"
        ],
        [
          716,
          "\tif (!nb_pack_samples)"
        ],
        [
          717,
          "\t\tnb_pack_samples = 1;"
        ],
        [
          733,
          "\t\tstsc->w_lastSampleNumber = sampleNumber + nb_pack_samples-1;"
        ],
        [
          788,
          "\tent->samplesPerChunk = nb_pack_samples;"
        ],
        [
          792,
          "\tif (sampleNumber + nb_pack_samples - 1 == stsc->w_lastSampleNumber) {"
        ]
      ],
      "statements": [
        [
          701,
          "GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples)"
        ],
        [
          716,
          "if (!nb_pack_samples)"
        ],
        [
          717,
          "nb_pack_samples = 1;"
        ],
        [
          733,
          "stsc->w_lastSampleNumber = sampleNumber + nb_pack_samples-1;"
        ],
        [
          788,
          "ent->samplesPerChunk = nb_pack_samples;"
        ],
        [
          792,
          "if (sampleNumber + nb_pack_samples - 1 == stsc->w_lastSampleNumber)"
        ]
      ],
      "cve": "CVE-2021-32439"
    },
    {
      "commit_id": "7ce5b2b590256ce53d6af28c1d203fb3bc1d2d97",
      "filepath": "src/change.c",
      "project": "vim",
      "project_repo_path": "symbol_backend_projects/vim",
      "is_vulnerable": false,
      "func_name": "changed_common",
      "func_body": "changed_common(\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    linenr_T\tlnume,\n    long\txtra)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n    int\t\ti;\n    int\t\tcols;\n    pos_T\t*p;\n    int\t\tadd;\n\n    // mark the buffer as modified\n    changed();\n\n#ifdef FEAT_EVAL\n    may_record_change(lnum, col, lnume, xtra);\n#endif\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff && diff_internal())\n\tcurtab->tp_diff_update = TRUE;\n#endif\n\n    // set the '. mark\n    if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0)\n    {\n\tcurbuf->b_last_change.lnum = lnum;\n\tcurbuf->b_last_change.col = col;\n\n\t// Create a new entry if a new undo-able change was started or we\n\t// don't have an entry yet.\n\tif (curbuf->b_new_change || curbuf->b_changelistlen == 0)\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\tadd = TRUE;\n\t    else\n\t    {\n\t\t// Don't create a new entry when the line number is the same\n\t\t// as the last one and the column is not too far away.  Avoids\n\t\t// creating many entries for typing \"xxxxx\".\n\t\tp = &curbuf->b_changelist[curbuf->b_changelistlen - 1];\n\t\tif (p->lnum != lnum)\n\t\t    add = TRUE;\n\t\telse\n\t\t{\n\t\t    cols = comp_textwidth(FALSE);\n\t\t    if (cols == 0)\n\t\t\tcols = 79;\n\t\t    add = (p->col + cols < col || col + cols < p->col);\n\t\t}\n\t    }\n\t    if (add)\n\t    {\n\t\t// This is the first of a new sequence of undo-able changes\n\t\t// and it's at some distance of the last change.  Use a new\n\t\t// position in the changelist.\n\t\tcurbuf->b_new_change = FALSE;\n\n\t\tif (curbuf->b_changelistlen == JUMPLISTSIZE)\n\t\t{\n\t\t    // changelist is full: remove oldest entry\n\t\t    curbuf->b_changelistlen = JUMPLISTSIZE - 1;\n\t\t    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,\n\t\t\t\t\t  sizeof(pos_T) * (JUMPLISTSIZE - 1));\n\t\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t    {\n\t\t\t// Correct position in changelist for other windows on\n\t\t\t// this buffer.\n\t\t\tif (wp->w_buffer == curbuf && wp->w_changelistidx > 0)\n\t\t\t    --wp->w_changelistidx;\n\t\t    }\n\t\t}\n\t\tFOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t{\n\t\t    // For other windows, if the position in the changelist is\n\t\t    // at the end it stays at the end.\n\t\t    if (wp->w_buffer == curbuf\n\t\t\t    && wp->w_changelistidx == curbuf->b_changelistlen)\n\t\t\t++wp->w_changelistidx;\n\t\t}\n\t\t++curbuf->b_changelistlen;\n\t    }\n\t}\n\tcurbuf->b_changelist[curbuf->b_changelistlen - 1] =\n\t\t\t\t\t\t\tcurbuf->b_last_change;\n\t// The current window is always after the last change, so that \"g,\"\n\t// takes you back to it.\n\tcurwin->w_changelistidx = curbuf->b_changelistlen;\n    }\n\n    if (VIsual_active)\n\tcheck_visual_pos();\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer == curbuf)\n\t{\n#ifdef FEAT_FOLDING\n\t    linenr_T last = lnume + xtra - 1;  // last line after the change\n#endif\n\t    // Mark this window to be redrawn later.\n\t    if (wp->w_redr_type < VALID)\n\t\twp->w_redr_type = VALID;\n\n\t    // Check if a change in the buffer has invalidated the cached\n\t    // values for the cursor.\n#ifdef FEAT_FOLDING\n\t    // Update the folds for this window.  Can't postpone this, because\n\t    // a following operator might work on the whole fold: \">>dd\".\n\t    foldUpdate(wp, lnum, last);\n\n\t    // The change may cause lines above or below the change to become\n\t    // included in a fold.  Set lnum/lnume to the first/last line that\n\t    // might be displayed differently.\n\t    // Set w_cline_folded here as an efficient way to update it when\n\t    // inserting lines just above a closed fold.\n\t    i = hasFoldingWin(wp, lnum, &lnum, NULL, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == lnum)\n\t\twp->w_cline_folded = i;\n\t    i = hasFoldingWin(wp, last, NULL, &last, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == last)\n\t\twp->w_cline_folded = i;\n\n\t    // If the changed line is in a range of previously folded lines,\n\t    // compare with the first line in that range.\n\t    if (wp->w_cursor.lnum <= lnum)\n\t    {\n\t\ti = find_wl_entry(wp, lnum);\n\t\tif (i >= 0 && wp->w_cursor.lnum > wp->w_lines[i].wl_lnum)\n\t\t    changed_line_abv_curs_win(wp);\n\t    }\n#endif\n\t    if (wp->w_cursor.lnum > lnum)\n\t\tchanged_line_abv_curs_win(wp);\n\t    else if (wp->w_cursor.lnum == lnum && wp->w_cursor.col >= col)\n\t\tchanged_cline_bef_curs_win(wp);\n\t    if (wp->w_botline >= lnum)\n\t    {\n\t\tif (xtra < 0)\n\t\t    invalidate_botline_win(wp);\n\t\telse\n\t\t    // Assume that botline doesn't change (inserted lines make\n\t\t    // other lines scroll down below botline).\n\t\t    approximate_botline_win(wp);\n\t    }\n\n\t    // Check if any w_lines[] entries have become invalid.\n\t    // For entries below the change: Correct the lnums for\n\t    // inserted/deleted lines.  Makes it possible to stop displaying\n\t    // after the change.\n\t    for (i = 0; i < wp->w_lines_valid; ++i)\n\t\tif (wp->w_lines[i].wl_valid)\n\t\t{\n\t\t    if (wp->w_lines[i].wl_lnum >= lnum)\n\t\t    {\n\t\t\tif (wp->w_lines[i].wl_lnum < lnume)\n\t\t\t{\n\t\t\t    // line included in change\n\t\t\t    wp->w_lines[i].wl_valid = FALSE;\n\t\t\t}\n\t\t\telse if (xtra != 0)\n\t\t\t{\n\t\t\t    // line below change\n\t\t\t    wp->w_lines[i].wl_lnum += xtra;\n#ifdef FEAT_FOLDING\n\t\t\t    wp->w_lines[i].wl_lastlnum += xtra;\n#endif\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FOLDING\n\t\t    else if (wp->w_lines[i].wl_lastlnum >= lnum)\n\t\t    {\n\t\t\t// change somewhere inside this range of folded lines,\n\t\t\t// may need to be redrawn\n\t\t\twp->w_lines[i].wl_valid = FALSE;\n\t\t    }\n#endif\n\t\t}\n\n#ifdef FEAT_FOLDING\n\t    // Take care of side effects for setting w_topline when folds have\n\t    // changed.  Esp. when the buffer was changed in another window.\n\t    if (hasAnyFolding(wp))\n\t\tset_topline(wp, wp->w_topline);\n#endif\n\t    // If lines have been added or removed, relative numbering always\n\t    // requires a redraw.\n\t    if (wp->w_p_rnu && xtra != 0)\n\t    {\n\t\twp->w_last_cursor_lnum_rnu = 0;\n\t\tredraw_win_later(wp, VALID);\n\t    }\n#ifdef FEAT_SYN_HL\n\t    // Cursor line highlighting probably need to be updated with\n\t    // \"VALID\" if it's below the change.\n\t    // If the cursor line is inside the change we need to redraw more.\n\t    if (wp->w_p_cul)\n\t    {\n\t\tif (xtra == 0)\n\t\t    redraw_win_later(wp, VALID);\n\t\telse if (lnum <= wp->w_last_cursorline)\n\t\t    redraw_win_later(wp, SOME_VALID);\n\t    }\n#endif\n\t}\n    }\n\n    // Call update_screen() later, which checks out what needs to be redrawn,\n    // since it notices b_mod_set and then uses b_mod_*.\n    if (must_redraw < VALID)\n\tmust_redraw = VALID;\n\n    // when the cursor line is changed always trigger CursorMoved\n    if (lnum <= curwin->w_cursor.lnum\n\t\t && lnume + (xtra < 0 ? -xtra : xtra) > curwin->w_cursor.lnum)\n\tlast_cursormoved.lnum = 0;\n}",
      "line_statements": [
        [
          551,
          "    if (VIsual_active)"
        ],
        [
          552,
          "\tcheck_visual_pos();"
        ],
        [
          553,
          ""
        ]
      ],
      "statements": [
        [
          460,
          "changed_common(\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    linenr_T\tlnume,\n    long\txtra)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n    int\t\ti;\n    int\t\tcols;\n    pos_T\t*p;\n    int\t\tadd;\n\n    // mark the buffer as modified\n    changed();\n\n#ifdef FEAT_EVAL\n    may_record_change(lnum, col, lnume, xtra);\n#endif\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff && diff_internal())\n\tcurtab->tp_diff_update = TRUE;\n#endif\n\n    // set the '. mark\n    if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0)\n    {\n\tcurbuf->b_last_change.lnum = lnum;\n\tcurbuf->b_last_change.col = col;\n\n\t// Create a new entry if a new undo-able change was started or we\n\t// don't have an entry yet.\n\tif (curbuf->b_new_change || curbuf->b_changelistlen == 0)\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\tadd = TRUE;\n\t    else\n\t    {\n\t\t// Don't create a new entry when the line number is the same\n\t\t// as the last one and the column is not too far away.  Avoids\n\t\t// creating many entries for typing \"xxxxx\".\n\t\tp = &curbuf->b_changelist[curbuf->b_changelistlen - 1];\n\t\tif (p->lnum != lnum)\n\t\t    add = TRUE;\n\t\telse\n\t\t{\n\t\t    cols = comp_textwidth(FALSE);\n\t\t    if (cols == 0)\n\t\t\tcols = 79;\n\t\t    add = (p->col + cols < col || col + cols < p->col);\n\t\t}\n\t    }\n\t    if (add)\n\t    {\n\t\t// This is the first of a new sequence of undo-able changes\n\t\t// and it's at some distance of the last change.  Use a new\n\t\t// position in the changelist.\n\t\tcurbuf->b_new_change = FALSE;\n\n\t\tif (curbuf->b_changelistlen == JUMPLISTSIZE)\n\t\t{\n\t\t    // changelist is full: remove oldest entry\n\t\t    curbuf->b_changelistlen = JUMPLISTSIZE - 1;\n\t\t    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,\n\t\t\t\t\t  sizeof(pos_T) * (JUMPLISTSIZE - 1));\n\t\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t    {\n\t\t\t// Correct position in changelist for other windows on\n\t\t\t// this buffer.\n\t\t\tif (wp->w_buffer == curbuf && wp->w_changelistidx > 0)\n\t\t\t    --wp->w_changelistidx;\n\t\t    }\n\t\t}\n\t\tFOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t{\n\t\t    // For other windows, if the position in the changelist is\n\t\t    // at the end it stays at the end.\n\t\t    if (wp->w_buffer == curbuf\n\t\t\t    && wp->w_changelistidx == curbuf->b_changelistlen)\n\t\t\t++wp->w_changelistidx;\n\t\t}\n\t\t++curbuf->b_changelistlen;\n\t    }\n\t}\n\tcurbuf->b_changelist[curbuf->b_changelistlen - 1] =\n\t\t\t\t\t\t\tcurbuf->b_last_change;\n\t// The current window is always after the last change, so that \"g,\"\n\t// takes you back to it.\n\tcurwin->w_changelistidx = curbuf->b_changelistlen;\n    }\n\n    if (VIsual_active)\n\tcheck_visual_pos();\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer == curbuf)\n\t{\n#ifdef FEAT_FOLDING\n\t    linenr_T last = lnume + xtra - 1;  // last line after the change\n#endif\n\t    // Mark this window to be redrawn later.\n\t    if (wp->w_redr_type < VALID)\n\t\twp->w_redr_type = VALID;\n\n\t    // Check if a change in the buffer has invalidated the cached\n\t    // values for the cursor.\n#ifdef FEAT_FOLDING\n\t    // Update the folds for this window.  Can't postpone this, because\n\t    // a following operator might work on the whole fold: \">>dd\".\n\t    foldUpdate(wp, lnum, last);\n\n\t    // The change may cause lines above or below the change to become\n\t    // included in a fold.  Set lnum/lnume to the first/last line that\n\t    // might be displayed differently.\n\t    // Set w_cline_folded here as an efficient way to update it when\n\t    // inserting lines just above a closed fold.\n\t    i = hasFoldingWin(wp, lnum, &lnum, NULL, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == lnum)\n\t\twp->w_cline_folded = i;\n\t    i = hasFoldingWin(wp, last, NULL, &last, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == last)\n\t\twp->w_cline_folded = i;\n\n\t    // If the changed line is in a range of previously folded lines,\n\t    // compare with the first line in that range.\n\t    if (wp->w_cursor.lnum <= lnum)\n\t    {\n\t\ti = find_wl_entry(wp, lnum);\n\t\tif (i >= 0 && wp->w_cursor.lnum > wp->w_lines[i].wl_lnum)\n\t\t    changed_line_abv_curs_win(wp);\n\t    }\n#endif\n\t    if (wp->w_cursor.lnum > lnum)\n\t\tchanged_line_abv_curs_win(wp);\n\t    else if (wp->w_cursor.lnum == lnum && wp->w_cursor.col >= col)\n\t\tchanged_cline_bef_curs_win(wp);\n\t    if (wp->w_botline >= lnum)\n\t    {\n\t\tif (xtra < 0)\n\t\t    invalidate_botline_win(wp);\n\t\telse\n\t\t    // Assume that botline doesn't change (inserted lines make\n\t\t    // other lines scroll down below botline).\n\t\t    approximate_botline_win(wp);\n\t    }\n\n\t    // Check if any w_lines[] entries have become invalid.\n\t    // For entries below the change: Correct the lnums for\n\t    // inserted/deleted lines.  Makes it possible to stop displaying\n\t    // after the change.\n\t    for (i = 0; i < wp->w_lines_valid; ++i)\n\t\tif (wp->w_lines[i].wl_valid)\n\t\t{\n\t\t    if (wp->w_lines[i].wl_lnum >= lnum)\n\t\t    {\n\t\t\tif (wp->w_lines[i].wl_lnum < lnume)\n\t\t\t{\n\t\t\t    // line included in change\n\t\t\t    wp->w_lines[i].wl_valid = FALSE;\n\t\t\t}\n\t\t\telse if (xtra != 0)\n\t\t\t{\n\t\t\t    // line below change\n\t\t\t    wp->w_lines[i].wl_lnum += xtra;\n#ifdef FEAT_FOLDING\n\t\t\t    wp->w_lines[i].wl_lastlnum += xtra;\n#endif\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FOLDING\n\t\t    else if (wp->w_lines[i].wl_lastlnum >= lnum)\n\t\t    {\n\t\t\t// change somewhere inside this range of folded lines,\n\t\t\t// may need to be redrawn\n\t\t\twp->w_lines[i].wl_valid = FALSE;\n\t\t    }\n#endif\n\t\t}\n\n#ifdef FEAT_FOLDING\n\t    // Take care of side effects for setting w_topline when folds have\n\t    // changed.  Esp. when the buffer was changed in another window.\n\t    if (hasAnyFolding(wp))\n\t\tset_topline(wp, wp->w_topline);\n#endif\n\t    // If lines have been added or removed, relative numbering always\n\t    // requires a redraw.\n\t    if (wp->w_p_rnu && xtra != 0)\n\t    {\n\t\twp->w_last_cursor_lnum_rnu = 0;\n\t\tredraw_win_later(wp, VALID);\n\t    }\n#ifdef FEAT_SYN_HL\n\t    // Cursor line highlighting probably need to be updated with\n\t    // \"VALID\" if it's below the change.\n\t    // If the cursor line is inside the change we need to redraw more.\n\t    if (wp->w_p_cul)\n\t    {\n\t\tif (xtra == 0)\n\t\t    redraw_win_later(wp, VALID);\n\t\telse if (lnum <= wp->w_last_cursorline)\n\t\t    redraw_win_later(wp, SOME_VALID);\n\t    }\n#endif\n\t}\n    }\n\n    // Call update_screen() later, which checks out what needs to be redrawn,\n    // since it notices b_mod_set and then uses b_mod_*.\n    if (must_redraw < VALID)\n\tmust_redraw = VALID;\n\n    // when the cursor line is changed always trigger CursorMoved\n    if (lnum <= curwin->w_cursor.lnum\n\t\t && lnume + (xtra < 0 ? -xtra : xtra) > curwin->w_cursor.lnum)\n\tlast_cursormoved.lnum = 0;\n}"
        ],
        [
          551,
          "if (VIsual_active)"
        ],
        [
          552,
          "check_visual_pos();"
        ]
      ],
      "cve": "CVE-2022-1735"
    },
    {
      "commit_id": "dd4f16e7e816f2165fba76e3d162cd8d2978dcb2",
      "filepath": "src/daemon/protocols/lldp.c",
      "project": "lldpd",
      "project_repo_path": "symbol_backend_projects/lldpd",
      "is_vulnerable": false,
      "func_name": "lldp_decode",
      "func_body": "lldp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tconst char lldpaddr[] = LLDP_MULTICAST_ADDR;\n\tconst char dot1[] = LLDP_TLV_ORG_DOT1;\n\tconst char dot3[] = LLDP_TLV_ORG_DOT3;\n\tconst char med[] = LLDP_TLV_ORG_MED;\n\tconst char dcbx[] = LLDP_TLV_ORG_DCBX;\n\tunsigned char orgid[3];\n\tint length, gotend = 0, ttl_received = 0;\n\tint tlv_size, tlv_type, tlv_subtype;\n\tu_int8_t *pos, *tlv;\n\tchar *b;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan = NULL;\n\tint vlan_len;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi = NULL;\n#endif\n\tstruct lldpd_mgmt *mgmt;\n\tint af;\n\tu_int8_t addr_str_length, addr_str_buffer[32];\n\tu_int8_t addr_family, addr_length, *addr_ptr, iface_subtype;\n\tu_int32_t iface_number, iface;\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom = NULL;\n#endif\n\n\tlog_debug(\"lldp\", \"receive LLDP PDU on %s\",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"lldp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"lldp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n\tTAILQ_INIT(&port->p_ppvids);\n\tTAILQ_INIT(&port->p_pids);\n#endif\n#ifdef ENABLE_CUSTOM\n\tTAILQ_INIT(&port->p_custom_list);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\"lldp\", \"too short frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(lldpaddr, ETHER_ADDR_LEN) != 0) {\n\t\tlog_info(\"lldp\", \"frame not targeted at LLDP multicast address received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\t/* Skip source address */\n\tif (PEEK_UINT16 != ETHERTYPE_LLDP) {\n\t\tlog_info(\"lldp\", \"non LLDP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\twhile (length && (!gotend)) {\n\t\tif (length < 2) {\n\t\t\tlog_warnx(\"lldp\", \"tlv header too short received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_size = PEEK_UINT16;\n\t\ttlv_type = tlv_size >> 9;\n\t\ttlv_size = tlv_size & 0x1ff;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif (length < tlv_size) {\n\t\t\tlog_warnx(\"lldp\", \"frame too short for tlv received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase LLDP_TLV_END:\n\t\t\tif (tlv_size != 0) {\n\t\t\t\tlog_warnx(\"lldp\", \"lldp end received with size not null on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif (length)\n\t\t\t\tlog_debug(\"lldp\", \"extra data after lldp end on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\tgotend = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_CHASSIS_ID:\n\t\tcase LLDP_TLV_PORT_ID:\n\t\t\tCHECK_TLV_SIZE(2, \"Port Id\");\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif ((tlv_subtype == 0) || (tlv_subtype > 7)) {\n\t\t\t\tlog_warnx(\"lldp\", \"unknown subtype for tlv id received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size - 1)) == NULL) {\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory for id tlv \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size - 1);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_ID) {\n\t\t\t\tport->p_id_subtype = tlv_subtype;\n\t\t\t\tport->p_id = b;\n\t\t\t\tport->p_id_len = tlv_size - 1;\n\t\t\t} else {\n\t\t\t\tchassis->c_id_subtype = tlv_subtype;\n\t\t\t\tchassis->c_id = b;\n\t\t\t\tchassis->c_id_len = tlv_size - 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LLDP_TLV_TTL:\n\t\t\tCHECK_TLV_SIZE(2, \"TTL\");\n\t\t\tchassis->c_ttl = PEEK_UINT16;\n\t\t\tttl_received = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_PORT_DESCR:\n\t\tcase LLDP_TLV_SYSTEM_NAME:\n\t\tcase LLDP_TLV_SYSTEM_DESCR:\n\t\t\tif (tlv_size < 1) {\n\t\t\t\tlog_debug(\"lldp\", \"empty tlv received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size + 1)) == NULL) {\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory for string tlv \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_DESCR)\n\t\t\t\tport->p_descr = b;\n\t\t\telse if (tlv_type == LLDP_TLV_SYSTEM_NAME)\n\t\t\t\tchassis->c_name = b;\n\t\t\telse chassis->c_descr = b;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_SYSTEM_CAP:\n\t\t\tCHECK_TLV_SIZE(4, \"System capabilities\");\n\t\t\tchassis->c_cap_available = PEEK_UINT16;\n\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \"Management address\");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tif (addr_str_length > sizeof(addr_str_buffer)) {\n\t\t\t\tlog_warnx(\"lldp\", \"too large management address on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \"Management address\");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\telse\n\t\t\t\tiface = 0;\n\t\t\tmgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);\n\t\t\tif (mgmt == NULL) {\n\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t\t\"for management address\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(1 + (int)sizeof(orgid), \"Organisational\");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot1 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT1_VLANNAME:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"VLAN\");\n\t\t\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc vlan \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tvlan->v_vid = PEEK_UINT16;\n\t\t\t\t\tvlan_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(7 + vlan_len, \"VLAN\");\n\t\t\t\t\tif ((vlan->v_name =\n\t\t\t\t\t\t(char *)calloc(1, vlan_len + 1)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc vlan name for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(vlan->v_name, vlan_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t\t\t    vlan, v_entries);\n\t\t\t\t\tvlan = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PVID:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \"PVID\");\n\t\t\t\t\tport->p_pvid = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PPVID:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"PPVID\");\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PPVID has to be unique if more than\n\t\t\t\t\t   one PPVID TLVs are received  - \n\t\t\t\t\t   discard if duplicate */\n\t\t\t\t\t/* if support bit is not set and \n\t\t\t\t\t   enabled bit is set - PPVID TLV is\n\t\t\t\t\t   considered error  and discarded */\n\t\t\t\t\t/* if PPVID > 4096 - bad and discard */\n\t\t\t\t\tif ((ppvid = (struct lldpd_ppvid *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_ppvid))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc ppvid \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tppvid->p_cap_status = PEEK_UINT8;\n\t\t\t\t\tppvid->p_ppvid = PEEK_UINT16;\t\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_ppvids,\n\t\t\t\t\t    ppvid, p_entries);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PI:\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PI has to be unique if more than \n\t\t\t\t\t   one PI TLVs are received  - discard\n\t\t\t\t\t   if duplicate ?? */\n\t\t\t\t\tCHECK_TLV_SIZE(5, \"PI\");\n\t\t\t\t\tif ((pi = (struct lldpd_pi *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_pi))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc PI \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tpi->p_pi_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(5 + pi->p_pi_len, \"PI\");\n\t\t\t\t\tif ((pi->p_pi =\n\t\t\t\t\t\t(char *)calloc(1, pi->p_pi_len)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc pid name for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(pi->p_pi, pi->p_pi_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_pids,\n\t\t\t\t\t    pi, p_entries);\n\t\t\t\t\tpi = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot1 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(dot3, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT3\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot3 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT3_MAC:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \"MAC/PHY\");\n\t\t\t\t\tport->p_macphy.autoneg_support = PEEK_UINT8;\n\t\t\t\t\tport->p_macphy.autoneg_enabled =\n\t\t\t\t\t    (port->p_macphy.autoneg_support & 0x2) >> 1;\n\t\t\t\t\tport->p_macphy.autoneg_support =\n\t\t\t\t\t    port->p_macphy.autoneg_support & 0x1;\n\t\t\t\t\tport->p_macphy.autoneg_advertised =\n\t\t\t\t\t    PEEK_UINT16;\n\t\t\t\t\tport->p_macphy.mau_type = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_LA:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \"Link aggregation\");\n\t\t\t\t\tPEEK_DISCARD_UINT8;\n\t\t\t\t\tport->p_aggregid = PEEK_UINT32;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_MFS:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \"MFS\");\n\t\t\t\t\tport->p_mfs = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_POWER:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"Power\");\n\t\t\t\t\tport->p_power.devicetype = PEEK_UINT8;\n\t\t\t\t\tport->p_power.supported =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x2) >> 1;\n\t\t\t\t\tport->p_power.enabled =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x4) >> 2;\n\t\t\t\t\tport->p_power.paircontrol =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x8) >> 3;\n\t\t\t\t\tport->p_power.devicetype =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x1)?\n\t\t\t\t\t\tLLDP_DOT3_POWER_PSE:LLDP_DOT3_POWER_PD;\n\t\t\t\t\tport->p_power.pairs = PEEK_UINT8;\n\t\t\t\t\tport->p_power.class = PEEK_UINT8;\n\t\t\t\t\t/* 802.3at? */\n\t\t\t\t\tif (tlv_size >= 12) {\n\t\t\t\t\t\tport->p_power.powertype = PEEK_UINT8;\n\t\t\t\t\t\tport->p_power.source =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<5 | 1<<4)) >> 4;\n\t\t\t\t\t\tport->p_power.priority =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<1 | 1<<0));\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<7))?\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE1:\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE2;\n\t\t\t\t\t\tport->p_power.requested = PEEK_UINT16;\n\t\t\t\t\t\tport->p_power.allocated = PEEK_UINT16;\n\t\t\t\t\t} else\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_OFF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot3 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(med, orgid, sizeof(orgid)) == 0) {\n\t\t\t\t/* LLDP-MED */\n#ifndef ENABLE_LLDPMED\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\tu_int32_t policy;\n\t\t\t\tunsigned loctype;\n\t\t\t\tunsigned power;\n\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_MED_CAP:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"LLDP-MED capabilities\");\n\t\t\t\t\tchassis->c_med_cap_available = PEEK_UINT16;\n\t\t\t\t\tchassis->c_med_type = PEEK_UINT8;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_CAP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_POLICY:\n\t\t\t\t\tCHECK_TLV_SIZE(8, \"LLDP-MED policy\");\n\t\t\t\t\tpolicy = PEEK_UINT32;\n\t\t\t\t\tif (((policy >> 24) < 1) ||\n\t\t\t\t\t    ((policy >> 24) > LLDP_MED_APPTYPE_LAST)) {\n\t\t\t\t\t\tlog_info(\"lldp\", \"unknown policy field %d \"\n\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t    policy,\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].type =\n\t\t\t\t\t    (policy >> 24);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].unknown =\n\t\t\t\t\t    ((policy & 0x800000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].tagged =\n\t\t\t\t\t    ((policy & 0x400000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].vid =\n\t\t\t\t\t    (policy & 0x001FFE00) >> 9;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].priority =\n\t\t\t\t\t    (policy & 0x1C0) >> 6;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].dscp =\n\t\t\t\t\t    policy & 0x3F;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_POLICY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_LOCATION:\n\t\t\t\t\tCHECK_TLV_SIZE(5, \"LLDP-MED Location\");\n\t\t\t\t\tloctype = PEEK_UINT8;\n\t\t\t\t\tif ((loctype < 1) ||\n\t\t\t\t\t    (loctype > LLDP_MED_LOCFORMAT_LAST)) {\n\t\t\t\t\t\tlog_info(\"lldp\", \"unknown location type \"\n\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((port->p_med_location[loctype - 1].data =\n\t\t\t\t\t\t(char*)malloc(tlv_size - 5)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t    \"for LLDP-MED location for \"\n\t\t\t\t\t\t    \"frame received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(port->p_med_location[loctype - 1].data,\n\t\t\t\t\t    tlv_size - 5);\n\t\t\t\t\tport->p_med_location[loctype - 1].data_len =\n\t\t\t\t\t    tlv_size - 5;\n\t\t\t\t\tport->p_med_location[loctype - 1].format = loctype;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_LOCATION;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_MDI:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"LLDP-MED PoE-MDI\");\n\t\t\t\t\tpower = PEEK_UINT8;\n\t\t\t\t\tswitch (power & 0xC0) {\n\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PSE;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PSE;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PRIMARY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BACKUP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_RESERVED;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PD;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PD;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_LOCAL;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BOTH;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tport->p_med_power.devicetype =\n\t\t\t\t\t\t    LLDP_MED_POW_TYPE_RESERVED;\n\t\t\t\t\t}\n\t\t\t\t\tif ((power & 0x0F) > LLDP_MED_POW_PRIO_LOW)\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    LLDP_MED_POW_PRIO_UNKNOWN;\n\t\t\t\t\telse\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    power & 0x0F;\n\t\t\t\t\tport->p_med_power.val = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\tif (tlv_size <= 4)\n\t\t\t\t\t\tb = NULL;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ((b = (char*)malloc(tlv_size - 3)) ==\n\t\t\t\t\t\t    NULL) {\n\t\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate \"\n\t\t\t\t\t\t\t    \"memory for LLDP-MED \"\n\t\t\t\t\t\t\t    \"inventory for frame \"\n\t\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPEEK_BYTES(b, tlv_size - 4);\n\t\t\t\t\t\tb[tlv_size - 4] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\t\t\tchassis->c_med_hw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\t\t\tchassis->c_med_fw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\t\t\tchassis->c_med_sw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\t\t\tchassis->c_med_sn = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\t\t\tchassis->c_med_manuf = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\t\t\tchassis->c_med_model = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\t\tchassis->c_med_asset = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_IV;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown LLDP MED, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif /* ENABLE_LLDPMED */\n\t\t\t} else if (memcmp(dcbx, orgid, sizeof(orgid)) == 0) {\n\t\t\t\tlog_debug(\"lldp\", \"unsupported DCBX tlv received on %s - ignore\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t} else {\n\t\t\t\tlog_debug(\"lldp\", \"unknown org tlv [%02x:%02x:%02x] received on %s\",\n\t\t\t\t    orgid[0], orgid[1], orgid[2],\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#ifdef ENABLE_CUSTOM\n\t\t\t\tcustom = (struct lldpd_custom*)calloc(1, sizeof(struct lldpd_custom));\n\t\t\t\tif (!custom) {\n\t\t\t\t\tlog_warn(\"lldp\",\n\t\t\t\t\t    \"unable to allocate memory for custom TLV\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tcustom->oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0;\n\t\t\t\tmemcpy(custom->oui, orgid, sizeof(custom->oui));\n\t\t\t\tcustom->subtype = tlv_subtype;\n\t\t\t\tif (custom->oui_info_len > 0) {\n\t\t\t\t\tcustom->oui_info = malloc(custom->oui_info_len);\n\t\t\t\t\tif (!custom->oui_info) {\n\t\t\t\t\t\tlog_warn(\"lldp\",\n\t\t\t\t\t\t    \"unable to allocate memory for custom TLV data\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(custom->oui_info, custom->oui_info_len);\n\t\t\t\t}\n\t\t\t\tTAILQ_INSERT_TAIL(&port->p_custom_list, custom, next);\n\t\t\t\tcustom = NULL;\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_warnx(\"lldp\", \"unknown tlv (%d) received on %s\",\n\t\t\t    tlv_type, hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tif (pos > tlv + tlv_size) {\n\t\t\tlog_warnx(\"lldp\", \"BUG: already past TLV!\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_size - pos);\n\t}\n\n\t/* Some random check */\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (!ttl_received) ||\n\t    (gotend == 0)) {\n\t\tlog_warnx(\"lldp\", \"some mandatory tlv are missing for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\nmalformed:\n#ifdef ENABLE_CUSTOM\n\tfree(custom);\n#endif\n#ifdef ENABLE_DOT1\n\tfree(vlan);\n\tfree(pi);\n#endif\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}",
      "line_statements": [
        [
          729,
          "\t\t\tif (addr_str_length > sizeof(addr_str_buffer)) {"
        ],
        [
          730,
          "\t\t\t\tlog_warnx(\"lldp\", \"too large management address on %s\","
        ],
        [
          731,
          "\t\t\t\t    hardware->h_ifname);"
        ],
        [
          732,
          "\t\t\t\tgoto malformed;"
        ],
        [
          733,
          "\t\t\t}"
        ],
        [
          742,
          ""
        ],
        [
          760,
          "\t\t\tCHECK_TLV_SIZE(1 + (int)sizeof(orgid), \"Organisational\");"
        ]
      ],
      "statements": [
        [
          726,
          "case LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \"Management address\");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tif (addr_str_length > sizeof(addr_str_buffer)) {\n\t\t\t\tlog_warnx(\"lldp\", \"too large management address on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \"Management address\");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\telse\n\t\t\t\tiface = 0;\n\t\t\tmgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);\n\t\t\tif (mgmt == NULL) {\n\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t\t\"for management address\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;"
        ],
        [
          729,
          "if (addr_str_length > sizeof(addr_str_buffer))"
        ],
        [
          730,
          "log_warnx(\"lldp\", \"too large management address on %s\",\n\t\t\t\t    hardware->h_ifname);"
        ],
        [
          732,
          "goto malformed;"
        ],
        [
          733,
          "\t\t\t}\n"
        ],
        [
          760,
          "CHECK_TLV_SIZE(1 + (int)sizeof(orgid), \"Organisational\");"
        ]
      ],
      "cve": "CVE-2015-8011"
    },
    {
      "commit_id": "3e990547e064b8fca916b23a0f7d6fe8c63c7f6b",
      "filepath": "clickhouse_driver/varint.c",
      "project": "clickhouse-driver",
      "project_repo_path": "symbol_backend_projects/clickhouse-driver",
      "is_vulnerable": false,
      "func_name": "__pyx_pf_17clickhouse_driver_6varint_2read_varint",
      "func_body": "static PyObject *__pyx_pf_17clickhouse_driver_6varint_2read_varint(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_f) {\n  unsigned char __pyx_v_shift;\n  unsigned PY_LONG_LONG __pyx_v_i;\n  unsigned PY_LONG_LONG __pyx_v_result;\n  PyObject *__pyx_v_read_one = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  unsigned PY_LONG_LONG __pyx_t_4;\n  int __pyx_t_5;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"read_varint\", 0);\n\n  /* \"clickhouse_driver/varint.pyx\":32\n *     Reads integer of variable length using LEB128.\n *     \"\"\"\n *     cdef unsigned char shift = 0             # <<<<<<<<<<<<<<\n *     cdef unsigned long long i, result = 0\n * \n */\n  __pyx_v_shift = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":33\n *     \"\"\"\n *     cdef unsigned char shift = 0\n *     cdef unsigned long long i, result = 0             # <<<<<<<<<<<<<<\n * \n *     read_one = f.read_one\n */\n  __pyx_v_result = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":35\n *     cdef unsigned long long i, result = 0\n * \n *     read_one = f.read_one             # <<<<<<<<<<<<<<\n * \n *     while True:\n */\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_f, __pyx_n_s_read_one); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 35, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_read_one = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":37\n *     read_one = f.read_one\n * \n *     while True:             # <<<<<<<<<<<<<<\n *         i = read_one()\n *         result |= (i & 0x7f) << shift\n */\n  while (1) {\n\n    /* \"clickhouse_driver/varint.pyx\":38\n * \n *     while True:\n *         i = read_one()             # <<<<<<<<<<<<<<\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n */\n    __Pyx_INCREF(__pyx_v_read_one);\n    __pyx_t_2 = __pyx_v_read_one; __pyx_t_3 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n      if (likely(__pyx_t_3)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n        __Pyx_INCREF(__pyx_t_3);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_2, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);\n    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 38, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_t_4 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_1); if (unlikely((__pyx_t_4 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 38, __pyx_L1_error)\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __pyx_v_i = __pyx_t_4;\n\n    /* \"clickhouse_driver/varint.pyx\":39\n *     while True:\n *         i = read_one()\n *         result |= (i & 0x7f) << shift             # <<<<<<<<<<<<<<\n *         shift += 7\n *         if i < 0x80:\n */\n    __pyx_v_result = (__pyx_v_result | ((__pyx_v_i & 0x7f) << __pyx_v_shift));\n\n    /* \"clickhouse_driver/varint.pyx\":40\n *         i = read_one()\n *         result |= (i & 0x7f) << shift\n *         shift += 7             # <<<<<<<<<<<<<<\n *         if i < 0x80:\n *             break\n */\n    __pyx_v_shift = (__pyx_v_shift + 7);\n\n    /* \"clickhouse_driver/varint.pyx\":41\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n *         if i < 0x80:             # <<<<<<<<<<<<<<\n *             break\n * \n */\n    __pyx_t_5 = ((__pyx_v_i < 0x80) != 0);\n    if (__pyx_t_5) {\n\n      /* \"clickhouse_driver/varint.pyx\":42\n *         shift += 7\n *         if i < 0x80:\n *             break             # <<<<<<<<<<<<<<\n * \n *     return result\n */\n      goto __pyx_L4_break;\n\n      /* \"clickhouse_driver/varint.pyx\":41\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n *         if i < 0x80:             # <<<<<<<<<<<<<<\n *             break\n * \n */\n    }\n  }\n  __pyx_L4_break:;\n\n  /* \"clickhouse_driver/varint.pyx\":44\n *             break\n * \n *     return result             # <<<<<<<<<<<<<<\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(__pyx_v_result); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 44, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/varint.pyx\":28\n * \n * \n * def read_varint(f):             # <<<<<<<<<<<<<<\n *     \"\"\"\n *     Reads integer of variable length using LEB128.\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.varint.read_varint\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_read_one);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}",
      "line_statements": [
        [
          1529,
          "  int __pyx_lineno = 0;"
        ],
        [
          1530,
          "  const char *__pyx_filename = NULL;"
        ],
        [
          1531,
          "  int __pyx_clineno = 0;"
        ]
      ],
      "statements": [
        [
          1529,
          "int __pyx_lineno = 0;"
        ],
        [
          1530,
          "const char *__pyx_filename = NULL;"
        ],
        [
          1531,
          "int __pyx_clineno = 0;"
        ]
      ],
      "cve": "CVE-2020-26759"
    },
    {
      "commit_id": "d27f79da11df7bc8bb56c2f291d71e54df8d2c47",
      "filepath": "pjsip/src/pjsip/sip_auth_aka.c",
      "project": "pjproject",
      "project_repo_path": "symbol_backend_projects/pjproject",
      "is_vulnerable": true,
      "func_name": "pjsip_auth_create_aka_response",
      "func_body": "PJ_DEF(pj_status_t) pjsip_auth_create_aka_response( \n\t\t\t\t\t     pj_pool_t *pool,\n\t\t\t\t\t     const pjsip_digest_challenge *chal,\n\t\t\t\t\t     const pjsip_cred_info *cred,\n\t\t\t\t\t     const pj_str_t *method,\n\t\t\t\t\t     pjsip_digest_credential *auth)\n{\n    pj_str_t nonce_bin;\n    int aka_version;\n    const pj_str_t pjsip_AKAv1_MD5 = { \"AKAv1-MD5\", 9 };\n    const pj_str_t pjsip_AKAv2_MD5 = { \"AKAv2-MD5\", 9 };\n    pj_uint8_t *chal_rand, *chal_sqnxoraka, *chal_mac;\n    pj_uint8_t k[PJSIP_AKA_KLEN];\n    pj_uint8_t op[PJSIP_AKA_OPLEN];\n    pj_uint8_t amf[PJSIP_AKA_AMFLEN];\n    pj_uint8_t res[PJSIP_AKA_RESLEN];\n    pj_uint8_t ck[PJSIP_AKA_CKLEN];\n    pj_uint8_t ik[PJSIP_AKA_IKLEN];\n    pj_uint8_t ak[PJSIP_AKA_AKLEN];\n    pj_uint8_t sqn[PJSIP_AKA_SQNLEN];\n    pj_uint8_t xmac[PJSIP_AKA_MACLEN];\n    pjsip_cred_info aka_cred;\n    int i, len;\n    pj_status_t status;\n\n    /* Check the algorithm is supported. */\n    if (chal->algorithm.slen==0 || pj_stricmp2(&chal->algorithm, \"md5\") == 0) {\n\t/*\n\t * A normal MD5 authentication is requested. Fallbackt to the usual\n\t * MD5 digest creation.\n\t */\n\tpjsip_auth_create_digest(&auth->response, &auth->nonce, &auth->nc,\n\t\t\t\t &auth->cnonce, &auth->qop, &auth->uri,\n\t\t\t\t &auth->realm, cred, method);\n\treturn PJ_SUCCESS;\n\n    } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5) == 0) {\n\t/*\n\t * AKA version 1 is requested.\n\t */\n\taka_version = 1;\n\n    } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv2_MD5) == 0) {\n\t/*\n\t * AKA version 2 is requested.\n\t */\n\taka_version = 2;\n\n    } else {\n\t/* Unsupported algorithm */\n\treturn PJSIP_EINVALIDALGORITHM;\n    }\n\n    /* Decode nonce */\n    nonce_bin.slen = len = PJ_BASE64_TO_BASE256_LEN(chal->nonce.slen);\n    nonce_bin.ptr = pj_pool_alloc(pool, nonce_bin.slen + 1);\n    status = pj_base64_decode(&chal->nonce, (pj_uint8_t*)nonce_bin.ptr, &len);\n    nonce_bin.slen = len;\n    if (status != PJ_SUCCESS)\n\treturn PJSIP_EAUTHINNONCE;\n\n    if (nonce_bin.slen < PJSIP_AKA_RANDLEN + PJSIP_AKA_AUTNLEN)\n\treturn PJSIP_EAUTHINNONCE;\n\n    /* Get RAND, AUTN, and MAC */\n    chal_rand = (pj_uint8_t*)(nonce_bin.ptr + 0);\n    chal_sqnxoraka = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN);\n    chal_mac = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN + \n\t\t\t      PJSIP_AKA_SQNLEN + PJSIP_AKA_AMFLEN);\n\n    /* Copy k. op, and amf */\n    pj_bzero(k, sizeof(k));\n    pj_bzero(op, sizeof(op));\n    pj_bzero(amf, sizeof(amf));\n\n    if (cred->ext.aka.k.slen)\n\tpj_memcpy(k, cred->ext.aka.k.ptr, cred->ext.aka.k.slen);\n    if (cred->ext.aka.op.slen)\n\tpj_memcpy(op, cred->ext.aka.op.ptr, cred->ext.aka.op.slen);\n    if (cred->ext.aka.amf.slen)\n\tpj_memcpy(amf, cred->ext.aka.amf.ptr, cred->ext.aka.amf.slen);\n\n    /* Given key K and random challenge RAND, compute response RES,\n     * confidentiality key CK, integrity key IK and anonymity key AK.\n     */\n    f2345(k, chal_rand, res, ck, ik, ak, op);\n\n    /* Compute sequence number SQN */\n    for (i=0; i<PJSIP_AKA_SQNLEN; ++i)\n\tsqn[i] = (pj_uint8_t) (chal_sqnxoraka[i] ^ ak[i]);\n\n    /* Verify MAC in the challenge */\n    /* Compute XMAC */\n    f1(k, chal_rand, sqn, amf, xmac, op);\n\n    if (pj_memcmp(chal_mac, xmac, PJSIP_AKA_MACLEN) != 0) {\n\treturn PJSIP_EAUTHINNONCE;\n    }\n\n    /* Build a temporary credential info to create MD5 digest, using\n     * \"res\" as the password. \n     */\n    pj_memcpy(&aka_cred, cred, sizeof(aka_cred));\n    aka_cred.data_type = PJSIP_CRED_DATA_PLAIN_PASSWD;\n\n    /* Create a response */\n    if (aka_version == 1) {\n\t/*\n\t * For AKAv1, the password is RES\n\t */\n\taka_cred.data.ptr = (char*)res;\n\taka_cred.data.slen = PJSIP_AKA_RESLEN;\n\n\tpjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\n\n    } else if (aka_version == 2) {\n\n\t/*\n\t * For AKAv2, password is base64 encoded [1] parameters:\n\t *    PRF(RES||IK||CK,\"http-digest-akav2-password\")\n\t *\n\t * The pseudo-random function (PRF) is HMAC-MD5 in this case.\n\t */\n\n\tpj_str_t resikck;\n\tconst pj_str_t AKAv2_Passwd = { \"http-digest-akav2-password\", 26 };\n\tpj_uint8_t hmac_digest[16];\n\tchar tmp_buf[48];\n\tint hmac64_len;\n\n\tresikck.slen = PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN + PJSIP_AKA_CKLEN;\n\tpj_assert(resikck.slen <= PJ_ARRAY_SIZE(tmp_buf));\n\tresikck.ptr = tmp_buf;\n\tpj_memcpy(resikck.ptr + 0, res, PJSIP_AKA_RESLEN);\n\tpj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN, ik, PJSIP_AKA_IKLEN);\n\tpj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN,\n\t          ck, PJSIP_AKA_CKLEN);\n\n\tpj_hmac_md5((const pj_uint8_t*)AKAv2_Passwd.ptr, AKAv2_Passwd.slen,\n\t            (const pj_uint8_t*)resikck.ptr, resikck.slen,\n\t            hmac_digest);\n\n\taka_cred.data.slen = hmac64_len =\n\t\tPJ_BASE256_TO_BASE64_LEN(PJ_ARRAY_SIZE(hmac_digest));\n\tpj_assert(aka_cred.data.slen+1 <= PJ_ARRAY_SIZE(tmp_buf));\n\taka_cred.data.ptr = tmp_buf;\n\tpj_base64_encode(hmac_digest, PJ_ARRAY_SIZE(hmac_digest),\n\t                 aka_cred.data.ptr, &len);\n\taka_cred.data.slen = hmac64_len;\n\n\tpjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\n\n    } else {\n\tpj_assert(!\"Bug!\");\n\treturn PJ_EBUG;\n    }\n\n    /* Done */\n    return PJ_SUCCESS;\n}",
      "line_statements": [
        [
          60,
          "    pj_status_t status;"
        ],
        [
          68,
          "\tpjsip_auth_create_digest(&auth->response, &auth->nonce, &auth->nc,"
        ],
        [
          69,
          "\t\t\t\t &auth->cnonce, &auth->qop, &auth->uri,"
        ],
        [
          70,
          "\t\t\t\t &auth->realm, cred, method);"
        ],
        [
          71,
          "\treturn PJ_SUCCESS;"
        ],
        [
          150,
          "\tpjsip_auth_create_digest(&auth->response, &chal->nonce,"
        ],
        [
          152,
          "\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);"
        ],
        [
          189,
          "\tpjsip_auth_create_digest(&auth->response, &chal->nonce,"
        ],
        [
          199,
          "    return PJ_SUCCESS;"
        ]
      ],
      "statements": [
        [
          60,
          "pj_status_t status;"
        ],
        [
          68,
          "pjsip_auth_create_digest(&auth->response, &auth->nonce, &auth->nc,\n\t\t\t\t &auth->cnonce, &auth->qop, &auth->uri,\n\t\t\t\t &auth->realm, cred, method);"
        ],
        [
          71,
          "return PJ_SUCCESS;"
        ],
        [
          150,
          "pjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);"
        ],
        [
          189,
          "pjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);"
        ],
        [
          199,
          "return PJ_SUCCESS;"
        ]
      ],
      "cve": "CVE-2022-24754"
    },
    {
      "commit_id": "1c518555dba6ceb45d5ba61845b96e261219c3b7",
      "filepath": "hphp/runtime/ext/mbstring/ext_mbstring.cpp",
      "project": "hhvm",
      "project_repo_path": "symbol_backend_projects/hhvm",
      "is_vulnerable": false,
      "func_name": "HPHP::_php_mb_regex_ereg_replace_exec",
      "func_body": "static Variant _php_mb_regex_ereg_replace_exec(const Variant& pattern,\n                                               const String& replacement,\n                                               const String& str,\n                                               const String& option,\n                                               OnigOptionType options) {\n  const char *p;\n  php_mb_regex_t *re;\n  OnigSyntaxType *syntax;\n  OnigRegion *regs = nullptr;\n  StringBuffer out_buf;\n  int i, err, eval, n;\n  OnigUChar *pos;\n  OnigUChar *string_lim;\n  char pat_buf[2];\n\n  const mbfl_encoding *enc;\n\n  {\n    const char *current_enc_name;\n    current_enc_name = php_mb_regex_mbctype2name(MBSTRG(current_mbctype));\n    if (current_enc_name == nullptr ||\n      (enc = mbfl_name2encoding(current_enc_name)) == nullptr) {\n      raise_warning(\"Unknown error\");\n      return false;\n    }\n  }\n  eval = 0;\n  {\n    if (!option.empty()) {\n      _php_mb_regex_init_options(option.data(), option.size(),\n                                 &options, &syntax, &eval);\n    } else {\n      options |= MBSTRG(regex_default_options);\n      syntax = MBSTRG(regex_default_syntax);\n    }\n  }\n\n  String spattern;\n  if (pattern.isString()) {\n    spattern = pattern.toString();\n  } else {\n    /* FIXME: this code is not multibyte aware! */\n    pat_buf[0] = pattern.toByte();\n    pat_buf[1] = '\\0';\n    spattern = String(pat_buf, 1, CopyString);\n  }\n  /* create regex pattern buffer */\n  re = php_mbregex_compile_pattern(spattern, options,\n                                   MBSTRG(current_mbctype), syntax);\n  if (re == nullptr) {\n    return false;\n  }\n\n  if (eval) {\n    throw_not_supported(\"ereg_replace\", \"dynamic coding\");\n  }\n\n  /* do the actual work */\n  err = 0;\n  pos = (OnigUChar*)str.data();\n  string_lim = (OnigUChar*)(str.data() + str.size());\n  regs = onig_region_new();\n  while (err >= 0) {\n    err = onig_search(re, (OnigUChar *)str.data(), (OnigUChar *)string_lim,\n                      pos, (OnigUChar *)string_lim, regs, 0);\n    if (err <= -2) {\n      OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n      onig_error_code_to_str(err_str, err);\n      raise_warning(\"mbregex search failure: %s\", err_str);\n      break;\n    }\n    if (err >= 0) {\n#if moriyoshi_0\n      if (regs->beg[0] == regs->end[0]) {\n        raise_warning(\"Empty regular expression\");\n        break;\n      }\n#endif\n      /* copy the part of the string before the match */\n      out_buf.append((const char *)pos,\n                     (OnigUChar *)(str.data() + regs->beg[0]) - pos);\n      /* copy replacement and backrefs */\n      i = 0;\n      p = replacement.data();\n      while (i < replacement.size()) {\n        int fwd = (int)php_mb_mbchar_bytes_ex(p, enc);\n        n = -1;\n        auto const remaining = replacement.size() - i;\n        if (remaining >= 2 && fwd == 1 &&\n            p[0] == '\\\\' && p[1] >= '0' && p[1] <= '9') {\n          n = p[1] - '0';\n        }\n        if (n >= 0 && n < regs->num_regs) {\n          if (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] &&\n              regs->end[n] <= str.size()) {\n            out_buf.append(str.data() + regs->beg[n],\n                           regs->end[n] - regs->beg[n]);\n          }\n          p += 2;\n          i += 2;\n        } else if (remaining >= fwd) {\n          out_buf.append(p, fwd);\n          p += fwd;\n          i += fwd;\n        } else {\n          raise_warning(\"Replacement ends with unterminated %s: 0x%hhx\",\n                        enc->name, *p);\n          break;\n        }\n      }\n      n = regs->end[0];\n      if ((pos - (OnigUChar *)str.data()) < n) {\n        pos = (OnigUChar *)(str.data() + n);\n      } else {\n        if (pos < string_lim) {\n          out_buf.append((const char *)pos, 1);\n        }\n        pos++;\n      }\n    } else { /* nomatch */\n      /* stick that last bit of string on our output */\n      if (string_lim - pos > 0) {\n        out_buf.append((const char *)pos, string_lim - pos);\n      }\n    }\n    onig_region_free(regs, 0);\n  }\n\n  if (regs != nullptr) {\n    onig_region_free(regs, 1);\n  }\n\n  if (err <= -2) {\n    return false;\n  }\n  return out_buf.detach();\n}",
      "line_statements": [
        [
          3612,
          "        auto const remaining = replacement.size() - i;"
        ],
        [
          3613,
          "        if (remaining >= 2 && fwd == 1 &&"
        ],
        [
          3614,
          "            p[0] == '\\\\' && p[1] >= '0' && p[1] <= '9') {"
        ],
        [
          3625,
          "        } else if (remaining >= fwd) {"
        ],
        [
          3629,
          "        } else {"
        ],
        [
          3630,
          "          raise_warning(\"Replacement ends with unterminated %s: 0x%hhx\","
        ],
        [
          3631,
          "                        enc->name, *p);"
        ],
        [
          3632,
          "          break;"
        ]
      ],
      "statements": [
        [
          3612,
          "auto const remaining = replacement.size() - i;"
        ],
        [
          3613,
          "if (remaining >= 2 && fwd == 1 &&\n            p[0] == '\\\\' && p[1] >= '0' && p[1] <= '9')"
        ],
        [
          3625,
          "else if (remaining >= fwd)"
        ],
        [
          3629,
          "else"
        ],
        [
          3630,
          "raise_warning(\"Replacement ends with unterminated %s: 0x%hhx\",\n                        enc->name, *p);"
        ],
        [
          3632,
          "break;"
        ]
      ],
      "cve": "CVE-2019-11935"
    }
  ],
  "CWE-415": [
    {
      "commit_id": "a49feeae76d41959d85ee733925a4cf40bac61b2",
      "filepath": "src/gd_webp.c",
      "project": "libgd",
      "project_repo_path": "symbol_backend_projects/libgd",
      "is_vulnerable": true,
      "func_name": "gdImageWebpPtr",
      "func_body": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\n\treturn rv;\n}",
      "line_statements": [
        [
          321,
          "\tgdImageWebpCtx(im, out, -1);"
        ],
        [
          322,
          "\trv = gdDPExtractData(out, size);"
        ]
      ],
      "statements": [
        [
          321,
          "gdImageWebpCtx(im, out, -1);"
        ],
        [
          322,
          "rv = gdDPExtractData(out, size);"
        ]
      ],
      "cve": "CVE-2016-6912"
    },
    {
      "commit_id": "87ca4f9efbd7cc649ff43b87970888f2812945b8",
      "filepath": "kernel/sched/core.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "dup_user_cpus_ptr",
      "func_body": "int dup_user_cpus_ptr(struct task_struct *dst, struct task_struct *src,\n\t\t      int node)\n{\n\tcpumask_t *user_mask;\n\tunsigned long flags;\n\n\t/*\n\t * Always clear dst->user_cpus_ptr first as their user_cpus_ptr's\n\t * may differ by now due to racing.\n\t */\n\tdst->user_cpus_ptr = NULL;\n\n\t/*\n\t * This check is racy and losing the race is a valid situation.\n\t * It is not worth the extra overhead of taking the pi_lock on\n\t * every fork/clone.\n\t */\n\tif (data_race(!src->user_cpus_ptr))\n\t\treturn 0;\n\n\tuser_mask = kmalloc_node(cpumask_size(), GFP_KERNEL, node);\n\tif (!user_mask)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Use pi_lock to protect content of user_cpus_ptr\n\t *\n\t * Though unlikely, user_cpus_ptr can be reset to NULL by a concurrent\n\t * do_set_cpus_allowed().\n\t */\n\traw_spin_lock_irqsave(&src->pi_lock, flags);\n\tif (src->user_cpus_ptr) {\n\t\tswap(dst->user_cpus_ptr, user_mask);\n\t\tcpumask_copy(dst->user_cpus_ptr, src->user_cpus_ptr);\n\t}\n\traw_spin_unlock_irqrestore(&src->pi_lock, flags);\n\n\tif (unlikely(user_mask))\n\t\tkfree(user_mask);\n\n\treturn 0;\n}\n",
      "line_statements": [
        [
          2615,
          "\tcpumask_t *user_mask;\n"
        ],
        [
          2618,
          "\t/*\n"
        ],
        [
          2619,
          "\t * Always clear dst->user_cpus_ptr first as their user_cpus_ptr's\n"
        ],
        [
          2620,
          "\t * may differ by now due to racing.\n"
        ],
        [
          2621,
          "\t */\n"
        ],
        [
          2622,
          "\tdst->user_cpus_ptr = NULL;\n"
        ],
        [
          2623,
          "\n"
        ],
        [
          2624,
          "\t/*\n"
        ],
        [
          2625,
          "\t * This check is racy and losing the race is a valid situation.\n"
        ],
        [
          2626,
          "\t * It is not worth the extra overhead of taking the pi_lock on\n"
        ],
        [
          2627,
          "\t * every fork/clone.\n"
        ],
        [
          2628,
          "\t */\n"
        ],
        [
          2629,
          "\tif (data_race(!src->user_cpus_ptr))\n"
        ],
        [
          2632,
          "\tuser_mask = kmalloc_node(cpumask_size(), GFP_KERNEL, node);\n"
        ],
        [
          2633,
          "\tif (!user_mask)\n"
        ],
        [
          2636,
          "\t/*\n"
        ],
        [
          2637,
          "\t * Use pi_lock to protect content of user_cpus_ptr\n"
        ],
        [
          2638,
          "\t *\n"
        ],
        [
          2639,
          "\t * Though unlikely, user_cpus_ptr can be reset to NULL by a concurrent\n"
        ],
        [
          2640,
          "\t * do_set_cpus_allowed().\n"
        ],
        [
          2641,
          "\t */\n"
        ],
        [
          2643,
          "\tif (src->user_cpus_ptr) {\n"
        ],
        [
          2644,
          "\t\tswap(dst->user_cpus_ptr, user_mask);\n"
        ],
        [
          2645,
          "\t\tcpumask_copy(dst->user_cpus_ptr, src->user_cpus_ptr);\n"
        ],
        [
          2646,
          "\t}\n"
        ],
        [
          2648,
          "\n"
        ],
        [
          2649,
          "\tif (unlikely(user_mask))\n"
        ],
        [
          2650,
          "\t\tkfree(user_mask);\n"
        ],
        [
          2651,
          "\n"
        ]
      ],
      "statements": [
        [
          2615,
          "cpumask_t *user_mask;"
        ],
        [
          2618,
          "/*\n\t * Always clear dst->user_cpus_ptr first as their user_cpus_ptr's\n\t * may differ by now due to racing.\n\t */"
        ],
        [
          2622,
          "dst->user_cpus_ptr = NULL;"
        ],
        [
          2623,
          "\n"
        ],
        [
          2624,
          "/*\n\t * This check is racy and losing the race is a valid situation.\n\t * It is not worth the extra overhead of taking the pi_lock on\n\t * every fork/clone.\n\t */"
        ],
        [
          2629,
          "if (data_race(!src->user_cpus_ptr))"
        ],
        [
          2632,
          "user_mask = kmalloc_node(cpumask_size(), GFP_KERNEL, node);"
        ],
        [
          2633,
          "if (!user_mask)"
        ],
        [
          2636,
          "/*\n\t * Use pi_lock to protect content of user_cpus_ptr\n\t *\n\t * Though unlikely, user_cpus_ptr can be reset to NULL by a concurrent\n\t * do_set_cpus_allowed().\n\t */"
        ],
        [
          2643,
          "if (src->user_cpus_ptr)"
        ],
        [
          2644,
          "swap(dst->user_cpus_ptr, user_mask);"
        ],
        [
          2645,
          "cpumask_copy(dst->user_cpus_ptr, src->user_cpus_ptr);"
        ],
        [
          2646,
          "\t}\n"
        ],
        [
          2648,
          "\n"
        ],
        [
          2649,
          "if (unlikely(user_mask))"
        ],
        [
          2650,
          "kfree(user_mask);"
        ],
        [
          2651,
          "\n"
        ]
      ],
      "cve": "CVE-2022-48892"
    },
    {
      "commit_id": "c70222752228a62135cee3409dccefd494a24646",
      "filepath": "drivers/net/can/usb/ems_usb.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "ems_usb_start_xmit",
      "func_body": "static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tstruct ems_tx_urb_context *context = NULL;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct ems_cpc_msg *msg;\n\tstruct urb *urb;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN\n\t\t\t+ sizeof(struct cpc_can_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(dev->udev, size, GFP_ATOMIC, &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tusb_free_urb(urb);\n\t\tgoto nomem;\n\t}\n\n\tmsg = (struct ems_cpc_msg *)&buf[CPC_HEADER_SIZE];\n\n\tmsg->msg.can_msg.id = cpu_to_le32(cf->can_id & CAN_ERR_MASK);\n\tmsg->msg.can_msg.length = cf->len;\n\n\tif (cf->can_id & CAN_RTR_FLAG) {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_RTR_FRAME : CPC_CMD_TYPE_RTR_FRAME;\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE;\n\t} else {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_CAN_FRAME : CPC_CMD_TYPE_CAN_FRAME;\n\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tmsg->msg.can_msg.msg[i] = cf->data[i];\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE + cf->len;\n\t}\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (dev->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &dev->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context) {\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\n\t\tnetdev_warn(netdev, \"couldn't find free context\\n\");\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tcontext->dev = dev;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,\n\t\t\t  size, ems_usb_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tif (err == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\tnetif_trans_update(netdev);\n\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&dev->active_tx_urbs) >= MAX_TX_URBS ||\n\t\t    dev->free_slots < CPC_TX_QUEUE_TRIGGER_LOW) {\n\t\t\tnetif_stop_queue(netdev);\n\t\t}\n\t}\n\n\t/*\n\t * Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2022-28390"
    },
    {
      "commit_id": "58a6fe94cb851f71214dbefac3f9bffee437d6fe",
      "filepath": "src/index.c",
      "project": "libgit2",
      "project_repo_path": "symbol_backend_projects/libgit2",
      "is_vulnerable": true,
      "func_name": "read_entry",
      "func_body": "static size_t read_entry(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn 0;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn 0;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn 0;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn 0;\n\t}\n\n\tgit__free(tmp_path);\n\treturn entry_size;\n}",
      "line_statements": [
        [
          2302,
          "static size_t read_entry("
        ],
        [
          2317,
          "\t\treturn 0;"
        ],
        [
          2359,
          "\t\t\t\treturn 0;"
        ],
        [
          2390,
          "\t\treturn 0;"
        ],
        [
          2394,
          "\t\treturn 0;"
        ],
        [
          2398,
          "\treturn entry_size;"
        ]
      ],
      "statements": [
        [
          2302,
          "static size_t read_entry(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)"
        ],
        [
          2317,
          "return 0;"
        ],
        [
          2359,
          "return 0;"
        ],
        [
          2390,
          "return 0;"
        ],
        [
          2394,
          "return 0;"
        ],
        [
          2398,
          "return entry_size;"
        ]
      ],
      "cve": "CVE-2018-8099"
    },
    {
      "commit_id": "b63f90487bdf93a4223ce7853d14717e9d452856",
      "filepath": "drivers/usb/typec/tcpm/tcpm.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "tcpm_port_unregister_pd",
      "func_body": "static void tcpm_port_unregister_pd(struct tcpm_port *port)\n{\n\tint i;\n\n\tport->port_sink_caps = NULL;\n\tport->port_source_caps = NULL;\n\tfor (i = 0; i < port->pd_count; i++) {\n\t\tusb_power_delivery_unregister_capabilities(port->pd_list[i]->sink_cap);\n\t\tusb_power_delivery_unregister_capabilities(port->pd_list[i]->source_cap);\n\t\tdevm_kfree(port->dev, port->pd_list[i]);\n\t\tport->pd_list[i] = NULL;\n\t\tusb_power_delivery_unregister(port->pds[i]);\n\t\tport->pds[i] = NULL;\n\t}\n}\n",
      "line_statements": [],
      "statements": [],
      "cve": "CVE-2024-26932"
    },
    {
      "commit_id": "3864d33943b4a76c6e64616280e98d2410b1190f",
      "filepath": "drivers/usb/misc/rio500.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "probe_rio",
      "func_body": "static int probe_rio(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct rio_usb_data *rio = &rio_instance;\n\tint retval = 0;\n\n\tmutex_lock(&rio500_mutex);\n\tif (rio->present) {\n\t\tdev_info(&intf->dev, \"Second USB Rio at address %d refused\\n\", dev->devnum);\n\t\tretval = -EBUSY;\n\t\tgoto bail_out;\n\t} else {\n\t\tdev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);\n\t}\n\n\tretval = usb_register_dev(intf, &usb_rio_class);\n\tif (retval) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Not able to get a minor for this device.\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\n\trio->rio_dev = dev;\n\n\tif (!(rio->obuf = kmalloc(OBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the output buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\tretval = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\tdev_dbg(&intf->dev, \"obuf address:%p\\n\", rio->obuf);\n\n\tif (!(rio->ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the input buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\tkfree(rio->obuf);\n\t\tretval = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\tdev_dbg(&intf->dev, \"ibuf address:%p\\n\", rio->ibuf);\n\n\tmutex_init(&(rio->lock));\n\n\tusb_set_intfdata (intf, rio);\n\trio->present = 1;\nbail_out:\n\tmutex_unlock(&rio500_mutex);\n\n\treturn retval;\n}\n",
      "line_statements": [
        [
          450,
          "\tint retval = 0;\n"
        ],
        [
          452,
          "\tmutex_lock(&rio500_mutex);\n"
        ],
        [
          453,
          "\tif (rio->present) {\n"
        ],
        [
          454,
          "\t\tdev_info(&intf->dev, \"Second USB Rio at address %d refused\\n\", dev->devnum);\n"
        ],
        [
          455,
          "\t\tretval = -EBUSY;\n"
        ],
        [
          456,
          "\t\tgoto bail_out;\n"
        ],
        [
          457,
          "\t} else {\n"
        ],
        [
          458,
          "\t\tdev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);\n"
        ],
        [
          459,
          "\t}\n"
        ],
        [
          465,
          "\t\tretval = -ENOMEM;\n"
        ],
        [
          466,
          "\t\tgoto bail_out;\n"
        ],
        [
          475,
          "\t\tretval = -ENOMEM;\n"
        ],
        [
          476,
          "\t\tgoto bail_out;\n"
        ],
        [
          485,
          "\t\tretval = -ENOMEM;\n"
        ],
        [
          486,
          "\t\tgoto bail_out;\n"
        ],
        [
          494,
          "bail_out:\n"
        ],
        [
          495,
          "\tmutex_unlock(&rio500_mutex);\n"
        ],
        [
          497,
          "\treturn retval;\n"
        ]
      ],
      "statements": [
        [
          450,
          "int retval = 0;"
        ],
        [
          452,
          "mutex_lock(&rio500_mutex);"
        ],
        [
          453,
          "if (rio->present)"
        ],
        [
          454,
          "dev_info(&intf->dev, \"Second USB Rio at address %d refused\\n\", dev->devnum);"
        ],
        [
          455,
          "retval = -EBUSY;"
        ],
        [
          456,
          "goto bail_out;"
        ],
        [
          457,
          "else"
        ],
        [
          458,
          "dev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);"
        ],
        [
          459,
          "\t}\n"
        ],
        [
          465,
          "retval = -ENOMEM;"
        ],
        [
          466,
          "goto bail_out;"
        ],
        [
          475,
          "retval = -ENOMEM;"
        ],
        [
          476,
          "goto bail_out;"
        ],
        [
          485,
          "retval = -ENOMEM;"
        ],
        [
          486,
          "goto bail_out;"
        ],
        [
          494,
          "bail_out:"
        ],
        [
          495,
          "mutex_unlock(&rio500_mutex);"
        ],
        [
          497,
          "return retval;"
        ]
      ],
      "cve": "CVE-2019-15212"
    }
  ],
  "CWE-264": [
    {
      "commit_id": "ee735086f8670be1591fa9593e80dd60163a7a2f",
      "filepath": "src/basic/fs-util.c",
      "project": "systemd",
      "project_repo_path": "symbol_backend_projects/systemd",
      "is_vulnerable": false,
      "func_name": "touch_file",
      "func_body": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n\n        assert(path);\n\n        if (parents)\n                mkdir_parents(path, 0755);\n\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n        if (fd < 0)\n                return -errno;\n\n        if (mode != MODE_INVALID) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n\n        return 0;\n}",
      "line_statements": [
        [
          314,
          "        if (mode != MODE_INVALID) {"
        ]
      ],
      "statements": [
        [
          314,
          "if (mode != MODE_INVALID)"
        ]
      ],
      "cve": "CVE-2016-10156"
    },
    {
      "commit_id": "1ee0a224bc9aad1de496c795f96bc6ba2c394811",
      "filepath": "drivers/usb/serial/io_ti.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "chase_port",
      "func_body": "static void chase_port(struct edgeport_port *port, unsigned long timeout,\n\t\t\t\t\t\t\t\tint flush)\n{\n\tint baud_rate;\n\tstruct tty_struct *tty = tty_port_tty_get(&port->port->port);\n\tstruct usb_serial *serial = port->port->serial;\n\twait_queue_t wait;\n\tunsigned long flags;\n\n\tif (!tty)\n\t\treturn;\n\n\tif (!timeout)\n\t\ttimeout = (HZ * EDGE_CLOSING_WAIT)/100;\n\n\t/* wait for data to drain from the buffer */\n\tspin_lock_irqsave(&port->ep_lock, flags);\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&tty->write_wait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kfifo_len(&port->write_fifo) == 0\n\t\t|| timeout == 0 || signal_pending(current)\n\t\t|| serial->disconnected)\n\t\t\t/* disconnect */\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tspin_lock_irqsave(&port->ep_lock, flags);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (flush)\n\t\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\ttty_kref_put(tty);\n\n\t/* wait for data to drain from the device */\n\ttimeout += jiffies;\n\twhile ((long)(jiffies - timeout) < 0 && !signal_pending(current)\n\t\t\t\t\t\t&& !serial->disconnected) {\n\t\t/* not disconnected */\n\t\tif (!tx_active(port))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\n\t/* disconnected */\n\tif (serial->disconnected)\n\t\treturn;\n\n\t/* wait one more character time, based on baud rate */\n\t/* (tx_active doesn't seem to wait for the last byte) */\n\tbaud_rate = port->baud_rate;\n\tif (baud_rate == 0)\n\t\tbaud_rate = 50;\n\tmsleep(max(1, DIV_ROUND_UP(10000, baud_rate)));\n}",
      "line_statements": [
        [
          533,
          "\tif (!tty)"
        ],
        [
          534,
          "\t\treturn;"
        ],
        [
          535,
          ""
        ]
      ],
      "statements": [
        [
          533,
          "if (!tty)"
        ],
        [
          534,
          "return;"
        ],
        [
          535,
          "\n"
        ]
      ],
      "cve": "CVE-2013-1774"
    },
    {
      "commit_id": "526b4af47f44148c9d665e57723ed9f86634c6e3",
      "filepath": "drivers/acpi/debugfs.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "acpi_debugfs_init",
      "func_body": "void __init acpi_debugfs_init(void)\n{\n\tacpi_debugfs_dir = debugfs_create_dir(\"acpi\", NULL);\n\n\tacpi_custom_method_init();\n}",
      "line_statements": [
        [
          94,
          ""
        ],
        [
          95,
          "\tacpi_custom_method_init();"
        ]
      ],
      "statements": [
        [
          94,
          "\n"
        ],
        [
          95,
          "acpi_custom_method_init();"
        ]
      ],
      "cve": "CVE-2011-1021"
    },
    {
      "commit_id": "ee735086f8670be1591fa9593e80dd60163a7a2f",
      "filepath": "src/basic/fs-util.c",
      "project": "systemd",
      "project_repo_path": "symbol_backend_projects/systemd",
      "is_vulnerable": true,
      "func_name": "touch_file",
      "func_body": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n\n        assert(path);\n\n        if (parents)\n                mkdir_parents(path, 0755);\n\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n        if (fd < 0)\n                return -errno;\n\n        if (mode > 0) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n\n        return 0;\n}",
      "line_statements": [
        [
          314,
          "        if (mode > 0) {"
        ]
      ],
      "statements": [
        [
          314,
          "if (mode > 0)"
        ]
      ],
      "cve": "CVE-2016-10156"
    },
    {
      "commit_id": "8141c7f3e7aee618312fa1c15109e1219de784a7",
      "filepath": "kernel/exit.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "do_exit",
      "func_body": "NORET_TYPE void do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\n\tWARN_ON(atomic_read(&tsk->fs_excl));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\ttracehook_report_exit(&code);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tprintk(KERN_ALERT\n\t\t\t\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tif (tsk->io_context)\n\t\t\texit_io_context();\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * tsk->flags are checked in the futex code to protect against\n\t * an exiting task cleaning up the robust pi futexes.\n\t */\n\tsmp_mb();\n\tspin_unlock_wait(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic()))\n\t\tprintk(KERN_INFO \"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\t\tpreempt_count());\n\n\tacct_update_integrals(tsk);\n\tif (tsk->mm) {\n\t\tupdate_hiwater_rss(tsk->mm);\n\t\tupdate_hiwater_vm(tsk->mm);\n\t}\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n\t}\n\tacct_collect(code, group_dead);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list))\n\t\texit_robust_list(tsk);\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list))\n\t\tcompat_exit_robust_list(tsk);\n#endif\n#endif\n\tif (group_dead)\n\t\ttty_audit_exit();\n\tif (unlikely(tsk->audit_context))\n\t\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm(tsk);\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tcheck_stack_usage();\n\texit_thread();\n\tcgroup_exit(tsk, 1);\n\texit_keys(tsk);\n\n\tif (group_dead && tsk->signal->leader)\n\t\tdisassociate_ctty(1);\n\n\tmodule_put(task_thread_info(tsk)->exec_domain->module);\n\tif (tsk->binfmt)\n\t\tmodule_put(tsk->binfmt->module);\n\n\tproc_exit_connector(tsk);\n\texit_notify(tsk, group_dead);\n#ifdef CONFIG_NUMA\n\tmpol_put(tsk->mempolicy);\n\ttsk->mempolicy = NULL;\n#endif\n#ifdef CONFIG_FUTEX\n\t/*\n\t * This must happen late, after the PID is not\n\t * hashed anymore:\n\t */\n\tif (unlikely(!list_empty(&tsk->pi_state_list)))\n\t\texit_pi_state_list(tsk);\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held(tsk);\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context();\n\n\tif (tsk->splice_pipe)\n\t\t__free_pipe_info(tsk->splice_pipe);\n\n\tpreempt_disable();\n\t/* causes final put_task_struct in finish_task_switch(). */\n\ttsk->state = TASK_DEAD;\n\n\tschedule();\n\tBUG();\n\t/* Avoid \"noreturn function does return\".  */\n\tfor (;;)\n\t\tcpu_relax();\t/* For when BUG is null */\n}",
      "line_statements": [
        [
          1062,
          "#ifdef CONFIG_FUTEX"
        ],
        [
          1063,
          "\tif (unlikely(tsk->robust_list))"
        ],
        [
          1064,
          "\t\texit_robust_list(tsk);"
        ],
        [
          1065,
          "#ifdef CONFIG_COMPAT"
        ],
        [
          1066,
          "\tif (unlikely(tsk->compat_robust_list))"
        ],
        [
          1067,
          "\t\tcompat_exit_robust_list(tsk);"
        ],
        [
          1068,
          "#endif"
        ],
        [
          1069,
          "#endif"
        ]
      ],
      "statements": [
        [
          1062,
          "#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list))\n\t\texit_robust_list(tsk);\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list))\n\t\tcompat_exit_robust_list(tsk);\n#endif\n#endif"
        ],
        [
          1063,
          "if (unlikely(tsk->robust_list))"
        ],
        [
          1064,
          "exit_robust_list(tsk);"
        ],
        [
          1065,
          "#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list))\n\t\tcompat_exit_robust_list(tsk);\n#endif"
        ],
        [
          1066,
          "if (unlikely(tsk->compat_robust_list))"
        ],
        [
          1067,
          "compat_exit_robust_list(tsk);"
        ]
      ],
      "cve": "CVE-2012-0028"
    }
  ],
  "CWE-401": [
    {
      "commit_id": "0e62395da2bd5166d7c9e14cbc7503b256a34cb0",
      "filepath": "drivers/scsi/bfa/bfad_attr.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "bfad_im_get_stats",
      "func_body": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\n\twait_for_completion(&fcomp.comp);\n\n\t/* Fill the fc_host_statistics structure */\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\n\tkfree(fcstats);\n\treturn hstats;\n}",
      "line_statements": [
        [
          278,
          "\tif (rc != BFA_STATUS_OK)"
        ]
      ],
      "statements": [
        [
          278,
          "if (rc != BFA_STATUS_OK)"
        ]
      ],
      "cve": "CVE-2019-19066"
    },
    {
      "commit_id": "c03b04dcdba1da39903e23cc4d072abf8f68f2dd",
      "filepath": "crypto/crypto_user_stat.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "crypto_reportstat",
      "func_body": "int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_reportstat_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}",
      "line_statements": [
        [
          331,
          "\tif (err)"
        ]
      ],
      "statements": [
        [
          331,
          "if (err)"
        ]
      ],
      "cve": "CVE-2019-19050"
    },
    {
      "commit_id": "bbe692e349e2a1edf3fe0a29a0e05899c9c94d51",
      "filepath": "drivers/rpmsg/rpmsg_char.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "rpmsg_eptdev_write_iter",
      "func_body": "static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from)) {\n\t\tret = -EFAULT;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\n\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\n\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}",
      "line_statements": [
        [
          230,
          "\tif (!copy_from_iter_full(kbuf, len, from)) {"
        ],
        [
          231,
          "\t\tret = -EFAULT;"
        ],
        [
          232,
          "\t\tgoto free_kbuf;"
        ],
        [
          233,
          "\t}"
        ]
      ],
      "statements": [
        [
          230,
          "if (!copy_from_iter_full(kbuf, len, from))"
        ],
        [
          231,
          "ret = -EFAULT;"
        ],
        [
          232,
          "goto free_kbuf;"
        ],
        [
          233,
          "\t}\n"
        ]
      ],
      "cve": "CVE-2019-19053"
    },
    {
      "commit_id": "7d11230060fa9c8f67e53c85224daf6648805c7b",
      "filepath": "coders/ps.c",
      "project": "ImageMagick6",
      "project_repo_path": "symbol_backend_projects/ImageMagick6",
      "is_vulnerable": false,
      "func_name": "ReadPSImage",
      "func_body": "static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \"BoundingBox:\"\n#define BeginDocument  \"BeginDocument:\"\n#define BeginXMPPacket  \"<?xpacket begin=\"\n#define EndXMPPacket  \"<?xpacket end=\"\n#define ICCProfile \"BeginICCProfile:\"\n#define CMYKCustomColor  \"CMYKCustomColor:\"\n#define CMYKProcessColor  \"CMYKProcessColor:\"\n#define DocumentMedia  \"DocumentMedia:\"\n#define DocumentCustomColors  \"DocumentCustomColors:\"\n#define DocumentProcessColors  \"DocumentProcessColors:\"\n#define EndDocument  \"EndDocument:\"\n#define HiResBoundingBox  \"HiResBoundingBox:\"\n#define ImageData  \"ImageData:\"\n#define PageBoundingBox  \"PageBoundingBox:\"\n#define LanguageLevel  \"LanguageLevel:\"\n#define PageMedia  \"PageMedia:\"\n#define Pages  \"Pages:\"\n#define PhotoshopProfile  \"BeginPhotoshop:\"\n#define PostscriptLevel  \"!PS-\"\n#define RenderPostscriptText  \"  Rendering Postscript...  \"\n#define SpotColor  \"+ \"\n\n  char\n    command[MaxTextExtent],\n    *density,\n    filename[MaxTextExtent],\n    geometry[MaxTextExtent],\n    input_filename[MaxTextExtent],\n    message[MaxTextExtent],\n    *options,\n    postscript_filename[MaxTextExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *postscript_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    fitPage,\n    skip,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution;\n\n  RectangleInfo\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  short int\n    hex_digits[256];\n\n  size_t\n    length,\n    priority;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned long\n    columns,\n    extent,\n    language_level,\n    pages,\n    rows,\n    scene,\n    spotcolor;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize hex values.\n  */\n  (void) memset(hex_digits,0,sizeof(hex_digits));\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->x_resolution == 0.0) || (image->y_resolution == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  resolution.x=image->x_resolution;\n  resolution.y=image->y_resolution;\n  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);\n  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);\n  /*\n    Determine page geometry from the Postscript bounding box.\n  */\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(command,0,sizeof(command));\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  (void) memset(&hires_bounds,0,sizeof(hires_bounds));\n  priority=0;\n  columns=0;\n  rows=0;\n  extent=0;\n  spotcolor=0;\n  language_level=1;\n  skip=MagickFalse;\n  pages=(~0UL);\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MaxTextExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\"ps:Level\",command+4);\n        if (GlobExpression(command,\"*EPSF-*\",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \" %lu\",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \" %lu\",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \" %lu %lu\",&columns,&rows);\n    /*\n      Is this a CMYK document?\n    */\n    length=strlen(DocumentProcessColors);\n    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)\n      {\n        if ((GlobExpression(command,\"*Cyan*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Magenta*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Yellow*\",MagickTrue) != MagickFalse))\n          cmyk=MagickTrue;\n      }\n    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    length=strlen(DocumentCustomColors);\n    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||\n        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||\n        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))\n      {\n        char\n          property[MaxTextExtent],\n          *value;\n\n        register char\n          *p;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MaxTextExtent,\"ps:SpotColor-%.20g\",\n          (double) (spotcolor++));\n        for (p=command; *p != '\\0'; p++)\n          if (isspace((int) (unsigned char) *p) != 0)\n            break;\n        value=ConstantString(p);\n        (void) SubstituteString(&value,\"(\",\"\");\n        (void) SubstituteString(&value,\")\",\"\");\n        (void) StripString(value);\n        if (*value != '\\0')\n          (void) SetImageProperty(image,property,value);\n        value=DestroyString(value);\n        continue;\n      }\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note region defined by bounding box.\n    */\n    count=0;\n    i=0;\n    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,BoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=2;\n      }\n    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,DocumentMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,HiResBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=3;\n      }\n    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if ((count != 4) || (i < (ssize_t) priority))\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      if (i == (ssize_t) priority)\n        continue;\n    hires_bounds=bounds;\n    priority=(size_t) i;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) &&\n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set Postscript render geometry.\n      */\n      (void) FormatLocaleString(geometry,MaxTextExtent,\"%gx%g%+.15g%+.15g\",\n        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\"ps:HiResBoundingBox\",geometry);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"eps:fit-page\");\n  if (option != (char *) NULL)\n    {\n      char\n        *geometry;\n\n      MagickStatusType\n        flags;\n\n      geometry=GetPageGeometry(option);\n      flags=ParseMetaGeometry(geometry,&page.x,&page.y,&page.width,\n        &page.height);\n      if (flags == NoValue)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"InvalidGeometry\",\"`%s'\",option);\n          geometry=DestroyString(geometry);\n          image=DestroyImage(image);\n          return((Image *) NULL);\n        }\n      page.width=(size_t) ceil((double) (page.width*image->x_resolution/delta.x)\n        -0.5);\n      page.height=(size_t) ceil((double) (page.height*image->y_resolution/\n        delta.y) -0.5);\n      geometry=DestroyString(geometry);\n      fitPage=MagickTrue;\n    }\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(&image->exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(command,\"/setpagedevice {pop} bind 1 index where {\"\n    \"dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\\n\"\n    \"<</UseCIEColor true>>setpagedevice\\n\",MaxTextExtent);\n  count=write(file,command,(unsigned int) strlen(command));\n  if (image_info->page == (char *) NULL)\n    {\n      char\n        translate_geometry[MaxTextExtent];\n\n      (void) FormatLocaleString(translate_geometry,MaxTextExtent,\n        \"%g %g translate\\n\",-hires_bounds.x1,-hires_bounds.y1);\n      count=write(file,translate_geometry,(unsigned int)\n        strlen(translate_geometry));\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n    if (cmyk != MagickFalse)\n      delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n    else\n      delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MaxTextExtent,\"%gx%g\",resolution.x,\n    resolution.y);\n  (void) FormatLocaleString(options,MaxTextExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MaxTextExtent];\n\n      (void) FormatLocaleString(pages,MaxTextExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g \",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MaxTextExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  if (*image_info->magick == 'E')\n    {\n      option=GetImageOption(image_info,\"eps:use-cropbox\");\n      if ((option == (const char *) NULL) ||\n          (IsStringTrue(option) != MagickFalse))\n        (void) ConcatenateMagickString(options,\"-dEPSCrop \",MaxTextExtent);\n      if (fitPage != MagickFalse)\n        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",MaxTextExtent);\n    }\n  (void) CopyMagickString(filename,read_info->filename,MaxTextExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MaxTextExtent);\n  (void) FormatLocaleString(command,MaxTextExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);\n  (void) InterpretImageFilename(image_info,image,filename,1,\n    read_info->filename);\n  if ((status == MagickFalse) ||\n      (IsPostscriptRendered(read_info->filename) == MagickFalse))\n    {\n      (void) ConcatenateMagickString(command,\" -c showpage\",MaxTextExtent);\n      status=InvokePostscriptDelegate(read_info->verbose,command,message,\n        exception);\n    }\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  postscript_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&postscript_image,next);\n    }\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (postscript_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n          \"PostscriptDelegateFailed\",\"`%s'\",message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(postscript_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          postscript_image=DestroyImageList(postscript_image);\n          postscript_image=cmyk_image;\n        }\n    }\n  (void) SeekBlob(image,0,SEEK_SET);\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MaxTextExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\"ps:Level\",command+4);\n        if (GlobExpression(command,\"*EPSF-*\",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \" %lu\",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \" %lu\",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \" %lu %lu\",&columns,&rows);\n    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)\n      {\n        unsigned char\n          *datum;\n\n        /*\n          Read ICC profile.\n        */\n        profile=AcquireStringInfo(MaxTextExtent);\n        datum=GetStringInfoDatum(profile);\n        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)\n        {\n          if (i >= (ssize_t) GetStringInfoLength(profile))\n            {\n              SetStringInfoLength(profile,(size_t) i << 1);\n              datum=GetStringInfoDatum(profile);\n            }\n          datum[i]=(unsigned char) c;\n        }\n        SetStringInfoLength(profile,(size_t) i+1);\n        (void) SetImageProfile(image,\"icc\",profile);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)\n      {\n        unsigned char\n          *p;\n\n        /*\n          Read Photoshop profile.\n        */\n        count=(ssize_t) sscanf(command,PhotoshopProfile \" %lu\",&extent);\n        if (count != 1)\n          continue;\n        length=extent;\n        if ((MagickSizeType) length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        profile=BlobToStringInfo((const void *) NULL,length);\n        if (profile != (StringInfo *) NULL)\n          {\n            p=GetStringInfoDatum(profile);\n            for (i=0; i < (ssize_t) length; i++)\n              *p++=(unsigned char) ProfileInteger(image,hex_digits);\n            (void) SetImageProfile(image,\"8bim\",profile);\n            profile=DestroyStringInfo(profile);\n          }\n        continue;\n      }\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        register size_t\n          i;\n\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,(size_t) (i+1));\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MaxTextExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,(size_t) i);\n        (void) SetImageProfile(image,\"xmp\",profile);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      register ssize_t\n        i;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&postscript_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(postscript_image->filename,filename,MaxTextExtent);\n    (void) CopyMagickString(postscript_image->magick,image->magick,\n      MaxTextExtent);\n    if (columns != 0)\n      postscript_image->magick_columns=columns;\n    if (rows != 0)\n      postscript_image->magick_rows=rows;\n    postscript_image->page=page;\n    (void) CloneImageProfiles(postscript_image,image);\n    (void) CloneImageProperties(postscript_image,image);\n    next=SyncNextImageInList(postscript_image);\n    if (next != (Image *) NULL)\n      postscript_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImageList(image);\n  scene=0;\n  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(postscript_image));\n}",
      "line_statements": [
        [
          752,
          "          geometry=DestroyString(geometry);"
        ]
      ],
      "statements": [
        [
          752,
          "geometry=DestroyString(geometry);"
        ]
      ],
      "cve": "CVE-2019-13137"
    },
    {
      "commit_id": "4ade98128cbc41d5115b97a41ca2e59529c8dd5f",
      "filepath": "src/laser/lsr_dec.c",
      "project": "gpac",
      "project_repo_path": "symbol_backend_projects/gpac",
      "is_vulnerable": false,
      "func_name": "lsr_read_rare_full",
      "func_body": "static void lsr_read_rare_full(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tGF_FieldInfo info;\n\tu32 i, nb_rare, field_rare;\n\ts32 field_tag;\n\n\tGF_LSR_READ_INT(lsr, nb_rare, 1, \"has_rare\");\n\tif (!nb_rare) return;\n\tGF_LSR_READ_INT(lsr, nb_rare, 6, \"nbOfAttributes\");\n\n\tfor (i=0; i<nb_rare; i++) {\n\t\tGF_LSR_READ_INT(lsr, field_rare, 6, \"attributeRARE\");\n\n\t\t/*lsr extend*/\n\t\tif (field_rare==49) {\n\t\t\tu32 extID, len, j;\n\t\t\twhile (1) {\n\t\t\t\tGF_LSR_READ_INT(lsr, extID, lsr->info->cfg.extensionIDBits, \"extensionID\");\n\t\t\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\t\tif (extID==2) {\n\t\t\t\t\tGF_LSR_READ_INT(lsr, len, 2, \"nbOfAttributes\");\n\t\t\t\t\tfor (j=0; j<len; j++) {\n\t\t\t\t\t\tGF_LSR_READ_INT(lsr, extID, 3, \"attributeRARE\");\n\t\t\t\t\t\tswitch (extID) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncMaster, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"syncMaster\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_focusHighlight, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FocusHighlight *)info.far_ptr, 2, \"focusHighlight\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_initialVisibility, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_InitialVisibility *)info.far_ptr, 2, \"initialVisibility\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_fullscreen, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"fullscreen\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_requiredFonts, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List **)info.far_ptr, \"requiredFonts\", GF_FALSE, GF_TRUE);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_read_int(lsr->bs, len);\n\t\t\t\t}\n\t\t\t\tGF_LSR_READ_INT(lsr, extID, 1, \"hasNextExtension\");\n\t\t\t\tif (!extID) break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfield_tag = gf_lsr_rare_type_to_attribute(field_rare);\n\t\tif (field_tag==-1) {\n\t\t\treturn;\n\t\t}\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, field_tag, GF_TRUE, GF_FALSE, &info);\n\t\tif (!info.far_ptr) lsr->last_error = GF_NOT_SUPPORTED;\n\t\tif (lsr->last_error) return;\n\n\t\tswitch (field_tag) {\n\t\tcase TAG_SVG_ATT__class:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"class\");\n\t\t\tbreak;\n\t\t/*properties*/\n\t\tcase TAG_SVG_ATT_audio_level:\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"audio-level\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_color:\n\t\t\tlsr_read_paint(lsr, (SVG_Paint *)info.far_ptr, \"color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_color_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, \"color-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_display:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Display*)info.far_ptr, 5, \"display\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_display_align:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_DisplayAlign*)info.far_ptr, 3, \"display-align\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_fill_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"fill-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_fill_rule:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FillRule*)info.far_ptr, 2, \"fill-rule\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_image_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, \"image-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_line_increment:\n\t\t\tlsr_read_line_increment_type(lsr, info.far_ptr, \"line-increment\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_pointer_events:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_PointerEvents*)info.far_ptr, 4, \"pointer-events\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_shape_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, \"shape-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_solid_color:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"solid-color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_solid_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"solid-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stop_color:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"stop-color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stop_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"stop-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_dasharray:\n\t\t{\n\t\t\tu32 j, flag;\n\t\t\tSVG_StrokeDashArray *da = (SVG_StrokeDashArray *)info.far_ptr;\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"dashArray\");\n\t\t\tif (flag) {\n\t\t\t\tda->type=SVG_STROKEDASHARRAY_INHERIT;\n\t\t\t} else {\n\t\t\t\tda->type=SVG_STROKEDASHARRAY_ARRAY;\n\t\t\t\tda->array.count = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\t\tda->array.vals = (Fixed*)gf_realloc(da->array.vals, sizeof(Fixed)*da->array.count);\n\t\t\t\tda->array.units = (u8*)gf_realloc(da->array.units, sizeof(u8)*da->array.count);\n\t\t\t\tif (!da->array.vals || !da->array.units) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<da->array.count; j++) {\n\t\t\t\t\tda->array.vals[j] = lsr_read_fixed_16_8(lsr, \"dash\");\n\t\t\t\t\tda->array.units[j] = 0;\n\t\t\t\t\tif (lsr->last_error) return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_dashoffset:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"dashOffset\");\n\t\t\tbreak;\n\n\t\tcase TAG_SVG_ATT_stroke_linecap:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_StrokeLineCap*)info.far_ptr, 2, \"stroke-linecap\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_linejoin:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_StrokeLineJoin*)info.far_ptr, 2, \"stroke-linejoin\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_miterlimit:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"miterLimit\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"stroke-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_width:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"strokeWidth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_anchor:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_TextAnchor*)info.far_ptr, 2, \"text-achor\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, \"text-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_viewport_fill:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"viewport-fill\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_viewport_fill_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"viewport-fill-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_vector_effect:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_VectorEffect*)info.far_ptr, 4, \"vector-effect\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_visibility:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Visibility*)info.far_ptr, 2, \"visibility\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredExtensions:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"requiredExtensions\", GF_TRUE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredFormats:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"requiredFormats\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredFeatures:\n\t\t{\n\t\t\tu32 j, fcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\t\tfor (j=0; j<fcount; j++) {\n\t\t\t\tu32 fval;\n\t\t\t\tGF_LSR_READ_INT(lsr, fval, 6, \"feature\");\n\t\t\t\tif (lsr->last_error) return;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_systemLanguage:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"systemLanguage\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_base:\n\t\t\tlsr_read_byte_align_string(lsr, &((XMLRI*)info.far_ptr)->string, \"xml:base\");\n\t\t\t((XMLRI*)info.far_ptr)->type = XMLRI_STRING;\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_lang:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"xml:lang\");\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_space:\n\t\t\tGF_LSR_READ_INT(lsr, *(XML_Space*)info.far_ptr, 1, \"xml:space\");\n\t\t\tbreak;\n\t\t/*focusable*/\n\t\tcase TAG_SVG_ATT_nav_next:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNext\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorthEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorthWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_prev:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusPrev\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouthEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouthWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_focusable:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Focusable*)info.far_ptr, 2, \"focusable\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_transform:\n\t\t\tlsr_read_matrix(lsr, info.far_ptr);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_decoration:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"textDecoration\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\n\t\tcase TAG_SVG_ATT_font_variant:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontVariant*)info.far_ptr, 2, \"font-variant\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_family:\n\t\t{\n\t\t\tu32 flag;\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"isInherit\");\n\t\t\tif (flag) {\n\t\t\t\t((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_INHERIT;\n\t\t\t} else {\n\t\t\t\tchar *ft;\n\t\t\t\t((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_VALUE;\n\t\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->fontIndexBits, \"fontIndex\");\n\t\t\t\tft = (char*)gf_list_get(lsr->font_table, flag);\n\t\t\t\tif (ft) ((SVG_FontFamily*)info.far_ptr)->value = gf_strdup(ft);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_size:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"fontSize\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_style:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontStyle*)info.far_ptr, 3, \"fontStyle\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_weight:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontWeight*)info.far_ptr, 4, \"fontWeight\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_title:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"xlink:title\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_type:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 3, \"xlink:type\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_role:\n\t\t\tlsr_read_any_uri(lsr, info.far_ptr, \"xlink:role\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_arcrole:\n\t\t\tlsr_read_any_uri(lsr, info.far_ptr, \"xlink:arcrole\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_actuate:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 2, \"xlink:actuate\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_show:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 3, \"xlink:show\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_end:\n\t\t\tlsr_read_smil_times(lsr, NULL, 0, info.far_ptr, \"end\", 0);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_max:\n\t\t\tlsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, \"min\", 0);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_min:\n\t\t\tlsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, \"min\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (lsr->last_error) return;\n\t}\n}",
      "line_statements": [
        [
          1542,
          "\t\t\t\tda->array.vals = (Fixed*)gf_realloc(da->array.vals, sizeof(Fixed)*da->array.count);"
        ],
        [
          1543,
          "\t\t\t\tda->array.units = (u8*)gf_realloc(da->array.units, sizeof(u8)*da->array.count);"
        ]
      ],
      "statements": [
        [
          1542,
          "da->array.vals = (Fixed*)gf_realloc(da->array.vals, sizeof(Fixed)*da->array.count);"
        ],
        [
          1543,
          "da->array.units = (u8*)gf_realloc(da->array.units, sizeof(u8)*da->array.count);"
        ]
      ],
      "cve": "CVE-2023-23145"
    }
  ],
  "CWE-369": [
    {
      "commit_id": "cfa91be9863a91d5105a3b4941096044ab32036b",
      "filepath": "tensorflow/core/kernels/quantized_conv_ops.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tensorflow::Im2ColConvFunctor::operator ( )",
      "func_body": "  void operator()(OpKernelContext* context, const T1* input_data,\n                  int input_batches, int input_height, int input_width,\n                  int input_depth, int input_offset, const T2* filter_data,\n                  int filter_height, int filter_width, int filter_count,\n                  int filter_offset, int stride, Padding padding,\n                  T3* output_data, int output_height, int output_width,\n                  int output_shift, int output_offset, int output_mult) {\n    if (input_offset < 0) {\n      // Only log the first few occurrences of this warning.\n      static int warning_count = 0;\n      if (warning_count < 10) {\n        ++warning_count;\n        LOG(WARNING)\n            << \"For kernel '\" << context->op_kernel().name() << \"' from input '\"\n            << context->op_kernel().requested_input(0)\n            << \"': Zero is not representable in the quantized range used by the\"\n            << \" input. This means QuantizedConv2d has to fall back to a slow\"\n            << \" implementation, since the border of zero values can't be\"\n            << \" represented easily. You should try to construct graphs that\"\n            << \" avoid this situation.\";\n      }\n      ReferenceConvFunctor<T1, T2, T3> conv_functor;\n      conv_functor(context, input_data, input_batches, input_height,\n                   input_width, input_depth, input_offset, filter_data,\n                   filter_height, filter_width, filter_count, filter_offset,\n                   stride, padding, output_data, output_height, output_width,\n                   output_shift, output_offset, output_mult);\n      return;\n    }\n\n    OP_REQUIRES(\n        context, output_width > 0,\n        errors::InvalidArgument(\"output_width must be strictly positive\"));\n    OP_REQUIRES(\n        context, output_height > 0,\n        errors::InvalidArgument(\"output_height must be strictly positive\"));\n    int filter_left_offset;\n    int filter_top_offset;\n    if (padding == VALID) {\n      filter_left_offset =\n          ((output_width - 1) * stride + filter_width - input_width + 1) / 2;\n      filter_top_offset =\n          ((output_height - 1) * stride + filter_height - input_height + 1) / 2;\n    } else {\n      filter_left_offset =\n          ((output_width - 1) * stride + filter_width - input_width) / 2;\n      filter_top_offset =\n          ((output_height - 1) * stride + filter_height - input_height) / 2;\n    }\n\n    // The im2col buffer has # of patches rows, and # of filters cols.\n    // It's laid out like this, in row major order in memory:\n    //        < filter value count >\n    //   ^   +---------------------+\n    // patch |                     |\n    // count |                     |\n    //   v   +---------------------+\n    // Each patch row contains a filter_width x filter_height patch of the\n    // input, with the depth channel as the most contiguous in memory, followed\n    // by the width, then the height. This is the standard memory order in the\n    // image world if it helps to visualize it.\n    const int filter_value_count = filter_width * filter_height * input_depth;\n    OP_REQUIRES(context, filter_value_count > 0,\n                errors::InvalidArgument(\n                    \"filter patch must contain at least one element\"));\n    const int64 patches_per_chunk =\n        kMaxChunkSize / (filter_value_count * sizeof(T1));\n    const int64 chunk_value_count =\n        (kMaxChunkSize + (sizeof(T1) - 1)) / sizeof(T1);\n    // TODO(petewarden) - Memory allocation can be very slow on Android. Can we\n    // optimize this by keeping the scratch buffer around?\n    // Because memory allocation is very expensive on mobile platforms, try to\n    // allocate a persistent buffer that will be kept around between calls. We\n    // use TensorFlow's resource management to ensure that the memory will be\n    // released when the session is over.\n    Im2ColBufferResource<T1, chunk_value_count>* im2col_buffer_resource;\n    std::function<Status(Im2ColBufferResource<T1, chunk_value_count>**)>\n        creator = [](Im2ColBufferResource<T1, chunk_value_count>** resource) {\n#ifdef _MSC_VER\n          // MSVC complains about the capture of chunk_value_count which oddly\n          // works fine in conv_ops_using_gemm.cc for example.\n          // Define chunk_value_count inside the lambda for now.\n          const int64 chunk_value_count =\n              (kMaxChunkSize + (sizeof(T1) - 1)) / sizeof(T1);\n#endif\n          *resource = new Im2ColBufferResource<T1, chunk_value_count>();\n          return Status::OK();\n        };\n    OP_REQUIRES_OK(context, context->resource_manager()->LookupOrCreate(\n                                \"Conv2d\", \"im2col_buffer\",\n                                &im2col_buffer_resource, creator));\n    // This means that multiple ops can't be run simultaneously on different\n    // threads, because we have a single shared resource. The platforms this is\n    // aimed at have intra-op parallelism as their focus though, so it shouldn't\n    // be an issue.\n    mutex_lock lock_buffer(im2col_buffer_resource->mu);\n    core::ScopedUnref unref_buffer(im2col_buffer_resource);\n    T1* im2col_buffer = im2col_buffer_resource->data;\n\n    const int64 patch_count = (input_batches * output_height * output_width);\n    const int64 chunk_count =\n        (patch_count + (patches_per_chunk - 1)) / patches_per_chunk;\n\n    for (int64 chunk_index = 0; chunk_index < chunk_count; ++chunk_index) {\n      const int64 patch_index_start = chunk_index * patches_per_chunk;\n      const int64 patch_index_end =\n          std::min(patch_index_start + patches_per_chunk, patch_count);\n      for (int64 patch_index = patch_index_start; patch_index < patch_index_end;\n           ++patch_index) {\n        const int64 batch = patch_index / (output_height * output_width);\n        const int64 out_y = (patch_index / output_width) % output_height;\n        const int64 out_x = patch_index % output_width;\n        const T1* input_batch_start =\n            input_data + (batch * input_height * input_width * input_depth);\n        const int in_y_origin = (out_y * stride) - filter_top_offset;\n        const int in_x_origin = (out_x * stride) - filter_left_offset;\n        const int patch_index_within_chunk = patch_index % patches_per_chunk;\n        T1* im2col_patch_start =\n            im2col_buffer + (patch_index_within_chunk * filter_value_count);\n        for (int filter_y = 0; filter_y < filter_height; ++filter_y) {\n          const int in_y = in_y_origin + filter_y;\n          T1* im2col_row_start =\n              im2col_patch_start + (filter_y * filter_width * input_depth);\n          // If we're off the top or the bottom of the input, fill the\n          // whole row with zeroes.\n          if ((in_y < 0) || (in_y >= input_height)) {\n            // On Android, memset and memcpy are significantly faster than the\n            // more modern std::set and std::copy equivalents.\n            memset(im2col_row_start, input_offset,\n                   (filter_width * input_depth));\n          } else {\n            // What we're doing here is trying to copy and fill the im2col\n            // buffer as efficiently as possible, using functions to set or\n            // duplicate values en masse. We know we don't have to worry about\n            // vertical edges because we dealt with that case above, so we\n            // just need to handle filters that overlap the left or right\n            // edges. Here's what that looks like:\n            //\n            // < left_zero_count > < center_copy_count > < right_zero_count >\n            // +------------------+---------------------+--------------------+\n            // |     (filter)     |       (image)       |      (filter)      |\n            // +------------------+---------------------+--------------------+\n            // in_x_origin        0                 input_width       in_x_end\n            //\n            // In reality it's unlikely that a filter patch will be wider\n            // than an input, but this shows all the edge cases.\n            // We use memset() to set the left and right sections to zeroes\n            // and memcpy() to copy over the input data for the center. These\n            // are preferred to std::fill and std::copy because they're much\n            // faster on Android.\n            const int in_x_end = in_x_origin + filter_width;\n            const int left_zero_count = std::max(0, 0 - in_x_origin);\n            const int right_zero_count = std::max(0, in_x_end - input_width);\n            const int center_copy_count =\n                filter_width - (left_zero_count + right_zero_count);\n            if (left_zero_count > 0) {\n              T1* im2col_left_start = im2col_row_start;\n              memset(im2col_left_start, input_offset,\n                     (left_zero_count * input_depth));\n            }\n            if (center_copy_count > 0) {\n              const T1* input_row_start =\n                  input_batch_start + (in_y * input_width * input_depth) +\n                  (std::max(0, in_x_origin) * input_depth);\n              T1* im2col_center_start =\n                  im2col_row_start + (left_zero_count * input_depth);\n              memcpy(im2col_center_start, input_row_start,\n                     (center_copy_count * input_depth));\n            }\n            if (right_zero_count > 0) {\n              T1* im2col_right_start =\n                  im2col_row_start +\n                  ((left_zero_count + center_copy_count) * input_depth);\n              memset(im2col_right_start, input_offset,\n                     (right_zero_count * input_depth));\n            }\n          }\n        }\n      }\n      // Now we've assembled a set of image patches into a matrix, apply a\n      // GEMM matrix multiply of the patches as rows, times the filter\n      // weights in columns, to get partial results in the output matrix.\n      const int how_many_patches = patch_index_end - patch_index_start;\n      const bool transpose_a = false;\n      const bool transpose_b = false;\n      const bool transpose_c = false;\n      const int m = how_many_patches;\n      const int n = filter_count;\n      const int k = filter_value_count;\n      const int lda = filter_value_count;\n      const int ldb = filter_count;\n      const int ldc = filter_count;\n      T3* chunk_output_data = output_data + (patch_index_start * filter_count);\n\n      if (meta::IsSupportedAndEnabled() && std::is_same<T1, quint8>() &&\n          std::is_same<T2, quint8>() && std::is_same<T3, qint32>() &&\n          (output_offset == 0) && (output_mult == 1) && (output_shift == 0) &&\n          (transpose_c == false) && (k <= 2048)) {\n        meta::QuantizedGemm(context, transpose_a, transpose_b, im2col_buffer,\n                            filter_data, chunk_output_data, m, n, k,\n                            -input_offset, -filter_offset, lda, ldb, ldc);\n      } else if (std::is_same<T1, quint8>() && std::is_same<T2, quint8>() &&\n                 std::is_same<T3, qint32>() && (output_offset == 0) &&\n                 (output_mult == 1) && (output_shift == 0)) {\n        // The gemmlowp optimized library only works for a particular set of\n        // data types, so check if we meet those requirements and fall back to a\n        // slower reference implementation if not.\n        const uint8* im2col_data_as_uint8 = &(im2col_buffer->value);\n        const uint8* filter_data_as_uint8 = &(filter_data->value);\n        int32* output_data_as_int32 = &(chunk_output_data->value);\n        // All of the transpose_* variables are currently compile-time consts,\n        // so we could just hard-code these values too, but that would break if\n        // anybody changed those values in the future (e.g. to match the ability\n        // of MatMul to specify them as attributes). We're using a verbose\n        // approach of deriving the order values from the transpose variables to\n        // be able to catch any changes like that.\n        static const gemmlowp::MapOrder ResultOrder =\n            !transpose_c ? gemmlowp::MapOrder::RowMajor\n                         : gemmlowp::MapOrder::ColMajor;\n        static const gemmlowp::MapOrder LhsOrder =\n            !transpose_a ? gemmlowp::MapOrder::RowMajor\n                         : gemmlowp::MapOrder::ColMajor;\n        static const gemmlowp::MapOrder RhsOrder =\n            !transpose_b ? gemmlowp::MapOrder::RowMajor\n                         : gemmlowp::MapOrder::ColMajor;\n        gemmlowp::MatrixMap<const std::uint8_t, LhsOrder> lhs(\n            im2col_data_as_uint8, m, k, lda);\n        gemmlowp::MatrixMap<const std::uint8_t, RhsOrder> rhs(\n            filter_data_as_uint8, k, n, ldb);\n        gemmlowp::MatrixMap<std::int32_t, ResultOrder> result(\n            output_data_as_int32, m, n, ldc);\n        const std::tuple<> empty_pipeline = {};\n\n        auto& worker_threads =\n            *(context->device()->tensorflow_cpu_worker_threads());\n        TensorflowGemmContext context(worker_threads.num_threads,\n                                      worker_threads.workers);\n        gemmlowp::GemmWithOutputPipeline<std::uint8_t, std::int32_t,\n                                         gemmlowp::DefaultL8R8BitDepthParams>(\n            &context, lhs, rhs, &result, -input_offset, -filter_offset,\n            empty_pipeline);\n        // Since gemmlowp uses assembly to write to the output, msan won't\n        // detect the output buffer as written to, so we mark it manually.\n        TF_ANNOTATE_MEMORY_IS_INITIALIZED(output_data_as_int32,\n                                          m * n * sizeof(int32));\n      } else {\n        ReferenceGemm<T1, T2, T3>(\n            transpose_a, transpose_b, transpose_c, m, n, k, im2col_buffer,\n            input_offset, lda, filter_data, filter_offset, ldb,\n            chunk_output_data, output_shift, output_offset, output_mult, ldc);\n      }\n    }\n  }",
      "line_statements": [
        [
          232,
          "    OP_REQUIRES("
        ],
        [
          233,
          "        context, output_width > 0,"
        ],
        [
          234,
          "        errors::InvalidArgument(\"output_width must be strictly positive\"));"
        ],
        [
          235,
          "    OP_REQUIRES("
        ],
        [
          236,
          "        context, output_height > 0,"
        ],
        [
          237,
          "        errors::InvalidArgument(\"output_height must be strictly positive\"));"
        ],
        [
          264,
          "    OP_REQUIRES(context, filter_value_count > 0,"
        ],
        [
          265,
          "                errors::InvalidArgument("
        ],
        [
          266,
          "                    \"filter patch must contain at least one element\"));"
        ]
      ],
      "statements": [
        [
          232,
          "OP_REQUIRES(\n        context, output_width > 0,\n        errors::InvalidArgument(\"output_width must be strictly positive\"));"
        ],
        [
          235,
          "OP_REQUIRES(\n        context, output_height > 0,\n        errors::InvalidArgument(\"output_height must be strictly positive\"));"
        ],
        [
          264,
          "OP_REQUIRES(context, filter_value_count > 0,\n                errors::InvalidArgument(\n                    \"filter patch must contain at least one element\"));"
        ],
        [
          265,
          "errors::InvalidArgument(\n                    \"filter patch must contain at least one element\")"
        ]
      ],
      "cve": "CVE-2021-29527"
    },
    {
      "commit_id": "728dc6a600cf4cbdac846964c85cc04339db8ac1",
      "filepath": "coders/tiff.c",
      "project": "ImageMagick",
      "project_repo_path": "symbol_backend_projects/ImageMagick",
      "is_vulnerable": true,
      "func_name": "WriteTIFFImage",
      "func_body": "static MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#if !defined(TIFFDefaultStripSize)\n#define TIFFDefaultStripSize(tiff,request)  (8192UL/TIFFScanlineSize(tiff))\n#endif\n\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric;\n\n  uint32\n    rows_per_strip;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  endian_type=UndefinedEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;;\n    }\n  switch (endian_type)\n  {\n    case LSBEndian: mode=\"wl\"; break;\n    case MSBEndian: mode=\"wb\"; break;\n    default: mode=\"w\"; break;\n  }\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    switch (endian_type)\n    {\n      case LSBEndian: mode=\"wl8\"; break;\n      case MSBEndian: mode=\"wb8\"; break;\n      default: mode=\"w8\"; break;\n    }\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type,exception);\n    compression=UndefinedCompression;\n    if (image->compression != JPEGCompression)\n      compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) SetImageType(image,BilevelType,exception);\n        (void) SetImageDepth(image,1,exception);\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        (void) SetImageDepth(image,8,exception);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n        compression=NoCompression;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n              MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          compression=NoCompression;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,exception);\n          }\n        else\n          if (image->colorspace == YCbCrColorspace)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass,exception);\n              (void) SetImageDepth(image,8,exception);\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorAlphaType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) &&\n                    (image->alpha_trait == UndefinedPixelTrait))\n                  SetImageMonochrome(image,exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) &&\n        (photometric != PHOTOMETRIC_MINISWHITE))\n      {\n        compress_tag=COMPRESSION_NONE;\n        endian=FILLORDER_MSB2LSB;\n      }\n    else\n      if ((compress_tag == COMPRESSION_CCITTFAX4) &&\n         (photometric != PHOTOMETRIC_MINISWHITE))\n       {\n         compress_tag=COMPRESSION_NONE;\n         endian=FILLORDER_MSB2LSB;\n       }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n     rows_per_strip=TIFFDefaultStripSize(tiff,0);\n    option=GetImageOption(image_info,\"tiff:rows-per-strip\");\n    if (option != (const char *) NULL)\n      rows_per_strip=(size_t) strtol(option,(char **) NULL,10);\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n        const char\n          *sampling_factor;\n\n        GeometryInfo\n          geometry_info;\n\n        MagickStatusType\n          flags;\n\n        rows_per_strip+=(16-(rows_per_strip % 16));\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            sampling_factor=(const char *) NULL;\n            value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n            if (value != (char *) NULL)\n              {\n                sampling_factor=value;\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Input sampling-factors=%s\",sampling_factor);\n              }\n            if (image_info->sampling_factor != (char *) NULL)\n              sampling_factor=image_info->sampling_factor;\n            if (sampling_factor != (const char *) NULL)\n              {\n                flags=ParseGeometry(sampling_factor,&geometry_info);\n                if ((flags & SigmaValue) == 0)\n                  geometry_info.sigma=geometry_info.rho;\n                if (image->colorspace == YCbCrColorspace)\n                  (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                    geometry_info.rho,(uint16) geometry_info.sigma);\n              }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        rows_per_strip=(uint32) image->rows;\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        rows_per_strip=(uint32) image->rows;\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n      {\n        rows_per_strip=(uint32) image->rows;\n        break;\n      }\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        break;\n      }\n      default:\n        break;\n    }\n    if (rows_per_strip < 1)\n      rows_per_strip=1;\n    if ((image->rows/rows_per_strip) >= (1UL << 15))\n      rows_per_strip=(uint32) (image->rows >> 15);\n    (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n    if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->resolution.x);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->resolution.y);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"TIFF: negative image positions unsupported\",\"%s\",image->filename);\n        if ((image->page.x > 0) && (image->resolution.x > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->resolution.x);\n          }\n        if ((image->page.y > 0) && (image->resolution.y > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->resolution.y);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (image_info->adjoin != MagickFalse) && (GetImageListLength(image) > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            GetImageListLength(image));\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    (void) TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,image_info,image,exception);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image,exception);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    quantum_info->endian=LSBEndian;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              (void) length;\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                RedQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GreenQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                BlueQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->alpha_trait != UndefinedPixelTrait)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const Quantum\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                length=ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) ResetMagickMemory(red,0,65536*sizeof(*red));\n        (void) ResetMagickMemory(green,0,65536*sizeof(*green));\n        (void) ResetMagickMemory(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,exception);\n    DestroyTIFFInfo(&tiff_info);\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\nRestoreMSCWarning\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\n    (void) TIFFWriteDirectory(tiff);\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(MagickTrue);\n}",
      "line_statements": [
        [
          3482,
          "     rows_per_strip=TIFFDefaultStripSize(tiff,0);"
        ]
      ],
      "statements": [
        [
          3482,
          "rows_per_strip=TIFFDefaultStripSize(tiff,0);"
        ]
      ],
      "cve": "CVE-2016-10053"
    },
    {
      "commit_id": "b522d2d857d2f75b659936b59b0da9df1682c256",
      "filepath": "magick/feature.c",
      "project": "ImageMagick6",
      "project_repo_path": "symbol_backend_projects/ImageMagick6",
      "is_vulnerable": true,
      "func_name": "MeanShiftImage",
      "func_body": "MagickExport Image *MeanShiftImage(const Image *image,const size_t width,\n  const size_t height,const double color_distance,ExceptionInfo *exception)\n{\n#define MaxMeanShiftIterations  100\n#define MeanShiftImageTag  \"MeanShift/Image\"\n\n  CacheView\n    *image_view,\n    *mean_view,\n    *pixel_view;\n\n  Image\n    *mean_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  mean_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (mean_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(mean_image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&mean_image->exception);\n      mean_image=DestroyImage(mean_image);\n      return((Image *) NULL);\n    }\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  pixel_view=AcquireVirtualCacheView(image,exception);\n  mean_view=AcquireAuthenticCacheView(mean_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status,progress) \\\n    magick_number_threads(mean_image,mean_image,mean_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) mean_image->rows; y++)\n  {\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(mean_view,0,y,mean_image->columns,1,\n      exception);\n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewVirtualIndexQueue(image_view);\n    for (x=0; x < (ssize_t) mean_image->columns; x++)\n    {\n      MagickPixelPacket\n        mean_pixel,\n        previous_pixel;\n\n      PointInfo\n        mean_location,\n        previous_location;\n\n      register ssize_t\n        i;\n\n      GetMagickPixelPacket(image,&mean_pixel);\n      SetMagickPixelPacket(image,p,indexes+x,&mean_pixel);\n      mean_location.x=(double) x;\n      mean_location.y=(double) y;\n      for (i=0; i < MaxMeanShiftIterations; i++)\n      {\n        double\n          distance,\n          gamma;\n\n        MagickPixelPacket\n          sum_pixel;\n\n        PointInfo\n          sum_location;\n\n        ssize_t\n          count,\n          v;\n\n        sum_location.x=0.0;\n        sum_location.y=0.0;\n        GetMagickPixelPacket(image,&sum_pixel);\n        previous_location=mean_location;\n        previous_pixel=mean_pixel;\n        count=0;\n        for (v=(-((ssize_t) height/2)); v <= (((ssize_t) height/2)); v++)\n        {\n          ssize_t\n            u;\n\n          for (u=(-((ssize_t) width/2)); u <= (((ssize_t) width/2)); u++)\n          {\n            if ((v*v+u*u) <= (ssize_t) ((width/2)*(height/2)))\n              {\n                PixelPacket\n                  pixel;\n\n                status=GetOneCacheViewVirtualPixel(pixel_view,(ssize_t)\n                  MagickRound(mean_location.x+u),(ssize_t) MagickRound(\n                  mean_location.y+v),&pixel,exception);\n                distance=(mean_pixel.red-pixel.red)*(mean_pixel.red-pixel.red)+\n                  (mean_pixel.green-pixel.green)*(mean_pixel.green-pixel.green)+\n                  (mean_pixel.blue-pixel.blue)*(mean_pixel.blue-pixel.blue);\n                if (distance <= (color_distance*color_distance))\n                  {\n                    sum_location.x+=mean_location.x+u;\n                    sum_location.y+=mean_location.y+v;\n                    sum_pixel.red+=pixel.red;\n                    sum_pixel.green+=pixel.green;\n                    sum_pixel.blue+=pixel.blue;\n                    sum_pixel.opacity+=pixel.opacity;\n                    count++;\n                  }\n              }\n          }\n        }\n        gamma=1.0/count;\n        mean_location.x=gamma*sum_location.x;\n        mean_location.y=gamma*sum_location.y;\n        mean_pixel.red=gamma*sum_pixel.red;\n        mean_pixel.green=gamma*sum_pixel.green;\n        mean_pixel.blue=gamma*sum_pixel.blue;\n        mean_pixel.opacity=gamma*sum_pixel.opacity;\n        distance=(mean_location.x-previous_location.x)*\n          (mean_location.x-previous_location.x)+\n          (mean_location.y-previous_location.y)*\n          (mean_location.y-previous_location.y)+\n          255.0*QuantumScale*(mean_pixel.red-previous_pixel.red)*\n          255.0*QuantumScale*(mean_pixel.red-previous_pixel.red)+\n          255.0*QuantumScale*(mean_pixel.green-previous_pixel.green)*\n          255.0*QuantumScale*(mean_pixel.green-previous_pixel.green)+\n          255.0*QuantumScale*(mean_pixel.blue-previous_pixel.blue)*\n          255.0*QuantumScale*(mean_pixel.blue-previous_pixel.blue);\n        if (distance <= 3.0)\n          break;\n      }\n      q->red=ClampToQuantum(mean_pixel.red);\n      q->green=ClampToQuantum(mean_pixel.green);\n      q->blue=ClampToQuantum(mean_pixel.blue);\n      q->opacity=ClampToQuantum(mean_pixel.opacity);\n      p++;\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(mean_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,MeanShiftImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  mean_view=DestroyCacheView(mean_view);\n  pixel_view=DestroyCacheView(pixel_view);\n  image_view=DestroyCacheView(image_view);\n  return(mean_image);\n}",
      "line_statements": [
        [
          2316,
          "        gamma=1.0/count;"
        ]
      ],
      "statements": [
        [
          2316,
          "gamma=1.0/count;"
        ]
      ],
      "cve": "CVE-2019-14981"
    },
    {
      "commit_id": "4aacb30888638da75023e6601149415b39763d76",
      "filepath": "tensorflow/core/kernels/resource_variable_ops.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tensorflow::ValidateInput",
      "func_body": "bool ValidateInput(const Tensor& updates) {\n  const auto updates_flat = updates.flat<T>();\n  const T zero(0);\n  for (int i = 0; i < updates.NumElements(); i++) {\n    if (updates_flat(i) == zero) return false;\n  }\n  return true;\n}",
      "line_statements": [
        [
          889,
          "bool ValidateInput(const Tensor& updates) {"
        ],
        [
          890,
          "  const auto updates_flat = updates.flat<T>();"
        ],
        [
          891,
          "  const T zero(0);"
        ],
        [
          892,
          "  for (int i = 0; i < updates.NumElements(); i++) {"
        ],
        [
          893,
          "    if (updates_flat(i) == zero) return false;"
        ],
        [
          894,
          "  }"
        ],
        [
          895,
          "  return true;"
        ],
        [
          896,
          "}"
        ]
      ],
      "statements": [
        [
          889,
          "bool ValidateInput(const Tensor& updates) {"
        ],
        [
          890,
          "const auto updates_flat = updates.flat<T>();"
        ],
        [
          891,
          "const T zero(0);"
        ],
        [
          892,
          "for (int i = 0; i < updates.NumElements(); i++) {"
        ],
        [
          893,
          "if (updates_flat(i) == zero)"
        ],
        [
          894,
          "  }\n"
        ],
        [
          895,
          "return true;"
        ],
        [
          896,
          "}"
        ]
      ],
      "cve": "CVE-2021-37642"
    }
  ],
  "CWE-189": [
    {
      "commit_id": "f8bd2258e2d520dff28c855658bd24bdafb5102d",
      "filepath": "arch/mips/kernel/binfmt_elfn32.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "jiffies_to_compat_timeval",
      "func_body": "jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong rem;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}",
      "line_statements": [
        [
          105,
          "\tlong rem;"
        ],
        [
          106,
          "\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);"
        ]
      ],
      "statements": [
        [
          105,
          "long rem;"
        ],
        [
          106,
          "value->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);"
        ]
      ],
      "cve": "CVE-2011-3209"
    },
    {
      "commit_id": "350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7",
      "filepath": "virt/kvm/iommu.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "kvm_iommu_map_pages",
      "func_body": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tgoto unmap_pages;\n\t\t}\n\n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\n\t}\n\n\treturn 0;\n\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn);\n\treturn r;\n}",
      "line_statements": [
        [
          137,
          "\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn);"
        ]
      ],
      "statements": [
        [
          137,
          "kvm_iommu_put_pages(kvm, slot->base_gfn, gfn);"
        ]
      ],
      "cve": "CVE-2014-3601"
    },
    {
      "commit_id": "8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664",
      "filepath": "net/ipv4/tcp_illinois.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "tcp_illinois_info",
      "func_body": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\t\tu64 t = ca->sum_rtt;\n\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}",
      "line_statements": [
        [
          316,
          "\t\tu64 t = ca->sum_rtt;"
        ],
        [
          318,
          "\t\tdo_div(t, ca->cnt_rtt);"
        ],
        [
          319,
          "\t\tinfo.tcpv_rtt = t;"
        ]
      ],
      "statements": [
        [
          316,
          "u64 t = ca->sum_rtt;"
        ],
        [
          318,
          "do_div(t, ca->cnt_rtt);"
        ],
        [
          319,
          "info.tcpv_rtt = t;"
        ]
      ],
      "cve": "CVE-2012-4565"
    },
    {
      "commit_id": "b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908",
      "filepath": "src/laser/lsr_dec.c",
      "project": "gpac",
      "project_repo_path": "symbol_backend_projects/gpac",
      "is_vulnerable": true,
      "func_name": "lsr_read_extend_class",
      "func_body": "static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n//\twhile (len) gf_bs_read_int(lsr->bs, 1);\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}",
      "line_statements": [
        [
          303,
          "\tu32 len;"
        ],
        [
          307,
          "\tgf_bs_read_long_int(lsr->bs, len);"
        ]
      ],
      "statements": [
        [
          303,
          "u32 len;"
        ],
        [
          307,
          "gf_bs_read_long_int(lsr->bs, len);"
        ]
      ],
      "cve": "CVE-2022-4202"
    },
    {
      "commit_id": "0641e56be1af003aa02c7c6b0184466540637233",
      "filepath": "src/cdf.c",
      "project": "file",
      "project_repo_path": "symbol_backend_projects/file",
      "is_vulnerable": false,
      "func_name": "cdf_read_property_info",
      "func_body": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t tail = (i << 1) + 1;\n\t\tif (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),\n\t\t    __LINE__) == -1)\n\t\t\tgoto out;\n\t\tsize_t ofs = CDF_GETUINT32(p, tail);\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p + ofs\n\t\t    - 2 * sizeof(uint32_t));\n\t\tif (q < p) {\n\t\t\tDPRINTF((\"Wrapped around %p < %p\\n\", q, p));\n\t\t\tgoto out;\n\t\t}\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %\" SIZE_T_FORMAT\n\t\t\t\t    \"u, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}",
      "line_statements": [
        [
          838,
          "\t\tif (q < p) {"
        ],
        [
          839,
          "\t\t\tDPRINTF((\"Wrapped around %p < %p\\n\", q, p));"
        ],
        [
          840,
          "\t\t\tgoto out;"
        ],
        [
          841,
          "\t\t}"
        ]
      ],
      "statements": [
        [
          838,
          "if (q < p)"
        ],
        [
          839,
          "DPRINTF((\"Wrapped around %p < %p\\n\", q, p));"
        ],
        [
          840,
          "goto out;"
        ],
        [
          841,
          "\t\t}\n"
        ]
      ],
      "cve": "CVE-2014-3587"
    }
  ],
  "CWE-617": [
    {
      "commit_id": "552bfced6ce4809db5f3ca305f60ff80dd40c5a3",
      "filepath": "tensorflow/core/kernels/random_op.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tensorflow::RandomGammaOp::Compute",
      "func_body": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_t = ctx->input(0);\n    const Tensor& alpha_t = ctx->input(1);\n\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(shape_t.shape()) &&\n                    (shape_t.dtype() == DataType::DT_INT32 ||\n                     shape_t.dtype() == DataType::DT_INT64),\n                errors::InvalidArgument(\n                    \"shape must be a vector of {int32,int64}, got shape: \",\n                    shape_t.DebugString()));\n    TensorShape samples_shape;\n    if (shape_t.dtype() == DataType::DT_INT32) {\n      auto vec = shape_t.flat<int32>();\n      OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(vec.data(), vec.size(),\n                                                      &samples_shape));\n    } else if (shape_t.dtype() == DataType::DT_INT64) {\n      auto vec = shape_t.flat<int64_t>();\n      OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(vec.data(), vec.size(),\n                                                      &samples_shape));\n    }\n    const int64_t samples_per_alpha = samples_shape.num_elements();\n\n    OP_REQUIRES_OK(ctx, samples_shape.AppendShapeWithStatus(alpha_t.shape()));\n    // Allocate output samples.\n    Tensor* samples_t = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, samples_shape, &samples_t));\n\n    if (samples_shape.num_elements() == 0) return;\n\n    using random::PhiloxRandom;\n\n    typedef random::NormalDistribution<PhiloxRandom, double> Normal;\n    typedef random::UniformDistribution<PhiloxRandom, double> Uniform;\n#define UNIFORM(X)                                    \\\n  if (uniform_remaining == 0) {                       \\\n    uniform_remaining = Uniform::kResultElementCount; \\\n    uniform_result = uniform(&gen);                   \\\n  }                                                   \\\n  uniform_remaining--;                                \\\n  double X = uniform_result[uniform_remaining]\n\n    // Each attempt is 95+% successful, and requires 1-2 normal + 1 uniform\n    static constexpr int kReservedSamplesPerOutput = 256;\n\n    const auto alpha_flat = alpha_t.flat<T>().data();\n    const int64_t num_alphas = alpha_t.NumElements();\n    OP_REQUIRES(ctx, num_alphas > 0,\n                errors::InvalidArgument(\n                    \"Input alpha should have non-zero element count, got: \",\n                    num_alphas));\n    auto samples_flat = samples_t->flat<T>().data();\n    PhiloxRandom rng = generator_.ReserveRandomOutputs(\n        samples_per_alpha * num_alphas, kReservedSamplesPerOutput);\n\n    // We partition work first across alphas then across samples-per-alpha to\n    // avoid a couple flops which can be done on a per-alpha basis.\n\n    auto DoWork = [samples_per_alpha, num_alphas, &rng, samples_flat,\n                   alpha_flat](int64_t start_output, int64_t limit_output) {\n      using Eigen::numext::exp;\n      using Eigen::numext::log;\n      using Eigen::numext::log1p;\n      using Eigen::numext::pow;\n\n      // Capturing \"rng\" by-value would only make a copy for the _shared_\n      // lambda.  Since we want to let each worker have its own copy, we pass\n      // \"rng\" by reference and explicitly do a copy assignment.\n\n      Normal normal;\n      Uniform uniform;\n      typename Normal::ResultType norm_result;\n      typename Uniform::ResultType uniform_result;\n      for (int64_t output_idx = start_output; output_idx < limit_output;\n           /* output_idx incremented within inner loop below */) {\n        int64_t alpha_idx = output_idx / samples_per_alpha;\n\n        // Instead of +alpha_idx for each sample, we offset the pointer once.\n        T* const samples_alpha_offset = samples_flat + alpha_idx;\n\n        // Several calculations can be done on a per-alpha basis.\n        const double alpha = static_cast<double>(alpha_flat[alpha_idx]);\n\n        DISABLE_FLOAT_EQUALITY_WARNING\n        if (alpha == static_cast<double>(1.0)) {\n          ENABLE_FLOAT_EQUALITY_WARNING\n          // Sample from an exponential distribution.\n          for (int64_t sample_idx = output_idx % samples_per_alpha;\n               sample_idx < samples_per_alpha && output_idx < limit_output;\n               sample_idx++, output_idx++) {\n            // As we want data stable regardless of sharding\n            // (including eventually on GPU), we skip on a per-sample basis.\n            PhiloxRandom gen = rng;\n            gen.Skip(kReservedSamplesPerOutput * output_idx);\n            int16_t uniform_remaining = 0;\n            UNIFORM(u);\n            const double res = -log1p(-u);\n            samples_alpha_offset[sample_idx * num_alphas] = static_cast<T>(res);\n          }       // for (sample_idx)\n        } else {  // if alpha != 1.0\n          // Transformation-rejection from pairs of uniform and normal random\n          // variables. http://dl.acm.org/citation.cfm?id=358414\n          //\n          // The algorithm has an acceptance rate of ~95% for small alpha (~1),\n          // and higher accept rates for higher alpha, so runtime is\n          // O(NumAlphas * NumSamples * k) with k ~ 1 / 0.95.\n          //\n          // For alpha<1, we add one to d=alpha-1/3, and multiply the final\n          // result by uniform()^(1/alpha)\n          const bool alpha_less_than_one = alpha < 1;\n          const double d = alpha + (alpha_less_than_one ? 2.0 / 3 : -1.0 / 3);\n          const double c = 1.0 / 3 / sqrt(d);\n\n          // Compute the rest of the samples for the current alpha value.\n          for (int64_t sample_idx = output_idx % samples_per_alpha;\n               sample_idx < samples_per_alpha && output_idx < limit_output;\n               sample_idx++, output_idx++) {\n            // Since each sample may use a variable number of normal/uniform\n            // samples, and we want data stable regardless of sharding\n            // (including eventually on GPU), we skip on a per-sample basis.\n            PhiloxRandom gen = rng;\n            gen.Skip(kReservedSamplesPerOutput * output_idx);\n            int16_t norm_remaining = 0;\n            int16_t uniform_remaining = 0;\n\n            // Keep trying until we don't reject a sample. In practice, we will\n            // only reject ~5% at worst, for low alpha near 1.\n            while (true) {\n              if (norm_remaining == 0) {\n                norm_remaining = Normal::kResultElementCount;\n                norm_result = normal(&gen);\n              }\n              norm_remaining--;\n              const double x = norm_result[norm_remaining];\n              double v = 1 + c * x;\n              if (v <= 0) {\n                continue;\n              }\n              v = v * v * v;\n              UNIFORM(u);\n              // The first option in the if is a \"squeeze\" short-circuit to\n              // dodge the two logs. Magic constant sourced from the paper\n              // linked above. Upward of .91 of the area covered by the log\n              // inequality is covered by the squeeze as well (larger coverage\n              // for smaller values of alpha).\n              if ((u < 1 - 0.0331 * (x * x) * (x * x)) ||\n                  (log(u) < 0.5 * x * x + d * (1 - v + log(v)))) {\n                double res = d * v;\n                if (alpha_less_than_one) {\n                  UNIFORM(b);\n                  res *= pow(b, 1 / alpha);\n                }\n                samples_alpha_offset[sample_idx * num_alphas] =\n                    static_cast<T>(res);\n                break;\n              }\n            }  // while: true\n          }    // for: sample_idx\n        }      // if (alpha == 1.0)\n      }        // for: output_idx\n    };         // DoWork\n#undef UNIFORM\n    // Two calls to log only occur for ~10% of samples reaching the log line.\n    //   2 x 100 (64-bit cycles per log) x 0.10 = ~20.\n    // Other ops: sqrt, +, *, /, %... something like 15 of these, at 3-6 cycles\n    // each = ~60.\n    // All of this /0.95 due to the rejection possibility = ~85.\n    static const int kElementCost = 85 + 2 * Normal::kElementCost +\n                                    Uniform::kElementCost +\n                                    3 * PhiloxRandom::kElementCost;\n    auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());\n    Shard(worker_threads.num_threads, worker_threads.workers,\n          num_alphas * samples_per_alpha, kElementCost, DoWork);\n  }",
      "line_statements": [
        [
          169,
          "    OP_REQUIRES_OK(ctx, samples_shape.AppendShapeWithStatus(alpha_t.shape()));"
        ]
      ],
      "statements": [
        [
          169,
          "OP_REQUIRES_OK(ctx, samples_shape.AppendShapeWithStatus(alpha_t.shape()));"
        ]
      ],
      "cve": "CVE-2022-36003"
    },
    {
      "commit_id": "ad069af92392efee1418c48ff561fd3070a03d7b",
      "filepath": "tensorflow/core/ir/importexport/functiondef_import.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": true,
      "func_name": "mlir::tfg::ImportNodes",
      "func_body": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  // Process every node and create a matching MLIR operation\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    // Fetch the inputs, creating placeholder if an input hasn't been visited.\n    for (const std::string& input : node.input())\n      state.operands.push_back(\n          value_manager.GetValueOrCreatePlaceholder(input));\n    // Retrieve the entry in the nodes_map for this node and infer the result\n    // count from what was inferred during the first traversal above.\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    // Handle attributes.\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder, tfgDialect));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(\n          tf_type::FullTypeAttr type,\n          ConvertAttribute(node.experimental_type(), builder, tfgDialect));\n      state.addAttribute(fulltype_attr, type);\n    }\n\n    Operation* op = builder.create(state);\n\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  // We don't expect any placeholder left at this point, fail if any.\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return Status::OK();\n}",
      "line_statements": [
        [
          169,
          "    for (const std::string& input : node.input())"
        ]
      ],
      "statements": [
        [
          169,
          "for (const std::string& input : node.input())"
        ]
      ],
      "cve": "CVE-2022-36012"
    },
    {
      "commit_id": "14fea662350e7c26eb5fe1be2ac31704e5682ee6",
      "filepath": "tensorflow/core/framework/resource_handle.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tensorflow::ResourceHandle::FromProto",
      "func_body": "Status ResourceHandle::FromProto(const ResourceHandleProto& proto) {\n  set_device(proto.device());\n  set_container(proto.container());\n  set_name(proto.name());\n  set_hash_code(proto.hash_code());\n  set_maybe_type_name(proto.maybe_type_name());\n  std::vector<DtypeAndPartialTensorShape> dtypes_and_shapes;\n  for (const auto& dtype_and_shape : proto.dtypes_and_shapes()) {\n    DataType dtype = dtype_and_shape.dtype();\n    PartialTensorShape shape;\n    Status s = PartialTensorShape::BuildPartialTensorShape(\n        dtype_and_shape.shape(), &shape);\n    if (!s.ok()) {\n      return s;\n    }\n    dtypes_and_shapes.push_back(DtypeAndPartialTensorShape{dtype, shape});\n  }\n  dtypes_and_shapes_ = std::move(dtypes_and_shapes);\n  return Status::OK();\n}",
      "line_statements": [
        [
          60,
          "Status ResourceHandle::FromProto(const ResourceHandleProto& proto) {"
        ],
        [
          69,
          "    PartialTensorShape shape;"
        ],
        [
          70,
          "    Status s = PartialTensorShape::BuildPartialTensorShape("
        ],
        [
          71,
          "        dtype_and_shape.shape(), &shape);"
        ],
        [
          72,
          "    if (!s.ok()) {"
        ],
        [
          73,
          "      return s;"
        ],
        [
          74,
          "    }"
        ],
        [
          78,
          "  return Status::OK();"
        ]
      ],
      "statements": [
        [
          60,
          "Status ResourceHandle::FromProto(const ResourceHandleProto& proto) {"
        ],
        [
          69,
          "PartialTensorShape shape;"
        ],
        [
          70,
          "Status s = PartialTensorShape::BuildPartialTensorShape(\n        dtype_and_shape.shape(), &shape);"
        ],
        [
          72,
          "if (!s.ok())"
        ],
        [
          73,
          "return s;"
        ],
        [
          74,
          "    }\n"
        ],
        [
          78,
          "return Status::OK();"
        ]
      ],
      "cve": "CVE-2022-23564"
    },
    {
      "commit_id": "3d89911481ba6ebe8c88c1c0b595412121e6c645",
      "filepath": "tensorflow/core/framework/function.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tensorflow::FunctionInstantiationHelper::BuildInputArgIndex",
      "func_body": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    if (dtypes.size() < size_t{1}) {\n      return errors::Internal(\"Expected a list of at least one dtype\");\n    }\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    // Creates dtypes.size() nodes in the graph.\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }",
      "line_statements": [
        [
          184,
          "    if (dtypes.size() < size_t{1}) {"
        ],
        [
          185,
          "      return errors::Internal(\"Expected a list of at least one dtype\");"
        ],
        [
          186,
          "    }"
        ]
      ],
      "statements": [
        [
          184,
          "if (dtypes.size() < size_t{1})"
        ],
        [
          185,
          "return errors::Internal(\"Expected a list of at least one dtype\");"
        ],
        [
          186,
          "    }\n"
        ]
      ],
      "cve": "CVE-2022-23586"
    },
    {
      "commit_id": "785d67a78a1d533759fcd2f5e8d6ef778de849e0",
      "filepath": "tensorflow/core/kernels/fake_quant_ops.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tensorflow::FakeQuantWithMinMaxVarsPerChannelOp::Compute",
      "func_body": "  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(3, context->num_inputs());\n    const Tensor& input = context->input(0);\n    const int depth = input.dim_size(input.dims() - 1);  // last dimension size.\n    const Tensor& min = context->input(1);\n    const Tensor& max = context->input(2);\n\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(min.shape()),\n        InvalidArgument(\"`min` must be rank 1 but is rank \", min.dims()));\n    OP_REQUIRES(context, min.dim_size(0) == depth,\n                InvalidArgument(\"min has incorrect size, expected \", depth,\n                                \" was \", min.dim_size(0)));\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(max.shape()),\n        InvalidArgument(\"`max` must be rank 1 but is rank \", max.dims()));\n    OP_REQUIRES(context, max.dim_size(0) == depth,\n                InvalidArgument(\"max has incorrect size, expected \", depth,\n                                \" was \", max.dim_size(0)));\n\n    Tensor* output;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n\n    FakeQuantWithMinMaxVarsPerChannelFunctor<Device> functor;\n    functor(context->eigen_device<Device>(), input.flat_inner_dims<float, 2>(),\n            min.vec<float>(), max.vec<float>(), quant_min_, quant_max_,\n            output->flat_inner_dims<float, 2>());\n  }",
      "line_statements": [
        [
          353,
          "    const Tensor& max = context->input(2);"
        ],
        [
          354,
          ""
        ],
        [
          355,
          "    OP_REQUIRES("
        ],
        [
          356,
          "        context, TensorShapeUtils::IsVector(min.shape()),"
        ],
        [
          357,
          "        InvalidArgument(\"`min` must be rank 1 but is rank \", min.dims()));"
        ],
        [
          361,
          "    OP_REQUIRES("
        ],
        [
          362,
          "        context, TensorShapeUtils::IsVector(max.shape()),"
        ],
        [
          363,
          "        InvalidArgument(\"`max` must be rank 1 but is rank \", max.dims()));"
        ]
      ],
      "statements": [
        [
          353,
          "const Tensor& max = context->input(2);"
        ],
        [
          354,
          "\n"
        ],
        [
          355,
          "OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(min.shape()),\n        InvalidArgument(\"`min` must be rank 1 but is rank \", min.dims()));"
        ],
        [
          361,
          "OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(max.shape()),\n        InvalidArgument(\"`max` must be rank 1 but is rank \", max.dims()));"
        ]
      ],
      "cve": "CVE-2022-35971"
    }
  ],
  "CWE-122": [
    {
      "commit_id": "3bd7fa12e146c6051490d048a4acbfba974eeb04",
      "filepath": "src/message.c",
      "project": "vim",
      "project_repo_path": "symbol_backend_projects/vim",
      "is_vulnerable": true,
      "func_name": "trunc_string",
      "func_body": "trunc_string(\n    char_u\t*s,\n    char_u\t*buf,\n    int\t\troom_in,\n    int\t\tbuflen)\n{\n    size_t\troom = room_in - 3; // \"...\" takes 3 chars\n    size_t\thalf;\n    size_t\tlen = 0;\n    int\t\te;\n    int\t\ti;\n    int\t\tn;\n\n    if (*s == NUL)\n    {\n\tif (buflen > 0)\n\t    *buf = NUL;\n\treturn;\n    }\n\n    if (room_in < 3)\n\troom = 0;\n    half = room / 2;\n\n    // First part: Start of the string.\n    for (e = 0; len < half && e < buflen; ++e)\n    {\n\tif (s[e] == NUL)\n\t{\n\t    // text fits without truncating!\n\t    buf[e] = NUL;\n\t    return;\n\t}\n\tn = ptr2cells(s + e);\n\tif (len + n > half)\n\t    break;\n\tlen += n;\n\tbuf[e] = s[e];\n\tif (has_mbyte)\n\t    for (n = (*mb_ptr2len)(s + e); --n > 0; )\n\t    {\n\t\tif (++e == buflen)\n\t\t    break;\n\t\tbuf[e] = s[e];\n\t    }\n    }\n\n    // Last part: End of the string.\n    i = e;\n    if (enc_dbcs != 0)\n    {\n\t// For DBCS going backwards in a string is slow, but\n\t// computing the cell width isn't too slow: go forward\n\t// until the rest fits.\n\tn = vim_strsize(s + i);\n\twhile (len + n > room)\n\t{\n\t    n -= ptr2cells(s + i);\n\t    i += (*mb_ptr2len)(s + i);\n\t}\n    }\n    else if (enc_utf8)\n    {\n\t// For UTF-8 we can go backwards easily.\n\thalf = i = (int)STRLEN(s);\n\tfor (;;)\n\t{\n\t    do\n\t\thalf = half - utf_head_off(s, s + half - 1) - 1;\n\t    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));\n\t    n = ptr2cells(s + half);\n\t    if (len + n > room || half == 0)\n\t\tbreak;\n\t    len += n;\n\t    i = (int)half;\n\t}\n    }\n    else\n    {\n\tfor (i = (int)STRLEN(s);\n\t\t   i - 1 >= 0 && len + (n = ptr2cells(s + i - 1)) <= room; --i)\n\t    len += n;\n    }\n\n\n    if (i <= e + 3)\n    {\n\t// text fits without truncating\n\tif (s != buf)\n\t{\n\t    len = STRLEN(s);\n\t    if (len >= (size_t)buflen)\n\t\tlen = buflen - 1;\n\t    len = len - e + 1;\n\t    if (len < 1)\n\t\tbuf[e - 1] = NUL;\n\t    else\n\t\tmch_memmove(buf + e, s + e, len);\n\t}\n    }\n    else if (e + 3 < buflen)\n    {\n\t// set the middle and copy the last part\n\tmch_memmove(buf + e, \"...\", (size_t)3);\n\tlen = STRLEN(s + i) + 1;\n\tif (len >= (size_t)buflen - e - 3)\n\t    len = buflen - e - 3 - 1;\n\tmch_memmove(buf + e + 3, s + i, len);\n\tbuf[e + 3 + len - 1] = NUL;\n    }\n    else\n    {\n\t// can't fit in the \"...\", just truncate it\n\tbuf[e - 1] = NUL;\n    }\n}",
      "line_statements": [
        [
          356,
          "\tbuf[e - 1] = NUL;"
        ]
      ],
      "statements": [
        [
          356,
          "buf[e - 1] = NUL;"
        ]
      ],
      "cve": "CVE-2023-5344"
    },
    {
      "commit_id": "ea7395f39f601a7750d48d606e9d10ea0b7beefe",
      "filepath": "src/isomedia/box_code_base.c",
      "project": "gpac",
      "project_repo_path": "symbol_backend_projects/gpac",
      "is_vulnerable": false,
      "func_name": "sgpd_parse_entry",
      "func_body": "static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\tGF_DefaultSampleGroupDescriptionEntry *def_ptr;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tif (bytes_in_box<3) return NULL;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tBool use_mkey = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tbytes_in_box -= 3;\n\t\tif (use_mkey) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tu32 i, count = gf_bs_read_u16(bs);\n\t\t\tbytes_in_box -= 2;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu8 ivsize = gf_bs_read_u8(bs);\n\t\t\t\tgf_bs_skip_bytes(bs, 16);\n\t\t\t\tbytes_in_box -= 17;\n\t\t\t\tif (!ivsize) {\n\t\t\t\t\t//const IV\n\t\t\t\t\tivsize = gf_bs_read_u8(bs);\n\t\t\t\t\tgf_bs_skip_bytes(bs, ivsize);\n\t\t\t\t\tbytes_in_box -= 1 + ivsize;\n\t\t\t\t}\n\t\t\t\tif (bytes_in_box<0) {\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos);\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\tptr->key_info[0] = 1;\n\t\t\tgf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1);\n\t\t\t*total_bytes = 3 + ptr->key_info_size - 1;\n\n\t\t\tif (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) {\n\t\t\t\tgf_free(ptr->key_info);\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tbin128 kid;\n\t\t\tu8 const_iv_size = 0;\n\t\t\tu8 iv_size = gf_bs_read_u8(bs);\n\t\t\tgf_bs_read_data(bs, kid, 16);\n\t\t\tbytes_in_box -= 17;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t*total_bytes = 20;\n\t\t\tif ((ptr->IsProtected == 1) && !iv_size) {\n\t\t\t\tconst_iv_size = gf_bs_read_u8(bs);\n\t\t\t\tif ((const_iv_size != 8) && (const_iv_size != 16)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group have invalid constant_IV size\\n\"));\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 20;\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info_size += 1 + const_iv_size;\n\t\t\t}\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr->key_info[0] = 0;\n\t\t\tptr->key_info[1] = 0;\n\t\t\tptr->key_info[2] = 0;\n\t\t\tptr->key_info[3] = iv_size;\n\t\t\tmemcpy(ptr->key_info+4, kid, 16);\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info[20] = const_iv_size;\n\t\t\t\tgf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size);\n\t\t\t\t*total_bytes += 1 + const_iv_size;\n\t\t\t}\n\t\t}\n\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + (large_size ? 2 : 1);\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureOrderEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->subpic_id_info_flag = gf_bs_read_int(bs, 1);\n\t\tptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15);\n\t\t*total_bytes = 2;\n\t\tptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx);\n\t\tif (!ptr->subp_track_ref_idx) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->num_subpic_ref_idx; i++) {\n\t\t\tptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\tif (ptr->subpic_id_info_flag) {\n\t\t\tptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4);\n\t\t\tptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12);\n\t\t\tptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1);\n\t\t\tptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (ptr->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 6);\n\t\t\t} else {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 4);\n\t\t\t\tgf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\t*total_bytes += 3;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->groupID_info_4cc = gf_bs_read_u32(bs);\n\t\tptr->nb_entries = 1 + gf_bs_read_u16(bs);\n\t\t*total_bytes = 6;\n\t\tptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries);\n\t\tif (!ptr->groupIDs) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tptr->groupIDs[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase 0:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] sgpd entry null grouping_type is invalid\\n\") );\n\t\treturn NULL;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( grouping_type) ));\n\t\treturn NULL;\n\t}\n\tGF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!def_ptr) return NULL;\n\tif (entry_size) {\n\t\tdef_ptr->length = entry_size;\n\t\tdef_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length);\n\t\tif (!def_ptr->data) {\n\t\t\tgf_free(def_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tgf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn def_ptr;\n}",
      "line_statements": [
        [
          9986,
          "\tcase 0:"
        ],
        [
          9987,
          "\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] sgpd entry null grouping_type is invalid\\n\") );"
        ],
        [
          9988,
          "\t\treturn NULL;"
        ]
      ],
      "statements": [
        [
          9986,
          "case 0:"
        ],
        [
          9987,
          "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] sgpd entry null grouping_type is invalid\\n\") );"
        ],
        [
          9988,
          "return NULL;"
        ]
      ],
      "cve": "CVE-2023-0760"
    },
    {
      "commit_id": "f6d39c31d2177549a986d170e192d8351bd571e2",
      "filepath": "src/mbyte.c",
      "project": "vim",
      "project_repo_path": "symbol_backend_projects/vim",
      "is_vulnerable": false,
      "func_name": "latin_ptr2len",
      "func_body": "latin_ptr2len(char_u *p)\n{\n    return *p == NUL ? 0 : 1;\n}",
      "line_statements": [
        [
          1086,
          "    return *p == NUL ? 0 : 1;"
        ]
      ],
      "statements": [
        [
          1086,
          "return *p == NUL ? 0 : 1;"
        ]
      ],
      "cve": "CVE-2022-2849"
    },
    {
      "commit_id": "232bdaaca98c34a99ffadf27bf6ee08be6cc8f6a",
      "filepath": "src/normal.c",
      "project": "vim",
      "project_repo_path": "symbol_backend_projects/vim",
      "is_vulnerable": true,
      "func_name": "nv_scroll",
      "func_body": "nv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    --curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}",
      "line_statements": [
        [
          3732,
          "\t\t    --curwin->w_cursor.lnum;"
        ]
      ],
      "statements": [
        [
          3732,
          "--curwin->w_cursor.lnum;"
        ]
      ],
      "cve": "CVE-2023-0288"
    },
    {
      "commit_id": "f6d28fe2c95c678cc3202cc5dc825a3fcc709e93",
      "filepath": "src/ex_cmds.c",
      "project": "vim",
      "project_repo_path": "symbol_backend_projects/vim",
      "is_vulnerable": false,
      "func_name": "ex_substitute",
      "func_body": "ex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    char_u\t*sub_copy = NULL;\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n    int\t\tsave_sandbox = 0;\n#endif\n#ifdef FEAT_PROP_POPUP\n    textprop_T\t*text_props = NULL;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    if (in_vim9script())\n\t    {\n\t\temsg(_(e_cannot_use_s_backslash_in_vim9_script));\n\t\treturn;\n\t    }\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST, pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    if (search_regcomp(pat, NULL, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * If the substitute pattern starts with \"\\=\" then it's an expression.\n     * Make a copy, a recursive function may free it.\n     * Otherwise, '~' in the substitute pattern is replaced with the old\n     * pattern.  We do it here once to avoid it to be replaced over and over\n     * again.\n     */\n    if (sub[0] == '\\\\' && sub[1] == '=')\n    {\n\tsub = vim_strsave(sub);\n\tif (sub == NULL)\n\t    return;\n\tsub_copy = sub;\n    }\n    else\n    {\n\tchar_u *newsub = regtilde(sub, magic_isset());\n\n\tif (newsub != sub)\n\t{\n\t    // newsub was allocated, free it later.\n\t    sub_copy = newsub;\n\t    sub = newsub;\n\t}\n    }\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n\t    int\t\ttext_prop_count = 0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to MODE_CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = MODE_CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t\t// When \":normal\" runs out of characters we get\n\t\t\t\t// an empty line.  Use \"q\" to get out of the\n\t\t\t\t// loop.\n\t\t\t\tif (ex_normal_busy && typed == NUL)\n\t\t\t\t    typed = 'q';\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    int save_RedrawingDisabled = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    if (search_match_lines == 0\n\t\t\t\t\t\t   && search_match_endcol == 0)\n\t\t\t\t// highlight at least one character for /^/\n\t\t\t\tsearch_match_endcol = 1;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(UPD_SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(UPD_SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return()\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = save_RedrawingDisabled;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tsave_sandbox = sandbox;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n\n\t\t// Disallow changing text or switching window in an expression.\n\t\t++textlock;\n#endif\n\t\t// Get length of substitution part, including the NUL.\n\t\t// When it fails sublen is zero.\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, 0,\n\t\t\t       REGSUB_BACKSLASH\n\t\t\t\t    | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (sublen == 0 || aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    sandbox = save_sandbox;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t    // safety check\n\t\t    if (nmatch < 0)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    linenr_T\tlastlnum = sub_firstlnum + nmatch - 1;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tchar_u\t*prop_start;\n\n\t\t\t// Props in the first line may be shortened or deleted\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       -MAXCOL, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\ttotal_added -= (colnr_T)STRLEN(\n\t\t\t\t     sub_firstline + regmatch.startpos[0].col);\n\n\t\t\t// Props in the last line may be moved or deleted\n\t\t\tif (adjust_prop_columns(lastlnum,\n\t\t\t\t\t0, -regmatch.endpos[0].col, apc_flags))\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\n\t\t\t// Copy the text props of the last line, they will be\n\t\t\t// later appended to the changed line.\n\t\t\ttext_prop_count = get_text_props(curbuf, lastlnum,\n\t\t\t\t\t\t\t   &prop_start, FALSE);\n\t\t\tif (text_prop_count > 0)\n\t\t\t{\n\t\t\t    // TODO: what when we already did this?\n\t\t\t    vim_free(text_props);\n\t\t\t    text_props = ALLOC_MULT(textprop_T,\n\t\t\t\t\t\t\t      text_prop_count);\n\t\t\t    if (text_props != NULL)\n\t\t\t    {\n\t\t\t\tint pi;\n\n\t\t\t\tmch_memmove(text_props, prop_start,\n\t\t\t\t\t text_prop_count * sizeof(textprop_T));\n\t\t\t\t// After joining the text prop columns will\n\t\t\t\t// increase.\n\t\t\t\tfor (pi = 0; pi < text_prop_count; ++pi)\n\t\t\t\t    text_props[pi].tp_col +=\n\t\t\t\t\t regmatch.startpos[0].col + sublen - 1;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n#endif\n\t\t    p1 = ml_get(lastlnum);\n\t\t    nmatch_tl += nmatch - 1;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t\ttotal_added += (colnr_T)STRLEN(\n\t\t\t\t\t\t  p1 + regmatch.endpos[0].col);\n#endif\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\tif ((int)new_start_len - copy_len < sublen)\n\t\t    sublen = new_start_len - copy_len - 1;\n\n#ifdef FEAT_EVAL\n\t\t++textlock;\n#endif\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, sublen,\n\t\t\t\t      REGSUB_COPY | REGSUB_BACKSLASH\n\t\t\t\t\t | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n#endif\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum,\n\t\t\t\t\t\t\t       plen, 1, FALSE);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (text_props != NULL)\n\t\t\t    add_text_props(lnum, text_props, text_prop_count);\n#endif\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n#ifdef FEAT_PROP_POPUP\n    vim_free(text_props);\n#endif\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n    vim_free(sub_copy);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}",
      "line_statements": [
        [
          4523,
          "\t\t    if (nmatch < 0)"
        ],
        [
          4524,
          "\t\t\tgoto skip;"
        ]
      ],
      "statements": [
        [
          4523,
          "if (nmatch < 0)"
        ],
        [
          4524,
          "goto skip;"
        ]
      ],
      "cve": "CVE-2023-4781"
    }
  ],
  "CWE-400": [
    {
      "commit_id": "473851d211cf8805a161820337ca74cc9615d6ef",
      "filepath": "tif_overview.c",
      "project": "libtiff",
      "project_repo_path": "symbol_backend_projects/libtiff",
      "is_vulnerable": false,
      "func_name": "TIFF_WriteOverview",
      "func_body": "uint32 TIFF_WriteOverview( TIFF *hTIFF, uint32 nXSize, uint32 nYSize,\n                           int nBitsPerPixel, int nPlanarConfig, int nSamples, \n                           int nBlockXSize, int nBlockYSize,\n                           int bTiled, int nCompressFlag, int nPhotometric,\n                           int nSampleFormat,\n                           unsigned short *panRed,\n                           unsigned short *panGreen,\n                           unsigned short *panBlue,\n                           int bUseSubIFDs,\n                           int nHorSubsampling, int nVerSubsampling )\n\n{\n    toff_t\tnBaseDirOffset;\n    toff_t\tnOffset;\n    tdir_t\tiNumDir;\n\n    (void) bUseSubIFDs;\n\n    nBaseDirOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFCreateDirectory( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Setup TIFF fields.                                              */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    if( nSamples == 1 )\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    else\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig );\n\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat );\n\n    if( bTiled )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize );\n        TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize );\n    }\n    else\n        TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize );\n\n    TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE );\n\n    if( nPhotometric == PHOTOMETRIC_YCBCR || nPhotometric == PHOTOMETRIC_ITULAB )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, nHorSubsampling, nVerSubsampling);\n        /* TODO: also write YCbCrPositioning and YCbCrCoefficients tag identical to source IFD */\n    }\n    /* TODO: add command-line parameter for selecting jpeg compression quality\n     * that gets ignored when compression isn't jpeg */\n\n/* -------------------------------------------------------------------- */\n/*\tWrite color table if one is present.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( panRed != NULL )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write directory, and return byte offset.                        */\n/* -------------------------------------------------------------------- */\n    if( TIFFWriteCheck( hTIFF, bTiled, \"TIFFBuildOverviews\" ) == 0 )\n        return 0;\n\n    TIFFWriteDirectory( hTIFF );\n    iNumDir = TIFFNumberOfDirectories(hTIFF);\n    if( iNumDir > TIFF_DIR_MAX )\n    {\n        TIFFErrorExt( TIFFClientdata(hTIFF),\n                      \"TIFF_WriteOverview\",\n                      \"File `%s' has too many directories.\\n\",\n                      TIFFFileName(hTIFF) );\n        exit(-1);\n    }\n    TIFFSetDirectory( hTIFF, (tdir_t) (iNumDir - 1) );\n\n    nOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n\n    return nOffset;\n}",
      "line_statements": [
        [
          96,
          "    tdir_t\tiNumDir;"
        ],
        [
          153,
          "    iNumDir = TIFFNumberOfDirectories(hTIFF);"
        ],
        [
          154,
          "    if( iNumDir > TIFF_DIR_MAX )"
        ],
        [
          155,
          "    {"
        ],
        [
          156,
          "        TIFFErrorExt( TIFFClientdata(hTIFF),"
        ],
        [
          157,
          "                      \"TIFF_WriteOverview\","
        ],
        [
          158,
          "                      \"File `%s' has too many directories.\\n\","
        ],
        [
          159,
          "                      TIFFFileName(hTIFF) );"
        ],
        [
          160,
          "        exit(-1);"
        ],
        [
          161,
          "    }"
        ],
        [
          162,
          "    TIFFSetDirectory( hTIFF, (tdir_t) (iNumDir - 1) );"
        ]
      ],
      "statements": [
        [
          96,
          "tdir_t\tiNumDir;"
        ],
        [
          153,
          "iNumDir = TIFFNumberOfDirectories(hTIFF);"
        ],
        [
          154,
          "if( iNumDir > TIFF_DIR_MAX )"
        ],
        [
          155,
          "    {\n"
        ],
        [
          156,
          "TIFFErrorExt( TIFFClientdata(hTIFF),\n                      \"TIFF_WriteOverview\",\n                      \"File `%s' has too many directories.\\n\",\n                      TIFFFileName(hTIFF) );"
        ],
        [
          160,
          "exit(-1);"
        ],
        [
          161,
          "    }\n"
        ],
        [
          162,
          "TIFFSetDirectory( hTIFF, (tdir_t) (iNumDir - 1) );"
        ]
      ],
      "cve": "CVE-2018-5784"
    },
    {
      "commit_id": "d974baa398f34393db76be45f7d4d04fbdbb4a0a",
      "filepath": "arch/x86/kvm/vmx.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "vmx_vcpu_run",
      "func_body": "static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr, cr4;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\t/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state */\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\tif (vmx->ple_window_dirty) {\n\t\tvmx->ple_window_dirty = false;\n\t\tvmcs_write32(PLE_WINDOW, vmx->ple_window);\n\t}\n\n\tif (vmx->nested.sync_shadow_vmcs) {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\tcr4 = read_cr4();\n\tif (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->host_state.vmcs_host_cr4 = cr4;\n\t}\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tatomic_switch_perf_msrs(vmx);\n\tdebugctlmsr = get_debugctlmsr();\n\n\tvmx->__launched = vmx->loaded_vmcs->launched;\n\tasm(\n\t\t/* Store host registers */\n\t\t\"push %%\" _ASM_DX \"; push %%\" _ASM_BP \";\"\n\t\t\"push %%\" _ASM_CX \" \\n\\t\" /* placeholder for guest rcx */\n\t\t\"push %%\" _ASM_CX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t\"je 1f \\n\\t\"\n\t\t\"mov %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t__ex(ASM_VMX_VMWRITE_RSP_RDX) \"\\n\\t\"\n\t\t\"1: \\n\\t\"\n\t\t/* Reload cr2 if changed */\n\t\t\"mov %c[cr2](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %%cr2, %%\" _ASM_DX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_AX \", %%\" _ASM_DX \" \\n\\t\"\n\t\t\"je 2f \\n\\t\"\n\t\t\"mov %%\" _ASM_AX\", %%cr2 \\n\\t\"\n\t\t\"2: \\n\\t\"\n\t\t/* Check if vmlaunch of vmresume is needed */\n\t\t\"cmpl $0, %c[launched](%0) \\n\\t\"\n\t\t/* Load guest registers.  Don't clobber flags. */\n\t\t\"mov %c[rax](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[rbx](%0), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rdx](%0), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%0), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%0), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%0), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%0),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%0),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%0), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%0), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%0), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%0), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%0), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%0), %%r15 \\n\\t\"\n#endif\n\t\t\"mov %c[rcx](%0), %%\" _ASM_CX \" \\n\\t\" /* kills %0 (ecx) */\n\n\t\t/* Enter guest mode */\n\t\t\"jne 1f \\n\\t\"\n\t\t__ex(ASM_VMX_VMLAUNCH) \"\\n\\t\"\n\t\t\"jmp 2f \\n\\t\"\n\t\t\"1: \" __ex(ASM_VMX_VMRESUME) \"\\n\\t\"\n\t\t\"2: \"\n\t\t/* Save guest registers, load host registers, keep flags */\n\t\t\"mov %0, %c[wordsize](%%\" _ASM_SP \") \\n\\t\"\n\t\t\"pop %0 \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[rax](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%0) \\n\\t\"\n\t\t__ASM_SIZE(pop) \" %c[rcx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%0) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%0) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%0) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%0) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%0) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%0) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%0) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%0) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%0) \\n\\t\"\n#endif\n\t\t\"mov %%cr2, %%\" _ASM_AX \"   \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[cr2](%0) \\n\\t\"\n\n\t\t\"pop  %%\" _ASM_BP \"; pop  %%\" _ASM_DX \" \\n\\t\"\n\t\t\"setbe %c[fail](%0) \\n\\t\"\n\t\t\".pushsection .rodata \\n\\t\"\n\t\t\".global vmx_return \\n\\t\"\n\t\t\"vmx_return: \" _ASM_PTR \" 2b \\n\\t\"\n\t\t\".popsection\"\n\t      : : \"c\"(vmx), \"d\"((unsigned long)HOST_RSP),\n\t\t[launched]\"i\"(offsetof(struct vcpu_vmx, __launched)),\n\t\t[fail]\"i\"(offsetof(struct vcpu_vmx, fail)),\n\t\t[host_rsp]\"i\"(offsetof(struct vcpu_vmx, host_rsp)),\n\t\t[rax]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),\n\t\t[rbx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t[rcx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t[rdx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t[rsi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t[rdi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t[rbp]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\n#ifdef CONFIG_X86_64\n\t\t[r8]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t[r9]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t[r10]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t[r11]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t[r12]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t[r13]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t[r14]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t[r15]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\n#endif\n\t\t[cr2]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),\n\t\t[wordsize]\"i\"(sizeof(ulong))\n\t      : \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rax\", \"rbx\", \"rdi\", \"rsi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"eax\", \"ebx\", \"edi\", \"esi\"\n#endif\n\t      );\n\n\t/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */\n\tif (debugctlmsr)\n\t\tupdate_debugctlmsr(debugctlmsr);\n\n#ifndef CONFIG_X86_64\n\t/*\n\t * The sysexit path does not restore ds/es, so we must set them to\n\t * a reasonable value ourselves.\n\t *\n\t * We can't defer this to vmx_load_host_state() since that function\n\t * may be executed in interrupt context, which saves and restore segments\n\t * around it, nullifying its effect.\n\t */\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#endif\n\n\tvcpu->arch.regs_avail = ~((1 << VCPU_REGS_RIP) | (1 << VCPU_REGS_RSP)\n\t\t\t\t  | (1 << VCPU_EXREG_RFLAGS)\n\t\t\t\t  | (1 << VCPU_EXREG_PDPTR)\n\t\t\t\t  | (1 << VCPU_EXREG_SEGMENTS)\n\t\t\t\t  | (1 << VCPU_EXREG_CR3));\n\tvcpu->arch.regs_dirty = 0;\n\n\tvmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);\n\n\tvmx->loaded_vmcs->launched = 1;\n\n\tvmx->exit_reason = vmcs_read32(VM_EXIT_REASON);\n\ttrace_kvm_exit(vmx->exit_reason, vcpu, KVM_ISA_VMX);\n\n\t/*\n\t * the KVM_REQ_EVENT optimization bit is only on for one entry, and if\n\t * we did not inject a still-pending event to L1 now because of\n\t * nested_run_pending, we need to re-enable this bit.\n\t */\n\tif (vmx->nested.nested_run_pending)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvmx->nested.nested_run_pending = 0;\n\n\tvmx_complete_atomic_exit(vmx);\n\tvmx_recover_nmi_blocking(vmx);\n\tvmx_complete_interrupts(vmx);\n}",
      "line_statements": [
        [
          7523,
          "\tunsigned long debugctlmsr, cr4;"
        ],
        [
          7549,
          "\tcr4 = read_cr4();"
        ],
        [
          7550,
          "\tif (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {"
        ],
        [
          7551,
          "\t\tvmcs_writel(HOST_CR4, cr4);"
        ],
        [
          7552,
          "\t\tvmx->host_state.vmcs_host_cr4 = cr4;"
        ],
        [
          7553,
          "\t}"
        ],
        [
          7554,
          ""
        ]
      ],
      "statements": [
        [
          7523,
          "unsigned long debugctlmsr, cr4;"
        ],
        [
          7549,
          "cr4 = read_cr4();"
        ],
        [
          7550,
          "if (unlikely(cr4 != vmx->host_state.vmcs_host_cr4))"
        ],
        [
          7551,
          "vmcs_writel(HOST_CR4, cr4);"
        ],
        [
          7552,
          "vmx->host_state.vmcs_host_cr4 = cr4;"
        ],
        [
          7553,
          "\t}\n"
        ],
        [
          7554,
          "\n"
        ]
      ],
      "cve": "CVE-2014-3690"
    },
    {
      "commit_id": "fac8e0f579695a3ecbc4d3cac369139d7f819971",
      "filepath": "net/core/dev.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "dev_gro_receive",
      "func_body": "\nstatic enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff *skb)\n{\n\tstruct sk_buff **pp = NULL;\n\tstruct packet_offload *ptype;\n\t__be16 type = skb->protocol;\n\tstruct list_head *head = &offload_base;\n\tint same_flow;\n\tenum gro_result ret;\n\tint grow;\n\n\tif (!(skb->dev->features & NETIF_F_GRO))\n\t\tgoto normal;\n\n\tif (skb_is_gso(skb) || skb_has_frag_list(skb) || skb->csum_bad)\n\t\tgoto normal;\n\n\tgro_list_prepare(napi, skb);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ptype, head, list) {\n\t\tif (ptype->type != type || !ptype->callbacks.gro_receive)\n\t\t\tcontinue;\n\n\t\tskb_set_network_header(skb, skb_gro_offset(skb));\n\t\tskb_reset_mac_len(skb);\n\t\tNAPI_GRO_CB(skb)->same_flow = 0;\n\t\tNAPI_GRO_CB(skb)->flush = 0;\n\t\tNAPI_GRO_CB(skb)->free = 0;\n\t\tNAPI_GRO_CB(skb)->encap_mark = 0;\n\t\tNAPI_GRO_CB(skb)->gro_remcsum_start = 0;\n\n\t\t/* Setup for GRO checksum validation */\n\t\tswitch (skb->ip_summed) {\n\t\tcase CHECKSUM_COMPLETE:\n\t\t\tNAPI_GRO_CB(skb)->csum = skb->csum;\n\t\t\tNAPI_GRO_CB(skb)->csum_valid = 1;\n\t\t\tNAPI_GRO_CB(skb)->csum_cnt = 0;\n\t\t\tbreak;\n\t\tcase CHECKSUM_UNNECESSARY:\n\t\t\tNAPI_GRO_CB(skb)->csum_cnt = skb->csum_level + 1;\n\t\t\tNAPI_GRO_CB(skb)->csum_valid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNAPI_GRO_CB(skb)->csum_cnt = 0;\n\t\t\tNAPI_GRO_CB(skb)->csum_valid = 0;\n\t\t}\n\n\t\tpp = ptype->callbacks.gro_receive(&napi->gro_list, skb);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (&ptype->list == head)\n\t\tgoto normal;\n\n\tsame_flow = NAPI_GRO_CB(skb)->same_flow;\n\tret = NAPI_GRO_CB(skb)->free ? GRO_MERGED_FREE : GRO_MERGED;\n\n\tif (pp) {\n\t\tstruct sk_buff *nskb = *pp;\n\n\t\t*pp = nskb->next;\n\t\tnskb->next = NULL;\n\t\tnapi_gro_complete(nskb);\n\t\tnapi->gro_count--;\n\t}\n\n\tif (same_flow)\n\t\tgoto ok;\n\n\tif (NAPI_GRO_CB(skb)->flush)\n\t\tgoto normal;\n\n\tif (unlikely(napi->gro_count >= MAX_GRO_SKBS)) {\n\t\tstruct sk_buff *nskb = napi->gro_list;\n\n\t\t/* locate the end of the list to select the 'oldest' flow */\n\t\twhile (nskb->next) {\n\t\t\tpp = &nskb->next;\n\t\t\tnskb = *pp;\n\t\t}\n\t\t*pp = NULL;\n\t\tnskb->next = NULL;\n\t\tnapi_gro_complete(nskb);\n\t} else {\n\t\tnapi->gro_count++;\n\t}\n\tNAPI_GRO_CB(skb)->count = 1;\n\tNAPI_GRO_CB(skb)->age = jiffies;\n\tNAPI_GRO_CB(skb)->last = skb;\n\tskb_shinfo(skb)->gso_size = skb_gro_len(skb);\n\tskb->next = napi->gro_list;\n\tnapi->gro_list = skb;\n\tret = GRO_HELD;\n\npull:\n\tgrow = skb_gro_offset(skb) - skb_headlen(skb);\n\tif (grow > 0)\n\t\tgro_pull_from_frag0(skb, grow);\nok:\n\treturn ret;\n\nnormal:\n\tret = GRO_NORMAL;\n\tgoto pull;",
      "line_statements": [
        [
          4441,
          "\t\tNAPI_GRO_CB(skb)->encap_mark = 0;"
        ]
      ],
      "statements": [
        [
          4441,
          "NAPI_GRO_CB(skb)->encap_mark = 0;"
        ]
      ],
      "cve": "CVE-2016-8666"
    },
    {
      "commit_id": "1fb254aa983bf190cfd685d40c64a480a9bafaee",
      "filepath": "fs/xfs/xfs_iops.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "xfs_setattr_nonsize",
      "func_body": "xfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_cancel;\n\t\t}\n\t}\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((inode->i_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tinode->i_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n\nout_cancel:\n\txfs_trans_cancel(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_dqrele:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\treturn error;\n}",
      "line_statements": [
        [
          796,
          "\txfs_iunlock(ip, XFS_ILOCK_EXCL);"
        ]
      ],
      "statements": [
        [
          796,
          "xfs_iunlock(ip, XFS_ILOCK_EXCL);"
        ]
      ],
      "cve": "CVE-2019-15538"
    }
  ],
  "CWE-22": [
    {
      "commit_id": "2896c93811e39d63a4d9b63ccf12a8fbc226e5e4",
      "filepath": "drivers/target/target_core_xcopy.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "xcopy_pt_undepend_remotedev",
      "func_body": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}",
      "line_statements": [
        [
          394,
          "\tstruct se_device *remote_dev;"
        ],
        [
          395,
          ""
        ],
        [
          397,
          "\t\tremote_dev = xop->dst_dev;"
        ],
        [
          399,
          "\t\tremote_dev = xop->src_dev;"
        ],
        [
          400,
          ""
        ],
        [
          401,
          "\tpr_debug(\"Calling configfs_undepend_item for\""
        ],
        [
          402,
          "\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\","
        ],
        [
          403,
          "\t\t  remote_dev, &remote_dev->dev_group.cg_item);"
        ],
        [
          405,
          "\ttarget_undepend_item(&remote_dev->dev_group.cg_item);"
        ]
      ],
      "statements": [
        [
          394,
          "struct se_device *remote_dev;"
        ],
        [
          395,
          "\n"
        ],
        [
          397,
          "remote_dev = xop->dst_dev;"
        ],
        [
          399,
          "remote_dev = xop->src_dev;"
        ],
        [
          400,
          "\n"
        ],
        [
          401,
          "pr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);"
        ],
        [
          405,
          "target_undepend_item(&remote_dev->dev_group.cg_item);"
        ]
      ],
      "cve": "CVE-2020-28374"
    },
    {
      "commit_id": "424be345639d75c6cb7d0bd2da5f0f407dbd0bd5",
      "filepath": "main/manager.c",
      "project": "asterisk",
      "project_repo_path": "symbol_backend_projects/asterisk",
      "is_vulnerable": true,
      "func_name": "action_getconfig",
      "func_body": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\n\t\tcatcount++;\n\t}\n\n\tif (!ast_strlen_zero(category) && catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}",
      "line_statements": [
        [
          3782,
          "\tif (restrictedFile(fn)) {"
        ]
      ],
      "statements": [
        [
          3782,
          "if (restrictedFile(fn))"
        ]
      ],
      "cve": "CVE-2023-49294"
    },
    {
      "commit_id": "ddb312090ebd5794e81bc6fb1dfb4e79eda48761",
      "filepath": "qpress.cpp",
      "project": "qpress",
      "project_repo_path": "symbol_backend_projects/qpress",
      "is_vulnerable": false,
      "func_name": "decompress_directory",
      "func_body": "void decompress_directory(string extract_dir, bool std_out)\r\n{\r\n    char c;\r\n    string curdir;\r\n    size_t r = 0;\r\n    unsigned int chunk_size;\r\n\r\n    curdir = string(extract_dir);\r\n\r\n    for(;;)\r\n    {\r\n        r = aread(&c, 1);\r\n        if (r == 0)\r\n            return;\r\n\r\n        if(c == 'D')\r\n        {\r\n\t\t\t// read directory name, append it to current path and create the directory\r\n            chunk_size = fread32();\r\n\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)\r\n            {\r\n                abort(\"File path string is bigger than buffer size\");\r\n            }\r\n            try_aread(tmp, chunk_size + 1);\r\n            curdir = curdir + DELIM_STR + tmp;\r\n            PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\r\n\t\t\t/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\r\n\t \t\tNeed to check if we try to decompress file or directory outside working directory\r\n\t \t\t*/\r\n\t        if(true == check_if_path_has_dir_traversal(tmp)) \r\n            {\r\n\t            abort(\"Directory path contains directory traversal which is not allowed.\");\r\n\t        }\r\n\t        /* End of RDS security fix*/\r\n            if(!std_out)\r\n            {\r\n#ifdef WINDOWS\r\n                CreateDirectory(curdir.c_str(), 0);\r\n#else\r\n                mkdir(curdir.c_str(), 509);\r\n#endif\r\n            }\r\n        }\r\n        else if(c == 'U')\r\n            curdir = curdir.substr(0, curdir.find_last_of(DELIM_STR)); // remove last sub dir from current path\r\n        else if(c == 'F')\r\n        {\r\n            chunk_size = fread32(); // read length of file name\r\n            if(NAME_BUFFER_SIZE < chunk_size + 1)\r\n\t             {\r\n\t                 abort(\"File path string is bigger than buffer size\");\r\n\t             }\r\n\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'\r\n\t         /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\r\n\t \t\t   Need to check if we try to decompress file or directory outside working directory\r\n\t \t\t*/\r\n\t         if(true == check_if_path_has_dir_traversal(tmp)) \r\n\t         {\r\n\t             abort(\"File path contains directory traversal which is not allowed.\");\r\n\t         }\r\n\t         /* End of RDS security fix*/\r\n            string buf2 = curdir + DELIM_STR + tmp;\r\n            PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\r\n            if(!std_out)\r\n            {\r\n                if(exists(buf2) && !force_flag)\r\n                    abort(\"Destination file '%s' already exists - aborted\", buf2.c_str());\r\n                else\r\n                    decompress_file(buf2);\r\n            }\r\n            else\r\n                decompress_file(\"<stdout>\");\r\n        }\r\n        else\r\n            abort(\"Source file is corrupted - try the -R flag to recover\");\r\n    }\r\n}\r",
      "line_statements": [
        [
          975,
          "\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)"
        ],
        [
          976,
          "            {"
        ],
        [
          977,
          "                abort(\"File path string is bigger than buffer size\");"
        ],
        [
          978,
          "            }"
        ],
        [
          983,
          "\t \t\tNeed to check if we try to decompress file or directory outside working directory"
        ],
        [
          985,
          "\t        if(true == check_if_path_has_dir_traversal(tmp))"
        ],
        [
          986,
          "            {"
        ],
        [
          987,
          "\t            abort(\"Directory path contains directory traversal which is not allowed.\");"
        ],
        [
          988,
          "\t        }"
        ],
        [
          1004,
          "            if(NAME_BUFFER_SIZE < chunk_size + 1)"
        ],
        [
          1005,
          "\t             {"
        ],
        [
          1006,
          "\t                 abort(\"File path string is bigger than buffer size\");"
        ],
        [
          1007,
          "\t             }"
        ],
        [
          1008,
          "\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'"
        ],
        [
          1010,
          "\t \t\t   Need to check if we try to decompress file or directory outside working directory"
        ],
        [
          1012,
          "\t         if(true == check_if_path_has_dir_traversal(tmp))"
        ],
        [
          1013,
          "\t         {"
        ],
        [
          1014,
          "\t             abort(\"File path contains directory traversal which is not allowed.\");"
        ],
        [
          1015,
          "\t         }"
        ]
      ],
      "statements": [
        [
          975,
          "if(NAME_BUFFER_SIZE < chunk_size + 1)"
        ],
        [
          976,
          "            {\r\n"
        ],
        [
          977,
          "abort(\"File path string is bigger than buffer size\");"
        ],
        [
          978,
          "            }\r\n"
        ],
        [
          982,
          "/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\r\n\t \t\tNeed to check if we try to decompress file or directory outside working directory\r\n\t \t\t*/"
        ],
        [
          985,
          "if(true == check_if_path_has_dir_traversal(tmp))"
        ],
        [
          986,
          "            {\r\n"
        ],
        [
          987,
          "abort(\"Directory path contains directory traversal which is not allowed.\");"
        ],
        [
          988,
          "\t        }\r\n"
        ],
        [
          1004,
          "if(NAME_BUFFER_SIZE < chunk_size + 1)"
        ],
        [
          1005,
          "\t             {\r\n"
        ],
        [
          1006,
          "abort(\"File path string is bigger than buffer size\");"
        ],
        [
          1007,
          "\t             }\r\n"
        ],
        [
          1008,
          "\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'\r\n"
        ],
        [
          1009,
          "/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\r\n\t \t\t   Need to check if we try to decompress file or directory outside working directory\r\n\t \t\t*/"
        ],
        [
          1012,
          "if(true == check_if_path_has_dir_traversal(tmp))"
        ],
        [
          1013,
          "\t         {\r\n"
        ],
        [
          1014,
          "abort(\"File path contains directory traversal which is not allowed.\");"
        ],
        [
          1015,
          "\t         }\r\n"
        ]
      ],
      "cve": "CVE-2022-45866"
    }
  ],
  "CWE-835": [
    {
      "commit_id": "6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91",
      "filepath": "mm/madvise.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "madvise_willneed",
      "func_body": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n\n\t*prev = vma;\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\n\tif (shmem_mapping(file->f_mapping)) {\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\n\tif (IS_DAX(file_inode(file))) {\n\t\t/* no bad return value, but ignore advice */\n\t\treturn 0;\n\t}\n\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}",
      "line_statements": [
        [
          279,
          "\t*prev = vma;"
        ]
      ],
      "statements": [
        [
          279,
          "*prev = vma;"
        ]
      ],
      "cve": "CVE-2017-18208"
    },
    {
      "commit_id": "8354763b90490d4105695df52674d0fcef823e92",
      "filepath": "table.c",
      "project": "w3m",
      "project_repo_path": "symbol_backend_projects/w3m",
      "is_vulnerable": false,
      "func_name": "feed_table_block_tag",
      "func_body": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    if (tbl->indent < 0)\n\ttbl->indent = 0;\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n\tif (offset < 0)\n\t    offset = 0;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}",
      "line_statements": [
        [
          2359,
          "    if (tbl->indent < 0)"
        ],
        [
          2360,
          "\ttbl->indent = 0;"
        ],
        [
          2365,
          "\tif (offset < 0)"
        ],
        [
          2366,
          "\t    offset = 0;"
        ]
      ],
      "statements": [
        [
          2359,
          "if (tbl->indent < 0)"
        ],
        [
          2360,
          "tbl->indent = 0;"
        ],
        [
          2365,
          "if (offset < 0)"
        ],
        [
          2366,
          "offset = 0;"
        ]
      ],
      "cve": "CVE-2018-6196"
    },
    {
      "commit_id": "3ca8138f014a913f98e6ef40e939868e1e9ea876",
      "filepath": "fs/fuse/file.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": false,
      "func_name": "fuse_fill_write_pages",
      "func_body": "static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\n\treturn count > 0 ? count : err;\n}",
      "line_statements": [
        [
          1052,
          "\t\tiov_iter_advance(ii, tmp);"
        ]
      ],
      "statements": [
        [
          1052,
          "iov_iter_advance(ii, tmp);"
        ]
      ],
      "cve": "CVE-2015-8785"
    }
  ],
  "CWE-284": [
    {
      "commit_id": "2af9a55b38b55abbf05fd116ec097d4029115839",
      "filepath": "libndp/libndp.c",
      "project": "libndp",
      "project_repo_path": "symbol_backend_projects/libndp",
      "is_vulnerable": false,
      "func_name": "ndp_msg_check_valid",
      "func_body": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\n\tif (ndp_msg_type_info(msg_type)->addrto_validate)\n\t\treturn ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);\n\telse\n\t\treturn true;\n}",
      "line_statements": [
        [
          429,
          ""
        ],
        [
          430,
          "\tif (ndp_msg_type_info(msg_type)->addrto_validate)"
        ],
        [
          431,
          "\t\treturn ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);"
        ],
        [
          432,
          "\telse"
        ],
        [
          433,
          "\t\treturn true;"
        ]
      ],
      "statements": [
        [
          429,
          "\n"
        ],
        [
          430,
          "if (ndp_msg_type_info(msg_type)->addrto_validate)"
        ],
        [
          431,
          "return ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);"
        ],
        [
          432,
          "else"
        ],
        [
          433,
          "return true;"
        ]
      ],
      "cve": "CVE-2016-3698"
    },
    {
      "commit_id": "92362a92fffe60187df61f99ab11c249d44120ee",
      "filepath": "src/slurmd/slurmd/req.c",
      "project": "slurm",
      "project_repo_path": "symbol_backend_projects/slurm",
      "is_vulnerable": true,
      "func_name": "_prolog_error",
      "func_body": "_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}",
      "line_statements": [
        [
          1418,
          ""
        ],
        [
          1419,
          "\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {"
        ],
        [
          1420,
          "\t\terror(\"Unable to open %s: %s\", path_name,"
        ],
        [
          1421,
          "\t\t      slurm_strerror(errno));"
        ]
      ],
      "statements": [
        [
          1418,
          "\n"
        ],
        [
          1419,
          "if ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1)"
        ],
        [
          1420,
          "error(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));"
        ]
      ],
      "cve": "CVE-2016-10030"
    },
    {
      "commit_id": "a4892df306e0532487f1634ba6d4c6d4bb381c7f",
      "filepath": "libndp/libndp.c",
      "project": "libndp",
      "project_repo_path": "symbol_backend_projects/libndp",
      "is_vulnerable": true,
      "func_name": "ndp_sock_recv",
      "func_body": "static int ndp_sock_recv(struct ndp *ndp)\n{\n\tstruct ndp_msg *msg;\n\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tndp_msg_init(msg, msg_type);\n\tndp_msg_payload_len_set(msg, len);\n\n\tif (!ndp_msg_check_valid(msg)) {\n\t\twarn(ndp, \"rcvd invalid ND message\");\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\tdbg(ndp, \"rcvd %s, len: %zuB\",\n\t\t ndp_msg_type_info(msg_type)->strabbr, len);\n\n\tif (!ndp_msg_check_opts(msg)) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\terr = ndp_call_handlers(ndp, msg);;\n\nfree_msg:\n\tndp_msg_destroy(msg);\n\treturn err;\n}",
      "line_statements": [
        [
          1700,
          "\t\t\t  &msg->addrto, &msg->ifindex);"
        ],
        [
          1705,
          "\tdbg(ndp, \"rcvd from: %s, ifindex: %u\","
        ],
        [
          1706,
          "\t\t str_in6_addr(&msg->addrto), msg->ifindex);"
        ]
      ],
      "statements": [
        [
          1699,
          "err = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);"
        ],
        [
          1705,
          "dbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);"
        ]
      ],
      "cve": "CVE-2016-3698"
    }
  ],
  "CWE-674": [
    {
      "commit_id": "38096961c7cd109110ac21d3ed7dad7e0cb0ae06",
      "filepath": "src/alter.c",
      "project": "sqlite",
      "project_repo_path": "symbol_backend_projects/sqlite",
      "is_vulnerable": false,
      "func_name": "renameTableSelectCb",
      "func_body": "static int renameTableSelectCb(Walker *pWalker, Select *pSelect){\n  int i;\n  RenameCtx *p = pWalker->u.pRename;\n  SrcList *pSrc = pSelect->pSrc;\n  if( pSelect->selFlags & SF_View ) return WRC_Prune;\n  if( pSrc==0 ){\n    assert( pWalker->pParse->db->mallocFailed );\n    return WRC_Abort;\n  }\n  for(i=0; i<pSrc->nSrc; i++){\n    struct SrcList_item *pItem = &pSrc->a[i];\n    if( pItem->pTab==p->pTab ){\n      renameTokenFind(pWalker->pParse, p, pItem->zName);\n    }\n  }\n  renameWalkWith(pWalker, pSelect);\n\n  return WRC_Continue;\n}",
      "line_statements": [
        [
          1440,
          "  if( pSelect->selFlags & SF_View ) return WRC_Prune;"
        ]
      ],
      "statements": [
        [
          1440,
          "if( pSelect->selFlags & SF_View )"
        ]
      ],
      "cve": "CVE-2019-19645"
    },
    {
      "commit_id": "c6173f5fe66cdbab74f4f869311fe6aae2ba35f4",
      "filepath": "tensorflow/lite/core/subgraph.cc",
      "project": "tensorflow",
      "project_repo_path": "symbol_backend_projects/tensorflow",
      "is_vulnerable": false,
      "func_name": "tflite::SubgraphGuard::SubgraphGuard",
      "func_body": "  SubgraphGuard(TfLiteContext* context, bool* is_subgraph_in_use)\n      : is_subgraph_in_use_(is_subgraph_in_use) {\n    if (*is_subgraph_in_use_) {\n      TF_LITE_KERNEL_LOG(\n          context,\n          \"Subgraph is already in use. Using an interpreter or a subgraph in \"\n          \"multiple threads is not supported. Recursion in the graph is not \"\n          \"supported.\");\n      status_ = kTfLiteError;\n    } else {\n      *is_subgraph_in_use_ = true;\n    }\n  }",
      "line_statements": [
        [
          168,
          "  SubgraphGuard(TfLiteContext* context, bool* is_subgraph_in_use)"
        ],
        [
          169,
          "      : is_subgraph_in_use_(is_subgraph_in_use) {"
        ],
        [
          170,
          "    if (*is_subgraph_in_use_) {"
        ],
        [
          171,
          "      TF_LITE_KERNEL_LOG("
        ],
        [
          172,
          "          context,"
        ],
        [
          173,
          "          \"Subgraph is already in use. Using an interpreter or a subgraph in \""
        ],
        [
          174,
          "          \"multiple threads is not supported. Recursion in the graph is not \""
        ],
        [
          175,
          "          \"supported.\");"
        ],
        [
          176,
          "      status_ = kTfLiteError;"
        ],
        [
          177,
          "    } else {"
        ],
        [
          178,
          "      *is_subgraph_in_use_ = true;"
        ],
        [
          179,
          "    }"
        ],
        [
          180,
          "  }"
        ]
      ],
      "statements": [
        [
          168,
          "SubgraphGuard(TfLiteContext* context, bool* is_subgraph_in_use)\n      : is_subgraph_in_use_(is_subgraph_in_use) {"
        ],
        [
          170,
          "if (*is_subgraph_in_use_)"
        ],
        [
          171,
          "TF_LITE_KERNEL_LOG(\n          context,\n          \"Subgraph is already in use. Using an interpreter or a subgraph in \"\n          \"multiple threads is not supported. Recursion in the graph is not \"\n          \"supported.\");"
        ],
        [
          176,
          "status_ = kTfLiteError;"
        ],
        [
          177,
          "else"
        ],
        [
          178,
          "*is_subgraph_in_use_ = true;"
        ],
        [
          179,
          "    }\n"
        ],
        [
          180,
          "  }"
        ]
      ],
      "cve": "CVE-2021-29591"
    }
  ],
  "CWE-59": [
    {
      "commit_id": "72cf81f6a3404e35028567db2c99a90406e9c6e6",
      "filepath": "src/lxc/lxclock.c",
      "project": "lxc",
      "project_repo_path": "symbol_backend_projects/lxc",
      "is_vulnerable": true,
      "func_name": "lxclock_name",
      "func_body": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\n\t/* lockfile will be:\n\t * \"/run\" + \"/lock/lxc/$lxcpath/$lxcname + '\\0' if root\n\t * or\n\t * $XDG_RUNTIME_DIR + \"/lock/lxc/$lxcpath/$lxcname + '\\0' if non-root\n\t */\n\n\t/* length of \"/lock/lxc/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\t/* fall back to \"/tmp/\" + $(id -u) + \"/lxc\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0'\n\t\t * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)\n\t\t * * lxcpath always starts with '/'\n\t\t */\n\t\tint l2 = 22 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = mkdir_p(dest, 0755);\n\t\tif (ret < 0) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);\n\n\tfree(rundir);\n\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}",
      "line_statements": [
        [
          112,
          "\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;"
        ],
        [
          123,
          "\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);"
        ],
        [
          135,
          "\t\tint l2 = 22 + strlen(n) + strlen(p);"
        ],
        [
          136,
          "\t\tif (l2 > len) {"
        ],
        [
          137,
          "\t\t\tchar *d;"
        ],
        [
          138,
          "\t\t\td = realloc(dest, l2);"
        ],
        [
          139,
          "\t\t\tif (!d) {"
        ],
        [
          140,
          "\t\t\t\tfree(dest);"
        ],
        [
          141,
          "\t\t\t\tfree(rundir);"
        ],
        [
          142,
          "\t\t\t\treturn NULL;"
        ],
        [
          143,
          "\t\t\t}"
        ],
        [
          144,
          "\t\t\tlen = l2;"
        ],
        [
          145,
          "\t\t\tdest = d;"
        ],
        [
          146,
          "\t\t}"
        ],
        [
          147,
          "\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);"
        ],
        [
          148,
          "\t\tif (ret < 0 || ret >= len) {"
        ],
        [
          149,
          "\t\t\tfree(dest);"
        ],
        [
          150,
          "\t\t\tfree(rundir);"
        ],
        [
          151,
          "\t\t\treturn NULL;"
        ],
        [
          152,
          "\t\t}"
        ],
        [
          153,
          "\t\tret = mkdir_p(dest, 0755);"
        ],
        [
          154,
          "\t\tif (ret < 0) {"
        ],
        [
          155,
          "\t\t\tfree(dest);"
        ],
        [
          156,
          "\t\t\tfree(rundir);"
        ],
        [
          157,
          "\t\t\treturn NULL;"
        ],
        [
          158,
          "\t\t}"
        ],
        [
          159,
          "\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);"
        ],
        [
          160,
          "\t} else"
        ],
        [
          161,
          "\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);"
        ],
        [
          164,
          ""
        ]
      ],
      "statements": [
        [
          112,
          "len = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;"
        ],
        [
          123,
          "ret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);"
        ],
        [
          135,
          "int l2 = 22 + strlen(n) + strlen(p);"
        ],
        [
          136,
          "if (l2 > len)"
        ],
        [
          137,
          "char *d;"
        ],
        [
          138,
          "d = realloc(dest, l2);"
        ],
        [
          139,
          "if (!d)"
        ],
        [
          140,
          "free(dest);"
        ],
        [
          141,
          "free(rundir);"
        ],
        [
          142,
          "return NULL;"
        ],
        [
          143,
          "\t\t\t}\n"
        ],
        [
          144,
          "len = l2;"
        ],
        [
          145,
          "dest = d;"
        ],
        [
          146,
          "\t\t}\n"
        ],
        [
          147,
          "ret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);"
        ],
        [
          148,
          "if (ret < 0 || ret >= len)"
        ],
        [
          149,
          "free(dest);"
        ],
        [
          150,
          "free(rundir);"
        ],
        [
          151,
          "return NULL;"
        ],
        [
          152,
          "\t\t}\n"
        ],
        [
          153,
          "ret = mkdir_p(dest, 0755);"
        ],
        [
          154,
          "if (ret < 0)"
        ],
        [
          155,
          "free(dest);"
        ],
        [
          156,
          "free(rundir);"
        ],
        [
          157,
          "return NULL;"
        ],
        [
          158,
          "\t\t}\n"
        ],
        [
          159,
          "ret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);"
        ],
        [
          160,
          "else"
        ],
        [
          161,
          "ret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);"
        ],
        [
          164,
          "\n"
        ]
      ],
      "cve": "CVE-2015-1331"
    },
    {
      "commit_id": "fba4f123cc456d2b2538f811bb831483bf336bad",
      "filepath": "libarchive/archive_disk_acl_freebsd.c",
      "project": "libarchive",
      "project_repo_path": "symbol_backend_projects/libarchive",
      "is_vulnerable": true,
      "func_name": "set_acl",
      "func_body": "set_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t acl_type = 0;\n\tacl_t\t\t acl;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tacl_flagset_t\t acl_flagset;\n\tint\t\t r;\n#endif\n\tint\t\t ret;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tint\t\t perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tacl_type = ACL_TYPE_ACCESS;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tacl_type = ACL_TYPE_DEFAULT;\n\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tacl_type = ACL_TYPE_NFS4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tacl = acl_init(entries);\n\tif (acl == (acl_t)NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Failed to initialize ACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to create a new ACL entry\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER);\n\t\t\tacl_set_qualifier(acl_entry, &ae_uid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);\n\t\t\tacl_set_qualifier(acl_entry, &ae_gid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tacl_set_tag_type(acl_entry, ACL_MASK);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tacl_set_tag_type(acl_entry, ACL_OTHER);\n\t\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\tacl_set_tag_type(acl_entry, ACL_EVERYONE);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tr = 0;\n\t\tswitch (ae_type) {\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALLOW);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_DENY);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_AUDIT);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALARM);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\t// These don't translate directly into the system ACL.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to set ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#endif\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tif (acl_clear_perms(acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to clear ACL permissions\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\t}\n#endif\n\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tif (ae_permset & perm_map[i].a_perm) {\n\t\t\t\tif (acl_add_perm(acl_permset,\n\t\t\t\t    perm_map[i].p_perm) != 0) {\n\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t    \"Failed to add ACL permission\");\n\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\tgoto exit_free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/*\n\t\t\t * acl_get_flagset_np() fails with non-NFSv4 ACLs\n\t\t\t */\n\t\t\tif (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to get flagset from an NFSv4 \"\n\t\t\t\t    \"ACL entry\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tif (acl_clear_flags_np(acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to clear flags from an NFSv4 \"\n\t\t\t\t    \"ACL flagset\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif (ae_permset & acl_nfs4_flag_map[i].a_perm) {\n\t\t\t\t\tif (acl_add_flag_np(acl_flagset,\n\t\t\t\t\t    acl_nfs4_flag_map[i].p_perm) != 0) {\n\t\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t\t    \"Failed to add flag to \"\n\t\t\t\t\t\t    \"NFSv4 ACL flagset\");\n\t\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\t\tgoto exit_free;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Try restoring the ACL through 'fd' if we can. */\n\tif (fd >= 0) {\n\t\tif (acl_set_fd_np(fd, acl, acl_type) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t}\n#if HAVE_ACL_SET_LINK_NP\n\telse if (acl_set_link_np(name, acl_type, acl) != 0)\n#else\n\t/* FreeBSD older than 8.0 */\n\telse if (acl_set_file(name, acl_type, acl) != 0)\n#endif\n\t{\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tacl_free(acl);\n\treturn (ret);\n}",
      "line_statements": [
        [
          322,
          "    struct archive_acl *abstract_acl,"
        ],
        [
          545,
          "\telse if (acl_set_file(name, acl_type, acl) != 0)"
        ]
      ],
      "statements": [
        [
          321,
          "set_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t acl_type = 0;"
        ],
        [
          545,
          "else if (acl_set_file(name, acl_type, acl) != 0)\n#endif"
        ]
      ],
      "cve": "CVE-2021-23177"
    }
  ],
  "CWE-908": [
    {
      "commit_id": "00622428bda8d7521db8d74260b519fa41d69d0a",
      "filepath": "libvips/iofuncs/memory.c",
      "project": "libvips",
      "project_repo_path": "symbol_backend_projects/libvips",
      "is_vulnerable": true,
      "func_name": "vips_malloc",
      "func_body": "vips_malloc( VipsObject *object, size_t size )\n{\n\tvoid *buf;\n\n\tbuf = g_malloc( size );\n\n        if( object ) {\n\t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\n\treturn( buf );\n}",
      "line_statements": [
        [
          176,
          "\tbuf = g_malloc( size );"
        ]
      ],
      "statements": [
        [
          176,
          "buf = g_malloc( size );"
        ]
      ],
      "cve": "CVE-2019-6976"
    },
    {
      "commit_id": "da2311a6385c3b499da2ed5d9be59ce331fa93e9",
      "filepath": "drivers/net/can/usb/kvaser_usb/kvaser_usb_leaf.c",
      "project": "linux",
      "project_repo_path": "symbol_backend_projects/linux",
      "is_vulnerable": true,
      "func_name": "kvaser_usb_leaf_simple_cmd_async",
      "func_body": "static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\n\treturn err;\n}",
      "line_statements": [
        [
          611,
          "\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);"
        ]
      ],
      "statements": [
        [
          611,
          "cmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);"
        ]
      ],
      "cve": "CVE-2019-19947"
    }
  ]
}